{"meta":{"title":"Mr.li的小站","subtitle":"","description":"","author":"Mr.li","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Spring5-IOC","slug":"Spring5-IOC","date":"2022-04-30T01:04:29.000Z","updated":"2022-04-30T03:22:34.245Z","comments":true,"path":"2022/04/30/Spring5-IOC/","link":"","permalink":"http://example.com/2022/04/30/Spring5-IOC/","excerpt":"","text":"​ 花了两个星期的课余时间终于把Spring的大致内容学完了，今天先整理一些干货传上来。 IOC原理IOC（控制反转）就是依赖倒置原则的一种代码设计思路。 就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。 Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。 上面是比较官方的说法，据我理解其实 IOC 的意思是 “控制反转 ” 就是让Spring 帮我们管理对象，让对象在生存在框架上。平时我们不用框架去写代码的时候写出来的代码对象之间的耦合性很高，这样就造成了代码的可维护性极低，当我们需要更改某处的代码时就会造成连锁反应，一处改处处改。用了Spring之后Spring就会把对象都分开，减小耦合度，当我们需要修改代码的时候只需改改配置文件就OK了，也不需要担心每个对象之间复杂的关系。 其实Spring底层就是靠反射机制来完成的。 下面这张图就能很好的体现IOC机制 IOC的一些操作细节XML配置方式1.对象生成先把类写好，然和在xml中配置对象 1&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring5.User&quot;&gt;&lt;/bean&gt; id 相当于是给对象起个别名，com.atguigu.spring5.User 是类的全类名 用上述方法我们就可以实现一个对象的创建 2.XML实现属性注入属性注入有两中方式 1、用set方法进行属性注入 先生成每个属性的set方法，然后再在xml文件里进行配置 1234567891011121314151617181920212223242526package com.atguigu.spring5;/** * 演示实用set方法进行注入属性 */public class Book &#123; private String bname; private String bauthor; private String address; public void setBname(String bname) &#123; this.bname = bname; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public void setBauthor( String bauthor) &#123; this.bauthor = bauthor; &#125; public void testDemo()&#123; System.out.println(bname+&quot;----&gt;&quot;+bauthor+&quot;---&gt;&quot;+address); &#125;&#125; 123456789101112 &lt;!--2 set方法注入属性 --&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot;&gt; 实用property完成属性注入 &lt;property name=&quot;bname&quot; value=&quot;李锦超&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;达摩老祖祖&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;中国古代&quot;&gt;&lt;/property&gt; &lt;!-- 属性值包含特殊符号--&gt;&lt;!-- &lt;property name=&quot;address&quot; &gt;--&gt;&lt;!-- &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;--&gt;&lt;!-- &lt;/property&gt;--&gt; &lt;/bean&gt; 测试代码写法 123456789101112131415161718192021package com.atguigu.spring5.testdemo;import com.atguigu.spring5.config.SpringConfig;import com.atguigu.spring5.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring5Demo1 &#123; @Test public void testService()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125;&#125; 2、用构造器进行属性注入 一定要写构造方法，然后才能在xml中配置注入属性 1234&lt;bean id=&quot;orders&quot; class=&quot;com.atguigu.spring5.Orders&quot;&gt; &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 3、引入名称空间，简化属性注入 123&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p = &quot;http://www.springframework.org/schema/p&quot; 最下面的一行就是我引入的名称空间 p,我是这样写的：先复制第一行 xmlns&#x3D;”http://www.springframework.org/schema/beans&quot; 然后改成 第三行 xmlns:p &#x3D; “http://www.springframework.org/schema/p&quot; 这个样子就算引入名称空间 p 了，这个写法是固定的就只能这样写。 再进行属性注入，就可以这样写了 12&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot; p:bname=&quot;九阳神功&quot; p:bauthor=&quot;无名氏&quot;&gt;&lt;/bean&gt; 4.对象注入 对象作为属性注入有两种方式，内部bean和外部bean。 外部bean 写法 优势：可以给多个对象共享 先建两个类，其中一个类是接口实现类 123456789101112package com.atguigu.spring5.service;import com.atguigu.spring5.dao.UserDao;public class UserService &#123; //创建UserDao类型属性，生成set方法 private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 123456789package com.atguigu.spring5.dao;public class UserDaoImpl implements UserDao&#123; @Override public void update() &#123; System.out.println(&quot;dao update......&quot;); &#125;&#125; 用xml进行对象注入 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--service和dao对象创建 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring5.service.UserService&quot;&gt;&lt;!-- 注入userDao对象 name属性值，类里面属性名称 ref属性：创建userDao对象bean标签id值--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring5.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 内部bean写法 123456789101112&lt;!-- 内部bean--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;&lt;!-- 设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;李锦超&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;!-- 设置对象类型的属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 5.级联赋值 采用外部bean方式实现 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt; &lt;!-- 设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;王某&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- 级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;&lt;!-- &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 6.集合类型属性注入 这里面包含了含有对象的集合，由于时间原因我就直接贴代码了 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.spring5.collectiontype;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Stu &#123; //数组类型属性 private String[] courses; private List&lt;String&gt; list; private Map&lt;String,String&gt; maps; private Set&lt;String&gt; sets; //学生所学多门课程 private List&lt;Course&gt; courseList; public void setCourseList(List&lt;Course&gt; courseList) &#123; this.courseList = courseList; &#125; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125; public void setSets(Set&lt;String&gt; sets) &#123; this.sets = sets; &#125; public void test()&#123; System.out.println(Arrays.toString(courses)); System.out.println(list); System.out.println(maps); System.out.println(sets); System.out.println(courseList); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 1 集合类型属性注入--&gt; &lt;bean id=&quot;stu&quot; class=&quot;com.atguigu.spring5.collectiontype.Stu&quot;&gt;&lt;!-- 数组类型属性注入--&gt; &lt;property name=&quot;courses&quot;&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;value&gt;计算机网络&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!-- list类型属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;value&gt;三儿&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;!-- 注入list集合类型，值是对象--&gt; &lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- 创建多个course对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;MyBatis框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 8.利用名称空间实现公共集合属性 12345678910111213141516package com.atguigu.spring5.collectiontype;import java.util.List;public class Book &#123; private List&lt;String&gt; list; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void test()&#123; System.out.println(list); &#125;&#125; 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;&lt;!-- 1.提取list集合属性的注入--&gt; &lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;易筋经&lt;/value&gt; &lt;value&gt;九阴真经&lt;/value&gt; &lt;value&gt;九阳神功&lt;/value&gt; &lt;/util:list&gt;&lt;!-- 2、提取list集合属性的注入使用--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.collectiontype.Book&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 注意这里的名称空间还要在xsi:schemaLocation的双引号里额外的加上 http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd 9.bean的生命周期 大致可以分为五部分,细分的话有八部分 10.自动装配 有两种自动装配 根据属性名称 byName 根据属性类型 byType 这里我演示的是 byName 123456789101112131415161718192021package com.atguigu.spring5.autowire;public class Emp &#123; private Dept dept; public void setDept(Dept dept) &#123; this.dept = dept; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;dept=&quot; + dept + &#x27;&#125;&#x27;; &#125; public void test()&#123; System.out.println(dept); &#125;&#125; 1234package com.atguigu.spring5.autowire;public class Dept &#123;&#125; 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 实现自动装配 bean标签属性autowire,配置自动装配 autowire属性常用两个值：byName根据属性名称注入， 注入bean的id值要和属性名称一样 byType根据属性类型注入--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byName&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; XML加注解创建对象很多注解的意思我已经写成注释了，那就直接看代码 12345package com.atguigu.spring5.dao;public interface UserDao &#123; public void add();&#125; 12345678910111213package com.atguigu.spring5.dao;import org.springframework.stereotype.Repository;@Repository(value = &quot;userDaoImpl&quot;)public class UserDaoImpl implements UserDao&#123; @Override public void add() &#123; System.out.println(&quot;Dao add....&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.spring5.service;import com.atguigu.spring5.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import org.springframework.stereotype.Controller;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;//在注解里面value属性值可以不写//默认值是类名，首字母小写//UserService ---&gt; userService//@Service @Controller @Repository @Component//以上四个注解都可以用来创建对象，只不过用在不同的地方会更容易让人知道目前属于那一层@Component//相当于 &lt;bean id = &quot;userService&quot; class=&quot;.../&quot;/&gt;public class UserService &#123; //定义dao类型的属性 //不需要加set方法 //添加注入属性注解 @Autowired//只要这个注解的时候根据类型进行注入 @Qualifier(value = &quot;userDaoImpl&quot;)//加上这个就可以根据名称（指类的 id 值）进行注入 private UserDao userDao; @Value(value = &quot;李锦超&quot;) private String name; public void add()&#123; System.out.println(&quot;Service add....&quot;); userDao.add(); System.out.println(name); &#125;&#125; 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 开启组件扫描 1 如果扫描多个包，多个包用逗号隔开 2 或者扫描包上层目录 组件扫描的意思就是检查哪些类上面有 @Service @Controller @Repository @Component 这四个注解的其中之一就生成相应的对象，不再用bean标签去生成对象--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 示例1 use-default-filters=&quot;false&quot; 表示现在不使用默认filter context:include-filter 设置扫描哪些内容--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt;&lt;!-- 示例2 下面设置默认扫描所有内容 但是当我们加上 context:exclude-filter 就设置了哪些内容不进行扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; &gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 下面是测试代码的写法 1234567891011121314151617181920212223package com.atguigu.spring5.testdemo;import com.atguigu.spring5.config.SpringConfig;import com.atguigu.spring5.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring5Demo1 &#123; @Test public void testService2()&#123; //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125;&#125; 完全注解写法就是把上面的xml文件换成配置类就好了 下面是配置类 12345678910package com.atguigu.spring5.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration //作为配置类，替代xml配置文件@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)//开启组件扫描public class SpringConfig &#123;&#125; 好了，至此Spring的IOC就告一段落，以后有时间我会把底层原理了解一遍再发上来","categories":[],"tags":[]},{"title":"链表相加","slug":"链表相加","date":"2022-04-22T04:34:00.000Z","updated":"2022-04-22T05:09:17.526Z","comments":true,"path":"2022/04/22/链表相加/","link":"","permalink":"http://example.com/2022/04/22/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"今天牛客这题感觉很有意思，我硬是改了好几次才通过，他那个测试数据是真的长啊。 题目 思路1、先分别遍历两个链表，同时利用头插法逆转两个链表2、通过一我们成功的把链表的尾变成了头，这时我们就可以再一个循环里同时遍历两个链表，把他们对应的节点值相加。3、我们要注意两值相加进位的临界值是 9 ，因此我们必须考虑(sum + rem1)&#x3D;9、(sum + rem1)&lt;9、(sum + rem1)&gt;9这三种情况(sum表示两数相加的和，rem1表示进位数)这样做可以得到时间复杂度为O(n),空间复杂度为O(n). 上码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public static ListNode addInList (ListNode head1, ListNode head2) &#123; // write code here ListNode h1 = head1,h2 = head2; ListNode p1=null,p2=null; ListNode p3 = null,pSum = null; int k1=0,k2=0; while(h1!=null) &#123; ListNode temp = h1.next; h1.next = p1; p1 = h1; h1 = temp; k1++; &#125; while(h2!=null) &#123; ListNode temp = h2.next; h2.next = p2; p2 = h2; h2 = temp; k2++; &#125; int min = k1; if(k1&gt;k2) &#123; ListNode temp = p1; p1 = p2; p2 = temp; min = k2; &#125;; //sum为对应的两个数相加的和，rem和rem1用来存放进位数 int sum=0,rem=0,rem1=0; for(int i=0;p2!=null;i++,p2=p2.next) &#123; if(p1!=null&amp;&amp;p2!=null) &#123; sum = p1.val+p2.val; if((sum+rem1)&gt;9) &#123; sum = sum + rem1 - 10; rem = 1; &#125;else&#123; if((sum+rem1)==9)&#123; sum = sum + rem1; &#125;else&#123; if((sum+rem1)&lt;9)&#123; sum = sum + rem1; &#125;else&#123; if(sum&gt;9&amp;&amp;(rem1!=1)) &#123; sum = sum - 10; rem = 1; &#125; &#125; &#125; &#125; pSum = new ListNode(sum); pSum.next = p3; p3 = pSum; rem1 = rem; rem = 0; p1=p1.next; &#125; if(i&gt;=min) &#123; sum = p2.val; if((rem1+sum)&gt;9) &#123; sum = sum + rem1 - 10; rem = 1; &#125;else&#123; if((sum+rem1)==9)&#123; sum = sum + rem1; &#125;else&#123; if((sum+rem1)&lt;9)&#123; sum = sum + rem1; &#125; &#125; &#125; pSum = new ListNode(sum); pSum.next = p3; p3 = pSum; rem1 = rem; rem = 0; &#125; //System.out.println(i); &#125; if(rem1==1) &#123; pSum = new ListNode(1); pSum.next = p3; p3 = pSum; &#125; //output(p3); return p3; &#125; 结果","categories":[],"tags":[]},{"title":"牛客第三题","slug":"牛客第三题","date":"2022-04-16T15:20:18.000Z","updated":"2022-04-16T15:39:24.383Z","comments":true,"path":"2022/04/16/牛客第三题/","link":"","permalink":"http://example.com/2022/04/16/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%89%E9%A2%98/","excerpt":"","text":"今天又在牛客刷了一题，就单纯的想记录一下。 题目描述将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。 数据范围： 2000 0≤n≤2000 ， 20001≤k≤2000 ，链表中每个元素都满足 10000≤val≤1000要求空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)例如：给定的链表是 1→2→3→4→5对于 k &#x3D; 2k&#x3D;2 , 你应该返回 2→1→4→3→5对于 k &#x3D; 3k&#x3D;3 , 你应该返回 3→2→1→4→5 上码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static ListNode reverseKGroup (ListNode head, int k) &#123; /* * 我的大体思路就是每遍历k个节点就顺便放到栈里面，在栈里面把k个节点反转， * 然后再与后面的节点连起来 */ // write code here //如果链表为空或者k=1,就直接返回链表 if(head == null||k==1) &#123; return head; &#125; ListNode pre = head; ListNode temp=head,temp1= new ListNode(0); ListNode h =temp1,temp2=new ListNode(0); //用数组建一个栈，用来存k个节点 ListNode[] keyNode = new ListNode[k]; int keyCount = 0; int c=0; for(int i = 0;pre!=null;i++,keyCount++,c=i) &#123; if(i%k==0&amp;&amp;i!=0) &#123; temp2.next = keyNode[keyCount-1]; temp = keyNode[keyCount-1].next; for(int j = keyCount-1;j&gt;=0;j--) &#123; temp1.next = keyNode[j]; temp1 = keyNode[j]; &#125; temp2 = keyNode[0]; pre = temp; keyCount = 0; keyNode[keyCount] = pre; pre = pre.next; continue; &#125; //System.out.println(i); keyNode[keyCount] = pre; pre = pre.next; &#125; if(c&lt;k) &#123; return head; &#125; ListNode pp=null; if(c==k) &#123; for(int i = keyCount-1;i&gt;=0;i--) &#123; ListNode t = head.next; head.next = pp; pp = head; head = t; &#125; //output(pp); return pp; &#125; if(keyCount==k) &#123; for(int i = keyCount-1;i&gt;=0;i--) &#123;temp2.next = keyNode[i];temp2 = keyNode[i]; &#125; temp2.next=null; &#125;else &#123; for(int i = 0;i&lt;keyCount;i++) &#123; temp2.next = keyNode[i]; temp2 = keyNode[i]; &#125; &#125; //output(h); return h.next;&#125; 运行结果 这让我很意外","categories":[],"tags":[]},{"title":"AnswerPage","slug":"AnswerPage","date":"2022-04-15T01:13:10.000Z","updated":"2022-04-15T01:35:41.715Z","comments":true,"path":"2022/04/15/AnswerPage/","link":"","permalink":"http://example.com/2022/04/15/AnswerPage/","excerpt":"","text":"这两天小春同学向我求助帮他做一个答题网页。虽然感觉自己有很多事情都还没有做完，但是好哥们儿我肯定要帮啊。于是我就利用了三天的零碎时间做了这个网页，其实做完这个网页对我自己的收获也蛮大的。 AnswerPage需求：1、做一个由很多正方形组成的边框2、正方形边框里要有一个党徽在不断的移动3、让题目动态的显示，做完一题就可以进入下一题4、最后计算总分，用时其他的我就不多做赘述了，很多细节我已经写成注释混合在代码里了 上码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #content&#123;margin:20px auto 0px;&#125; .d2&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:40px;&#125; #contentbuttom&#123;margin:20px auto 0px;&#125; .d3&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:620px;&#125; #contentleft&#123;margin:20px auto 0px;&#125; .d4&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:130px;&#125; #contentright&#123;margin:20px auto 0px;&#125; .d5&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:1450px; top:130px;&#125; .move &#123; width: 80px; height: 80px; left:10px; top:40px; background-color: yellow; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var onOff = true; //获取body里面的div，返回值是数组 var d2 = document.getElementById(&#x27;content&#x27;).getElementsByTagName(&#x27;div&#x27;); var d3 = document.getElementById(&#x27;contentbuttom&#x27;).getElementsByTagName(&#x27;div&#x27;); var d4 = document.getElementById(&#x27;contentleft&#x27;).getElementsByTagName(&#x27;div&#x27;); var d5 = document.getElementById(&#x27;contentright&#x27;).getElementsByTagName(&#x27;div&#x27;); var d6 = document.getElementById(&#x27;mo&#x27;).getElementsByTagName(&#x27;div&#x27;); //生成最上面的墙(在id为content的div中生成17个div作为墙) function aa()&#123; document.getElementById(&#x27;content&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;17; i++)&#123; document.getElementById(&#x27;content&#x27;).innerHTML += &#x27;&lt;div class=&quot;d2&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d2[i].style.left = 10+(i*90)+&#x27;px&#x27;;//计算每个div间的距离 &#125; onOff = true; &#125; &#125; aa(); //生成最下面的墙(在id为contentbuttom的div中生成17个div作为墙) function bb()&#123; document.getElementById(&#x27;contentbuttom&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;17; i++)&#123; document.getElementById(&#x27;contentbuttom&#x27;).innerHTML += &#x27;&lt;div class=&quot;d3&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d3[i].style.left = 10+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; bb(); //生成左边的墙(在id为contentleft的div中生成5个div作为墙) function cc()&#123; document.getElementById(&#x27;contentleft&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;5; i++)&#123; document.getElementById(&#x27;contentleft&#x27;).innerHTML += &#x27;&lt;div class=&quot;d4&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d4[i].style.top = 150+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; cc(); //生成右边的墙(在id为contentright的div中生成5个div作为墙) function dd()&#123; document.getElementById(&#x27;contentright&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;5; i++)&#123; document.getElementById(&#x27;contentright&#x27;).innerHTML += &#x27;&lt;div class=&quot;d5&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d5[i].style.top = 150+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; dd(); //生成党徽(在id为mo的div中生成一个放党徽的div) function ee()&#123; document.getElementById(&#x27;mo&#x27;).innerHTML = &#x27;&#x27;; document.getElementById(&#x27;mo&#x27;).innerHTML += &#x27;&lt;div id=&quot;mm&quot; class=&quot;move&quot;&gt;&#x27;+&#x27;&lt;img src=&quot;https://tse2-mm.cn.bing.net/th/id/OIP-C.w7iifmShxQ8WNVHgRsnTRgHaHE?w=213&amp;h=204&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.25&amp;pid=1.7&quot; width=&quot;80&quot; height=&quot;80&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; &#125; ee(); //以下代码为控制党徽不断的在墙面上移动 m = document.getElementById(&#x27;mm&#x27;);//获取党徽所在的div的id var num1 = 10,num2=150,num3=600,num4=620;//这里初始化党徽运动到每一面墙的初始值 var x = 0,y=0;//这里用来定位党徽的位置 var flagx1 = true,flagx2=false,flagy1 = false,flagy2=false;//辅助变量 setInterval(function ()&#123; //在最上面的墙上运动 if((x&gt;=0&amp;&amp;x&lt;17)&amp;&amp;y==0)&#123; num2=150; flagx1=true; flagx2=false; flagy2=false; flagy1=false; m.style.top = 40 +&quot;px&quot;; m.style.left = num1 + &#x27;px&#x27;; num1 = num1 +90; &#125; //在右边的墙上运动 if(x==17&amp;&amp;(y&gt;=0&amp;&amp;y&lt;5))&#123; num4=num1-90; flagy1=true; flagx1=false; flagx2=false; flagy2=false; m.style.top = num2 +&#x27;px&#x27;; num2 = num2 + 90; &#125; //在最下面的墙上运动 if((x&lt;=17&amp;&amp;x&gt;0)&amp;&amp;y==5)&#123; num3=num2-90; flagx1=false; flagx2=true; flagy2=false; flagy1=false; m.style.top = 620 +&#x27;px&#x27;; m.style.left = num4 +&#x27;px&#x27;; num4 = num4 -90; &#125; //在最左边的墙上运动 if(x==0&amp;&amp;(y&lt;=5&amp;&amp;y&gt;0))&#123; num1 = 10 flagx1=false; flagx2=false; flagy2=true; flagy1=false; m.style.top = num3 +&#x27;px&#x27;; num3 = num3 -90; &#125; if(flagx1==true)&#123; x++; &#125; if(flagx2==true)&#123; x--; &#125; if(flagy1==true)&#123; y++ &#125; if(flagy2==true)&#123; y--; &#125; &#125;,300) var num = 10; /* setInterval(function()&#123; m.style.left = num +&#x27;px&#x27;; num = num +90; &#125;,500)*/ &#125; function $(id)&#123;//拿到html页里相应的id对象（这里的$相当于函数名,固定用法） return document.getElementById(id); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body background=&quot;https://tse1-mm.cn.bing.net/th/id/OIP-C.-Q5IrwV8dZ3PxjXIXW_ypwHaE8?pid=ImgDet&amp;rs=1&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var problems = new Array(9);//这个数组用来存放题目 problems[0] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[1] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[2] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; problems[3] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[4] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[5] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; problems[6] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[7] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[8] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; var arr = problems; var score_sum=0;//计分 // arr.push(problem1); //arr.push(problem2); //arr.push(problem3); for(let i=0;i&lt;3;i++)&#123; &#125; var k =0; var flag=false; //这些变量用来存放开始时间 var start_h=0 var start_m=0 var start_s=0 //这个函数用来控制下一题 function fun()&#123; judge(k,arr);//每点一次下一题按钮判断一次选项的值 k++; if(k==arr.length)&#123;//如果题目全部做完就把form删了，显示得分、用时 // alert(&quot;答题完毕！ &quot;+&quot;总得分：&quot;+score_sum); del(); var endtime = new Date(); var end_h = endtime.getHours(); var end_m = endtime.getMinutes(); var end_s = endtime.getSeconds(); var total_m=0; var total_s=0; //alert(&quot;结束时间：&quot;+end_m+&quot;分 &quot;+end_s+&quot;秒&quot;); //得到正确的时间 if(end_h!=start_h)&#123; total_m = (60-start_h)+end_m; if(end_m!=start_m)&#123; total_s = (60-start_s)+end_s; &#125;else&#123; total_s = end_s - start_s; &#125; &#125;else&#123; total_m = end_m - start_m; if(end_m!=start_m)&#123; total_s = (60-start_s)+end_s; &#125;else&#123; total_s = end_s - start_s; &#125; &#125; if(total_m&gt;0)&#123; total_m = total_m - 1; &#125; //alert(&quot;用时&quot;+total_m+&quot;分&quot;+total_s+&quot;秒&quot;); $(&#x27;replace&#x27;).innerHTML += &#x27;&lt;div style=&quot;margin-left: 150px;margin-top:150px; font-size:50px;color: rgb(23, 18, 168);&quot;&gt;&#x27;+&quot;总得分：&quot;+score_sum+ &quot;分 用时&quot;+total_m+ &quot;分钟&quot; +total_s+&#x27;秒&lt;/div&gt;&#x27;; &#125; //以下控制题目变化 document.getElementById(&#x27;a1&#x27;).innerHTML=arr[k].titile; document.getElementById(&#x27;a2&#x27;).innerHTML=arr[k].choice1; document.getElementById(&#x27;a3&#x27;).innerHTML=arr[k].choice2; document.getElementById(&#x27;a4&#x27;).innerHTML=arr[k].choice3; document.getElementById(&#x27;a5&#x27;).innerHTML=arr[k].choice4; //k++; &#125; function del()&#123;//删除form var elem = document.getElementById(&quot;myform&quot;); elem.parentNode.removeChild(elem); &#125; function judge(k,arr)&#123;//判断选项 var obj = document.getElementsByName(&#x27;ch&#x27;); var len = obj.length; //alert(k+&quot; &quot;+arr[k].answer); // alert(len) for(let j=0;true;j++)&#123; if(obj[j].checked==true)&#123; if(obj[j].value==arr[k].answer)&#123; score_sum = score_sum + 5; &#125; //alert(&quot;已选择&quot;+obj[j].value+&quot; 目前得分&quot;+score_sum); break; &#125; &#125; &#125; function au()&#123;//显示第一题 document.getElementById(&#x27;a1&#x27;).innerHTML=arr[0].titile; document.getElementById(&#x27;a2&#x27;).innerHTML=arr[0].choice1; document.getElementById(&#x27;a3&#x27;).innerHTML=arr[0].choice2; document.getElementById(&#x27;a4&#x27;).innerHTML=arr[0].choice3; document.getElementById(&#x27;a5&#x27;).innerHTML=arr[0].choice4; var starttime = new Date(); //获取开始时间 start_h = starttime.getHours(); start_m = starttime.getMinutes(); start_s = starttime.getSeconds(); //alert(&quot;开始时间：&quot;+start_m+&quot;分 &quot;+start_s+&quot;秒&quot;); //judge(0,arr); &#125; setTimeout(&quot;au()&quot;,1);//刚打开页面就显示第一个题目&lt;/script&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentbuttom&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentleft&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentright&quot;&gt;&lt;/div&gt;&lt;div id=&quot;mo&quot;&gt;&lt;/div&gt;&lt;div id=&quot;replace&quot;&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 500px;margin-top:300px; font-size:50px; color: rgb(134, 134, 137); position: absolute;&quot;&gt;我们一起来做题&lt;/div&gt;&lt;form style=&quot;margin-left: 200px;margin-top:200px;color: rgb(23, 18, 168);font-size: 20px;font-weight: bold;&quot; name=&quot;myform&quot; id=&quot;myform&quot;&gt;题目：&lt;label &gt;&lt;p id=&quot;a1&quot;&gt;&lt;/p&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;A&quot;&gt;A、&lt;label id=&quot;a2&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;B&quot;&gt;B、&lt;label id=&quot;a3&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;C&quot;&gt;C、&lt;label id=&quot;a4&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;D&quot;&gt;D、&lt;label id=&quot;a5&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; onclick=&quot;fun()&quot; name=&quot;next&quot; value=&quot;下一题&quot; style=&quot;font-size: 20px;color: blue;&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"反转链表","slug":"反转链表","date":"2022-04-10T01:24:55.000Z","updated":"2022-04-10T14:11:27.338Z","comments":true,"path":"2022/04/10/反转链表/","link":"","permalink":"http://example.com/2022/04/10/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"今天心血来潮想刷点题，于是就注册了牛客。没想到第一个题就是反转链表，啊这不是so easy吗。我火急火燎的就写完提交，没想到运行时间116ms,占用内存高达12948KB。代码我是用java写的，我看一些大神用Rust,C写竟然只花了2ms,300多KB,简直太牛了。后来我去看了一些题解把代码改进了一下，不用再去new空间，直接将原结点的指针反过来就ok了。 上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package p1;import java.util.Scanner;public class reverseLink &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ListNode h = create_list(); //output(h); ReverseList(h); &#125; public static ListNode create_list() &#123; Scanner input = new Scanner(System.in); int x=input.nextInt(); ListNode p=null,p1=null; ListNode h=new ListNode(input.nextInt()); p1=h; for(int i=0;i&lt;x-1;i++) &#123; p = new ListNode(input.nextInt()); p1.next = p; p1=p; p.next = null; &#125; return h; &#125; public static void output(ListNode h) &#123; while(h!=null) &#123; System.out.println(h.val); h=h.next; &#125; &#125; public static ListNode ReverseList(ListNode head) &#123; ListNode p=null,temp=null; //最巧的就是这个循环了 while(head!=null) &#123; //先让temp指向head.next节点,用来遍历链表 temp = head.next; //head.next指针指向p head.next = p; //让p指向head这个节点，这样下次循环的节点就可以和现在的节点连起来了 p = head; //这里再把刚刚temp保存的地址赋给head，继续遍历下一个节点 head = temp; &#125; while(p!=null) &#123; System.out.println(p.val); p=p.next; &#125; return new ListNode(1); &#125;&#125;class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 运行结果","categories":[],"tags":[]},{"title":"java编译器","slug":"java编译器","date":"2022-04-02T17:24:55.000Z","updated":"2022-04-02T17:53:14.675Z","comments":true,"path":"2022/04/03/java编译器/","link":"","permalink":"http://example.com/2022/04/03/java%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"java编译器今天偶然在网上看到一个java项目，就是用Java写一个Java编译器，只要会Javase就可以做。主要用到java里的几个包比如swing、io等。啊这不就很适合我做吗，于是我就跟着教程手敲了这个程序。由于时间问题，我就不写思路了，还有源代码我没有写注释，等有时间再来写吧。 FileWindow.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.Lijinchao.myedit;import java.awt.CardLayout;、import java.awt.Color;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.BufferedInputStream;import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JTextArea;import javax.swing.JTextField;public class FileWindow extends JFrame implements ActionListener,Runnable &#123; Thread compiler = null; Thread run_prom = null; boolean bn = true; CardLayout mycard; File file_saved = null; JButton button_input_txt, button_compiler_text, button_compiler, button_run_prom, button_see_doswin; JPanel p = new JPanel(); JTextArea input_text = new JTextArea(); JTextArea compiler_text = new JTextArea(); JTextArea dos_out_text = new JTextArea(); JTextField input_file_name_text = new JTextField(); JTextField run_file_name_text = new JTextField(); public FileWindow() &#123; super(&quot;JavaCompiler&quot;); mycard = new CardLayout(); compiler = new Thread(this); run_prom = new Thread(this); button_input_txt = new JButton(&quot;程序输入区(white)&quot;); button_compiler_text = new JButton(&quot;编译结果区(pink)&quot;); button_see_doswin = new JButton(&quot;程序执行结果(wathet)&quot;); button_compiler = new JButton(&quot;Compiler&quot;); button_run_prom = new JButton(&quot;Running&quot;); p.setLayout(mycard); p.add(&quot;input&quot;,input_text); p.add(&quot;compiler&quot;,compiler_text); p.add(&quot;dos&quot;,dos_out_text); add(p,&quot;Center&quot;); compiler_text.setBackground(Color.pink); dos_out_text.setBackground(Color.cyan); JPanel p1 = new JPanel(); p1.setLayout(new GridLayout(3,3)); p1.add(button_input_txt); p1.add(button_compiler_text); p1.add(button_see_doswin); p1.add(new JLabel(&quot;输入程序名称(.java)&quot;)); p1.add(input_file_name_text); p1.add(button_compiler); p1.add(new JLabel(&quot;输入程序主类名&quot;)); p1.add(run_file_name_text); p1.add(button_run_prom); add(p1,&quot;North&quot;); button_input_txt.addActionListener(this); button_compiler.addActionListener(this); button_compiler_text.addActionListener(this); button_run_prom.addActionListener(this); button_see_doswin.addActionListener(this); &#125; public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==button_input_txt) &#123; mycard.show(p,&quot;input&quot;); &#125;else if(e.getSource()==button_compiler_text) &#123; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_see_doswin) &#123; mycard.show(p, &quot;dos&quot;); &#125;else if(e.getSource()==button_compiler) &#123; if(!(compiler.isAlive())) &#123; compiler = new Thread(this); &#125; try &#123; compiler.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_run_prom) &#123; if(!(run_prom.isAlive())) &#123; run_prom = new Thread(this); &#125; try &#123; run_prom.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;dos&quot;); &#125; &#125; public void run() &#123; if(Thread.currentThread()==compiler) &#123; compiler_text.setText(null); String temp = input_text.getText().trim(); byte [] buffer = temp.getBytes(); int b = buffer.length; String file_name = null; file_name = input_file_name_text.getText().trim(); try &#123; file_saved = new File(file_name); FileOutputStream writefile = null; writefile = new FileOutputStream(file_saved); writefile.write(buffer, 0, b); writefile.close(); &#125;catch (Exception e) &#123; System.out.println(&quot;ERROR&quot;); &#125; try &#123; Runtime rt = Runtime.getRuntime(); InputStream in = rt.exec(&quot;javac &quot;+file_name).getErrorStream(); BufferedInputStream bufIn = new BufferedInputStream(in); byte[] shuzu = new byte[100]; int n=0; boolean flag = true; while((n=bufIn.read(shuzu,0,shuzu.length))!=-1) &#123; String s = null; s = new String(shuzu,0,n); compiler_text.append(s); if(s!=null) &#123; flag = false; &#125; &#125; if(flag) &#123; compiler_text.append(&quot;Compiler Succeed!&quot;); &#125; &#125; catch (Exception e) &#123; &#125; &#125; else if(Thread.currentThread()==run_prom) &#123; dos_out_text.setText(null); try &#123; Runtime rt = Runtime.getRuntime(); String path = run_file_name_text.getText().trim(); Process stream = rt.exec(&quot;java &quot;+path); InputStream in = stream.getInputStream(); BufferedInputStream bisErr = new BufferedInputStream(stream.getErrorStream()); BufferedInputStream bisIn = new BufferedInputStream(in); byte[] buf = new byte[150]; byte[] err_buf = new byte[150]; int m=0; int i=0; String s = null; String err = null; while((m = bisIn.read(buf, 0, 150))!=-1) &#123; s = new String(buf,0,150); dos_out_text.append(s); &#125; while((i = bisErr.read(err_buf))!=-1) &#123; &#123; err = new String(err_buf,0,150); dos_out_text.append(err); &#125; &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; Main.java12345678910111213141516171819202122package com.Lijinchao.myedit;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub FileWindow win = new FileWindow(); win.pack(); win.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); win.setBounds(200,180,550,360); win.setVisible(true); &#125;&#125; 运行结果点Running出现这样的画面就说明没问题了 正确运行需要在程序输入区输入代码，记住程序名称一定要.java作为后缀,并且程序名称一定要和主类名同名，主类名没有后缀。 1.先在程序输入区写好代码 2.点击Compiler编译 3.点击Running运行","categories":[],"tags":[]},{"title":"利用python爬取网页表情包","slug":"python爬虫","date":"2022-03-26T07:11:26.000Z","updated":"2022-04-15T01:39:34.806Z","comments":true,"path":"2022/03/26/python爬虫/","link":"","permalink":"http://example.com/2022/03/26/python%E7%88%AC%E8%99%AB/","excerpt":"","text":"今天刷着刷着视频，突然刷到一个关于python爬虫的视频，瞬间激起了我对爬虫的好奇心。刚好我以前学过一点python的知识，这会儿终于派上用场了。于是我上网借鉴了一些资料写了这个爬虫代码 requests,re知识想要写爬虫代码我们需要先了解这两个包。requests是一个很实用的python HTTP客户端库，编写爬虫这个包必不可少。这是我们常用的方法：requests.get()：获取HTML网页的主要方法，对应于HTTP的GET。re模块创建一个“规则表达式”，用于验证和查找符合规则的文本，广泛用于各种搜索引擎，账号密码的验证等。这是我们常用的两个方法：findall：扫描整个目标文本，返回所有与规则匹配的子串组成的列表，如果没有匹配的返回空列表。split：从与规则匹配的子串进行切割，返回切割后子串组成的列表。 爬虫编写步骤找表情包网站https://www.biaoqingba.net/hot.html 这个网址就是我爬表情包的网站，每个网站都有自己的HTML网页，所以我们需要简单的分析一下网页的HTML代码，便于写正则表达式，这里我就不多说了，直接看图。 获取URL，并且发起请求首先，我们想要下载表情包，就需要先获取网页的url，get方法里的网址就是url，可以上百度找到一个网页，然后复制链接就好。requests.get()就发起了一个请求。 1response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;) 利用正则表达式筛选数据在img标签中提取我们想要的内容，比如表情包的url,名字等 123re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text) 保存数据这里我们写一个download方法来保存数据。 12345678910111213# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix) 这里是源代码123456789101112131415161718192021222324252627282930313233343536373839import reimport osimport requests# https://www.biaoqingba.net/hot.html，这是我爬表情包的网页# 创建一个文件用来放表情包，images为文件名images = &#x27;images&#x27;# 如果文件不存在，就新建一个if not os.path.exists(images): os.mkdir(images)# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix)response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;)# print(response.text) 打印所请求网页的内容，其实就是网页的实现代码# 这行代码用了正则表达式来提取img标签的内容，src的引号内就是表情包链接，(.*?)表示# 只要是引号内的内容都要re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text)# print(result)# 循环获取result数组内的每个元素，调用download函数下载表情包for img in result: print(img) download(img[1], img[0]) # img[1]为name,img[0]为url 运行结果爬了满满一文件夹的表情包，真爽！","categories":[],"tags":[]},{"title":"Socket","slug":"page","date":"2022-03-21T01:34:55.000Z","updated":"2022-04-02T16:53:05.986Z","comments":true,"path":"2022/03/21/page/","link":"","permalink":"http://example.com/2022/03/21/page/","excerpt":"","text":"什么是Socket呢？Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。简言之，我们的QQ或者微信发送消息和接受消息的功能，底层就是用Socket实现的。废话不多说，直接上代码。 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package SeverAndClient;/** * @author 超 * 这里是服务器，开启两个线程，一个是接收消息的，一个是发送消息的 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class sever extends Thread&#123; ServerSocket server = null;//先定义一个服务Socket Socket socket = null; public sever(int port) &#123;//直接利用构造方法传入端口号 try &#123; server = new ServerSocket(port);//实例化ServerSocket &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run()&#123; super.run(); try&#123; System.out.println(&quot;wait client connect...&quot;); socket = server.accept();//等待客户端连接 new sendMessThread().start();//连接并返回socket后，再启用发送消息线程 System.out.println(socket.getInetAddress().getHostAddress()+&quot;SUCCESS TO CONNECT...&quot;); InputStream in = socket.getInputStream();//利用IO流获取信息 int len = 0; byte[] buf = new byte[1024];//这个用来缓冲数据 while ((len=in.read(buf))!=-1)&#123; System.out.println(&quot;client saying: &quot;+new String(buf,0,len)); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //这个就是发送消息的线程 class sendMessThread extends Thread&#123; @Override public void run()&#123; super.run(); Scanner scanner=null; OutputStream out = null; try&#123; if(socket != null)&#123; scanner = new Scanner(System.in); out = socket.getOutputStream(); String in = &quot;&quot;; do &#123; in = scanner.next();//输入数据 out.write((&quot;server saying: &quot;+in).getBytes()); out.flush();//清空缓存区的内容 &#125;while (!in.equals(&quot;q&quot;)); scanner.close(); try&#123; out.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; sever server = new sever(1234); server.start();//启动线程 &#125;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package SeverAndClient;/** * @author 超 * 这里是客户端 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;public class client extends Thread &#123; //定义一个Socket对象 Socket socket = null; public client(String host, int port) &#123; try &#123; //需要服务器的IP地址和端口号，才能获得正确的Socket对象 socket = new Socket(host, port);//host为服务器的ip地址，port为服务器的端口号 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; //客户端一连接就可以写数据个服务器了 new sendMessThread().start(); super.run(); try &#123; // 读Sock里面的数据 InputStream s = socket.getInputStream(); byte[] buf = new byte[1024];//缓冲数据 int len = 0; while ((len = s.read(buf)) != -1) &#123; System.out.println(new String(buf, 0, len)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //往Socket里面写数据，需要新开一个线程 class sendMessThread extends Thread&#123; @Override public void run() &#123; super.run(); //写操作 Scanner scanner=null; OutputStream os= null; try &#123; scanner=new Scanner(System.in); os= socket.getOutputStream(); String in=&quot;&quot;; do &#123; in=scanner.next();//输入数据 os.write((&quot;&quot;+in).getBytes()); os.flush(); &#125; while (!in.equals(&quot;bye&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; scanner.close(); try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; //需要服务器的正确的IP地址和端口号 client clientTest=new client(&quot;127.0.0.1&quot;, 8000);//127.0.0.1为测试专用ip,如果你想连另一台主机，就把ip换了 clientTest.start();//启动线程 &#125;&#125; 运行结果记住！一定要先运行服务器。","categories":[],"tags":[]}],"categories":[],"tags":[]}