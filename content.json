{"meta":{"title":"Mr.li的小站","subtitle":"","description":"","author":"Mr.li","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"反转链表","slug":"反转链表","date":"2022-04-10T01:24:55.000Z","updated":"2022-04-10T14:11:27.338Z","comments":true,"path":"2022/04/10/反转链表/","link":"","permalink":"http://example.com/2022/04/10/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"今天心血来潮想刷点题，于是就注册了牛客。没想到第一个题就是反转链表，啊这不是so easy吗。我火急火燎的就写完提交，没想到运行时间116ms,占用内存高达12948KB。代码我是用java写的，我看一些大神用Rust,C写竟然只花了2ms,300多KB,简直太牛了。后来我去看了一些题解把代码改进了一下，不用再去new空间，直接将原结点的指针反过来就ok了。 上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package p1;import java.util.Scanner;public class reverseLink &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ListNode h = create_list(); //output(h); ReverseList(h); &#125; public static ListNode create_list() &#123; Scanner input = new Scanner(System.in); int x=input.nextInt(); ListNode p=null,p1=null; ListNode h=new ListNode(input.nextInt()); p1=h; for(int i=0;i&lt;x-1;i++) &#123; p = new ListNode(input.nextInt()); p1.next = p; p1=p; p.next = null; &#125; return h; &#125; public static void output(ListNode h) &#123; while(h!=null) &#123; System.out.println(h.val); h=h.next; &#125; &#125; public static ListNode ReverseList(ListNode head) &#123; ListNode p=null,temp=null; //最巧的就是这个循环了 while(head!=null) &#123; //先让temp指向head.next节点,用来遍历链表 temp = head.next; //head.next指针指向p head.next = p; //让p指向head这个节点，这样下次循环的节点就可以和现在的节点连起来了 p = head; //这里再把刚刚temp保存的地址赋给head，继续遍历下一个节点 head = temp; &#125; while(p!=null) &#123; System.out.println(p.val); p=p.next; &#125; return new ListNode(1); &#125;&#125;class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 运行结果","categories":[],"tags":[]},{"title":"java编译器","slug":"java编译器","date":"2022-04-02T17:24:55.000Z","updated":"2022-04-02T17:53:14.675Z","comments":true,"path":"2022/04/03/java编译器/","link":"","permalink":"http://example.com/2022/04/03/java%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"java编译器今天偶然在网上看到一个java项目，就是用Java写一个Java编译器，只要会Javase就可以做。主要用到java里的几个包比如swing、io等。啊这不就很适合我做吗，于是我就跟着教程手敲了这个程序。由于时间问题，我就不写思路了，还有源代码我没有写注释，等有时间再来写吧。 FileWindow.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.Lijinchao.myedit;import java.awt.CardLayout;、import java.awt.Color;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.BufferedInputStream;import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JTextArea;import javax.swing.JTextField;public class FileWindow extends JFrame implements ActionListener,Runnable &#123; Thread compiler = null; Thread run_prom = null; boolean bn = true; CardLayout mycard; File file_saved = null; JButton button_input_txt, button_compiler_text, button_compiler, button_run_prom, button_see_doswin; JPanel p = new JPanel(); JTextArea input_text = new JTextArea(); JTextArea compiler_text = new JTextArea(); JTextArea dos_out_text = new JTextArea(); JTextField input_file_name_text = new JTextField(); JTextField run_file_name_text = new JTextField(); public FileWindow() &#123; super(&quot;JavaCompiler&quot;); mycard = new CardLayout(); compiler = new Thread(this); run_prom = new Thread(this); button_input_txt = new JButton(&quot;程序输入区(white)&quot;); button_compiler_text = new JButton(&quot;编译结果区(pink)&quot;); button_see_doswin = new JButton(&quot;程序执行结果(wathet)&quot;); button_compiler = new JButton(&quot;Compiler&quot;); button_run_prom = new JButton(&quot;Running&quot;); p.setLayout(mycard); p.add(&quot;input&quot;,input_text); p.add(&quot;compiler&quot;,compiler_text); p.add(&quot;dos&quot;,dos_out_text); add(p,&quot;Center&quot;); compiler_text.setBackground(Color.pink); dos_out_text.setBackground(Color.cyan); JPanel p1 = new JPanel(); p1.setLayout(new GridLayout(3,3)); p1.add(button_input_txt); p1.add(button_compiler_text); p1.add(button_see_doswin); p1.add(new JLabel(&quot;输入程序名称(.java)&quot;)); p1.add(input_file_name_text); p1.add(button_compiler); p1.add(new JLabel(&quot;输入程序主类名&quot;)); p1.add(run_file_name_text); p1.add(button_run_prom); add(p1,&quot;North&quot;); button_input_txt.addActionListener(this); button_compiler.addActionListener(this); button_compiler_text.addActionListener(this); button_run_prom.addActionListener(this); button_see_doswin.addActionListener(this); &#125; public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==button_input_txt) &#123; mycard.show(p,&quot;input&quot;); &#125;else if(e.getSource()==button_compiler_text) &#123; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_see_doswin) &#123; mycard.show(p, &quot;dos&quot;); &#125;else if(e.getSource()==button_compiler) &#123; if(!(compiler.isAlive())) &#123; compiler = new Thread(this); &#125; try &#123; compiler.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_run_prom) &#123; if(!(run_prom.isAlive())) &#123; run_prom = new Thread(this); &#125; try &#123; run_prom.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;dos&quot;); &#125; &#125; public void run() &#123; if(Thread.currentThread()==compiler) &#123; compiler_text.setText(null); String temp = input_text.getText().trim(); byte [] buffer = temp.getBytes(); int b = buffer.length; String file_name = null; file_name = input_file_name_text.getText().trim(); try &#123; file_saved = new File(file_name); FileOutputStream writefile = null; writefile = new FileOutputStream(file_saved); writefile.write(buffer, 0, b); writefile.close(); &#125;catch (Exception e) &#123; System.out.println(&quot;ERROR&quot;); &#125; try &#123; Runtime rt = Runtime.getRuntime(); InputStream in = rt.exec(&quot;javac &quot;+file_name).getErrorStream(); BufferedInputStream bufIn = new BufferedInputStream(in); byte[] shuzu = new byte[100]; int n=0; boolean flag = true; while((n=bufIn.read(shuzu,0,shuzu.length))!=-1) &#123; String s = null; s = new String(shuzu,0,n); compiler_text.append(s); if(s!=null) &#123; flag = false; &#125; &#125; if(flag) &#123; compiler_text.append(&quot;Compiler Succeed!&quot;); &#125; &#125; catch (Exception e) &#123; &#125; &#125; else if(Thread.currentThread()==run_prom) &#123; dos_out_text.setText(null); try &#123; Runtime rt = Runtime.getRuntime(); String path = run_file_name_text.getText().trim(); Process stream = rt.exec(&quot;java &quot;+path); InputStream in = stream.getInputStream(); BufferedInputStream bisErr = new BufferedInputStream(stream.getErrorStream()); BufferedInputStream bisIn = new BufferedInputStream(in); byte[] buf = new byte[150]; byte[] err_buf = new byte[150]; int m=0; int i=0; String s = null; String err = null; while((m = bisIn.read(buf, 0, 150))!=-1) &#123; s = new String(buf,0,150); dos_out_text.append(s); &#125; while((i = bisErr.read(err_buf))!=-1) &#123; &#123; err = new String(err_buf,0,150); dos_out_text.append(err); &#125; &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; Main.java12345678910111213141516171819202122package com.Lijinchao.myedit;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub FileWindow win = new FileWindow(); win.pack(); win.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); win.setBounds(200,180,550,360); win.setVisible(true); &#125;&#125; 运行结果点Running出现这样的画面就说明没问题了 正确运行需要在程序输入区输入代码，记住程序名称一定要.java作为后缀,并且程序名称一定要和主类名同名，主类名没有后缀。 1.先在程序输入区写好代码 2.点击Compiler编译 3.点击Running运行","categories":[],"tags":[]},{"title":"利用python爬取网页表情包","slug":"python爬虫","date":"2022-03-26T07:11:26.000Z","updated":"2022-04-02T17:09:06.818Z","comments":true,"path":"2022/03/26/python爬虫/","link":"","permalink":"http://example.com/2022/03/26/python%E7%88%AC%E8%99%AB/","excerpt":"","text":"今天刷着刷着视频，突然刷到一个关于python爬虫的视频，瞬间激起了我对爬虫的好奇心。刚好我以前学过一点python的知识，这会儿终于派上用场了。于是我上网借鉴了一些资料写了这个爬虫代码 requests,re知识想要写爬虫代码我们需要先了解这两个包。requests是一个很实用的python HTTP客户端库，编写爬虫这个包必不可少。这是我们常用的方法：requests.get()：获取HTML网页的主要方法，对应于HTTP的GET。re模块创建一个“规则表达式”，用于验证和查找符合规则的文本，广泛用于各种搜索引擎，账号密码的验证等。这是我们常用的两个方法：findall：扫描整个目标文本，返回所有与规则匹配的子串组成的列表，如果没有匹配的返回空列表。split：从与规则匹配的子串进行切割，返回切割后子串组成的列表。 爬虫编写步骤找表情包网站https://www.biaoqingba.net/hot.html，这个网址就是我爬表情包的网站，每个网站都有自己的HTML网页，所以我们需要简单的分析一下网页的HTML代码，便于写正则表达式，这里我就不多说了，直接看图。 获取URL，并且发起请求首先，我们想要下载表情包，就需要先获取网页的url，get方法里的网址就是url，可以上百度找到一个网页，然后复制链接就好。requests.get()就发起了一个请求。 1response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;) 利用正则表达式筛选数据在img标签中提取我们想要的内容，比如表情包的url,名字等 123re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text) 保存数据这里我们写一个download方法来保存数据。 12345678910111213# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix) 这里是源代码我本来想传一些具体操作截图上来的，奈何由于一些技术没有解决，传不了（太难受了）。 123456789101112131415161718192021222324252627282930313233343536373839import reimport osimport requests# https://www.biaoqingba.net/hot.html，这是我爬表情包的网页# 创建一个文件用来放表情包，images为文件名images = &#x27;images&#x27;# 如果文件不存在，就新建一个if not os.path.exists(images): os.mkdir(images)# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix)response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;)# print(response.text) 打印所请求网页的内容，其实就是网页的实现代码# 这行代码用了正则表达式来提取img标签的内容，src的引号内就是表情包链接，(.*?)表示# 只要是引号内的内容都要re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text)# print(result)# 循环获取result数组内的每个元素，调用download函数下载表情包for img in result: print(img) download(img[1], img[0]) # img[1]为name,img[0]为url 运行结果爬了满满一文件夹的表情包，真爽！","categories":[],"tags":[]},{"title":"Socket","slug":"page","date":"2022-03-21T01:34:55.000Z","updated":"2022-04-02T16:53:05.986Z","comments":true,"path":"2022/03/21/page/","link":"","permalink":"http://example.com/2022/03/21/page/","excerpt":"","text":"什么是Socket呢？Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。简言之，我们的QQ或者微信发送消息和接受消息的功能，底层就是用Socket实现的。废话不多说，直接上代码。 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package SeverAndClient;/** * @author 超 * 这里是服务器，开启两个线程，一个是接收消息的，一个是发送消息的 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class sever extends Thread&#123; ServerSocket server = null;//先定义一个服务Socket Socket socket = null; public sever(int port) &#123;//直接利用构造方法传入端口号 try &#123; server = new ServerSocket(port);//实例化ServerSocket &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run()&#123; super.run(); try&#123; System.out.println(&quot;wait client connect...&quot;); socket = server.accept();//等待客户端连接 new sendMessThread().start();//连接并返回socket后，再启用发送消息线程 System.out.println(socket.getInetAddress().getHostAddress()+&quot;SUCCESS TO CONNECT...&quot;); InputStream in = socket.getInputStream();//利用IO流获取信息 int len = 0; byte[] buf = new byte[1024];//这个用来缓冲数据 while ((len=in.read(buf))!=-1)&#123; System.out.println(&quot;client saying: &quot;+new String(buf,0,len)); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //这个就是发送消息的线程 class sendMessThread extends Thread&#123; @Override public void run()&#123; super.run(); Scanner scanner=null; OutputStream out = null; try&#123; if(socket != null)&#123; scanner = new Scanner(System.in); out = socket.getOutputStream(); String in = &quot;&quot;; do &#123; in = scanner.next();//输入数据 out.write((&quot;server saying: &quot;+in).getBytes()); out.flush();//清空缓存区的内容 &#125;while (!in.equals(&quot;q&quot;)); scanner.close(); try&#123; out.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; sever server = new sever(1234); server.start();//启动线程 &#125;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package SeverAndClient;/** * @author 超 * 这里是客户端 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;public class client extends Thread &#123; //定义一个Socket对象 Socket socket = null; public client(String host, int port) &#123; try &#123; //需要服务器的IP地址和端口号，才能获得正确的Socket对象 socket = new Socket(host, port);//host为服务器的ip地址，port为服务器的端口号 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; //客户端一连接就可以写数据个服务器了 new sendMessThread().start(); super.run(); try &#123; // 读Sock里面的数据 InputStream s = socket.getInputStream(); byte[] buf = new byte[1024];//缓冲数据 int len = 0; while ((len = s.read(buf)) != -1) &#123; System.out.println(new String(buf, 0, len)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //往Socket里面写数据，需要新开一个线程 class sendMessThread extends Thread&#123; @Override public void run() &#123; super.run(); //写操作 Scanner scanner=null; OutputStream os= null; try &#123; scanner=new Scanner(System.in); os= socket.getOutputStream(); String in=&quot;&quot;; do &#123; in=scanner.next();//输入数据 os.write((&quot;&quot;+in).getBytes()); os.flush(); &#125; while (!in.equals(&quot;bye&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; scanner.close(); try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; //需要服务器的正确的IP地址和端口号 client clientTest=new client(&quot;127.0.0.1&quot;, 8000);//127.0.0.1为测试专用ip,如果你想连另一台主机，就把ip换了 clientTest.start();//启动线程 &#125;&#125; 运行结果记住！一定要先运行服务器。","categories":[],"tags":[]}],"categories":[],"tags":[]}