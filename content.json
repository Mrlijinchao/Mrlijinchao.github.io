{"meta":{"title":"Mr.li的小站","subtitle":"","description":"","author":"Mr.li","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"MyBatis-Plus","slug":"MyBatis-Plus","date":"2022-08-28T06:15:04.000Z","updated":"2022-08-28T13:48:37.912Z","comments":true,"path":"2022/08/28/MyBatis-Plus/","link":"","permalink":"http://example.com/2022/08/28/MyBatis-Plus/","excerpt":"","text":"一、MyBatis-Plus简介MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 它有以下特性： 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 二、MyBatis-Plus项目构建1、关键依赖12345678910111213141516171819&lt;!-- mybatis-plus启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt;&lt;!-- lombok 用于简化实体类开发--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;!-- mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.43&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 2、application.yml配置文件12345678910spring:# 配置数据源学习 datasource:# 配置数据源类型 type: com.zaxxer.hikari.HikariDataSource# 配置连接数据库的各个信息 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;userSSL=false username: root password: ljc625995 注意： 1)、驱动类driver-class-namespring boot 2.0（内置jdbc5驱动），驱动类使用： driver-class-name: com.mysql.jdbc.Driverspring boot 2.1及以上（内置jdbc8驱动），驱动类使用：driver-class-name: com.mysql.cj.jdbc.Driver否则运行测试用例的时候会有 WARN 信息2)、连接地址urlMySQL5.7版本的url：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis_plus?characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;falseMySQL8.0版本的url：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis_plus?serverTimezone&#x3D;GMT%2B8&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false否则运行测试用例报告如下错误：java.sql.SQLException: The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized orrepresents more 3、启动类12345678910@SpringBootApplication//扫描mapper接口所在的包@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)public class MybatisplusApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisplusApplication.class, args); &#125;&#125; 4、实体类123456789//这个是lombok的注解，加上这个注解后，就会自动生成getter，setter，// 无参构造，ToString等一堆方法，使代码更简介@Datapublic class User &#123;private Long id;private String name;private Integer age;private String email;&#125; 5、写mapper接口BaseMapper是MyBatis-Plus提供的模板mapper，其中包含了基本的CRUD方法，泛型为需要操作的实体类型。也就是只要继承了这个模板mapper,很多基本的增删改查的sql语句都不需要我们自己写了，直接调用方法就行 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 5、添加日志1234# 让控制台输出mybatisplus帮我们生成的sql语句mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 测试：123456@Testpublic void testSelectList()&#123; //通过条件构造器查询一个list集合人，若没有条件，则可以设置null为参数 List&lt;User&gt; list = userMapper.selectList(null); list.forEach(System.out::println);&#125; 结果： 三、基本CRUD1、BaseMapperMyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，我们可以直接使用，接口如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/** * Mapper 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能 * &lt;p&gt;这个 Mapper 支持 id 泛型&lt;/p&gt; * * @author hubin * @since 2016-01-23 */public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt; &#123; /** * 插入一条记录 * * @param entity 实体对象 */ int insert(T entity); /** * 根据 ID 删除 * * @param id 主键ID */ int deleteById(Serializable id); /** * 根据实体(ID)删除 * * @param entity 实体对象 * @since 3.4.4 */ int deleteById(T entity); /** * 根据 columnMap 条件，删除记录 * * @param columnMap 表字段 map 对象 */ int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); /** * 根据 entity 条件，删除记录 * * @param queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） */ int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 删除（根据ID或实体 批量删除） * * @param idList 主键ID列表或实体列表(不能为 null 以及 empty) */ int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;?&gt; idList); /** * 根据 ID 修改 * * @param entity 实体对象 */ int updateById(@Param(Constants.ENTITY) T entity); /** * 根据 whereEntity 条件，更新记录 * * @param entity 实体对象 (set 条件值,可以为 null) * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） */ int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; updateWrapper); /** * 根据 ID 查询 * * @param id 主键ID */ T selectById(Serializable id); /** * 查询（根据ID 批量查询） * * @param idList 主键ID列表(不能为 null 以及 empty) */ List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); /** * 查询（根据 columnMap 条件） * * @param columnMap 表字段 map 对象 */ List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); /** * 根据 entity 条件，查询一条记录 * &lt;p&gt;查询一条记录，例如 qw.last(&quot;limit 1&quot;) 限制取一条记录, 注意：多条数据会报异常&lt;/p&gt; * * @param queryWrapper 实体对象封装操作类（可以为 null） */ default T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper) &#123; List&lt;T&gt; ts = this.selectList(queryWrapper); if (CollectionUtils.isNotEmpty(ts)) &#123; if (ts.size() != 1) &#123; throw ExceptionUtils.mpe(&quot;One record is expected, but the query result is multiple records&quot;); &#125; return ts.get(0); &#125; return null; &#125; /** * 根据 Wrapper 条件，判断是否存在记录 * * @param queryWrapper 实体对象封装操作类 * @return */ default boolean exists(Wrapper&lt;T&gt; queryWrapper) &#123; Long count = this.selectCount(queryWrapper); return null != count &amp;&amp; count &gt; 0; &#125; /** * 根据 Wrapper 条件，查询总记录数 * * @param queryWrapper 实体对象封装操作类（可以为 null） */ Long selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 entity 条件，查询全部记录 * * @param queryWrapper 实体对象封装操作类（可以为 null） */ List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 Wrapper 条件，查询全部记录 * * @param queryWrapper 实体对象封装操作类（可以为 null） */ List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 Wrapper 条件，查询全部记录 * &lt;p&gt;注意： 只返回第一个字段的值&lt;/p&gt; * * @param queryWrapper 实体对象封装操作类（可以为 null） */ List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 entity 条件，查询全部记录（并翻页） * * @param page 分页查询条件（可以为 RowBounds.DEFAULT） * @param queryWrapper 实体对象封装操作类（可以为 null） */ &lt;P extends IPage&lt;T&gt;&gt; P selectPage(P page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 Wrapper 条件，查询全部记录（并翻页） * * @param page 分页查询条件 * @param queryWrapper 实体对象封装操作类 */ &lt;P extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; P selectMapsPage(P page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);&#125; 2、插入12345678910111213 @Test public void testInsert()&#123;// 实现新增用户信息// INSERT INTO user ( id, name, age, email ) VALUES ( ?, ?, ?, ? ) User user = new User();// user.setId(100L); user.setAge(99); user.setEmail(&quot;2116639781@qq.com&quot;); user.setName(&quot;李艾&quot;); int insert = userMapper.insert(user); System.out.println(&quot;insert:&quot;+insert); System.out.println(&quot;userId:&quot;+user.getId()); &#125; 3、删除1）通过id删除记录 1234567@Testpublic void testDeleteById()&#123;//通过id删除用户信息//DELETE FROM user WHERE id=?int result = userMapper.deleteById(1475754982694199298L);System.out.println(&quot;受影响行数：&quot;+result);&#125; 2）通过id批量删除记录 12345678@Testpublic void testDeleteBatchIds()&#123;//通过多个id批量删除//DELETE FROM user WHERE id IN ( ? , ? , ? )List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L);int result = userMapper.deleteBatchIds(idList);System.out.println(&quot;受影响行数：&quot;+result);&#125; 3）通过map条件删除记录 12345678910@Testpublic void testDeleteByMap()&#123;//根据map集合中所设置的条件删除记录//DELETE FROM user WHERE name = ? AND age = ?Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;age&quot;, 23);map.put(&quot;name&quot;, &quot;张三&quot;);int result = userMapper.deleteByMap(map);System.out.println(&quot;受影响行数：&quot;+result);&#125; 4、修改1234567@Testpublic void testUpdateById()&#123;User user = new User(4L, &quot;admin&quot;, 22, null);//UPDATE user SET name=?, age=? WHERE id=?int result = userMapper.updateById(user);System.out.println(&quot;受影响行数：&quot;+result);&#125; 5、查询1）根据id查询用户信息 1234567@Testpublic void testSelectById()&#123;//根据id查询用户信息//SELECT id,name,age,email FROM user WHERE id=?User user = userMapper.selectById(4L);System.out.println(user);&#125; 2）根据id查询多个用户信息 12345678@Testpublic void testSelectBatchIds()&#123;//根据多个id查询多个用户信息//SELECT id,name,age,email FROM user WHERE id IN ( ? , ? )List&lt;Long&gt; idList = Arrays.asList(4L, 5L);List&lt;User&gt; list = userMapper.selectBatchIds(idList);list.forEach(System.out::println);&#125; 3）通过map条件查询用户信息 12345678910@Testpublic void testSelectByMap()&#123;//通过map条件查询用户信息//SELECT id,name,age,email FROM user WHERE name = ? AND age = ?Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;age&quot;, 22);map.put(&quot;name&quot;, &quot;admin&quot;);List&lt;User&gt; list = userMapper.selectByMap(map);list.forEach(System.out::println);&#125; 6、通用Service说明:通用 Service CRUD 封装IService接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免淆， 泛型 T 为任意实体对象 建议如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承Mybatis-Plus 提供的基类 MyBatis-Plus中有一个接口 IService和其实现类 ServiceImpl，封装了常见的业务层逻辑 1）创建Service接口和实现类 1234/*** UserService继承IService模板提供的基础功能*/public interface UserService extends IService&lt;User&gt; &#123;&#125; 123456/*** ServiceImpl实现了IService，提供了IService中基础功能的实现* 若ServiceImpl无法满足业务需求，则可以使用自定的UserService定义方法，并在实现类中实现*/@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125; 2）测试查询记录数 1234567@Autowiredprivate UserService userService;@Testpublic void testGetCount()&#123;long count = userService.count();System.out.println(&quot;总记录数：&quot; + count);&#125; 3）测试批量插入 1234567891011121314@Testpublic void testSaveBatch()&#123;// SQL长度有限制，海量数据插入单条SQL无法实行，// 因此MP将批量插入放在了通用Service中实现，而不是通用MapperArrayList&lt;User&gt; users = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 5; i++) &#123;User user = new User();user.setName(&quot;ybc&quot; + i);user.setAge(20 + i);users.add(user);&#125;//SQL:INSERT INTO t_user ( username, age ) VALUES ( ?, ? )userService.saveBatch(users);&#125; 四、常用注解1、解决表名与实体类名称不一致经过以上的测试，在使用MyBatis-Plus实现基本的CRUD时，我们并没有指定要操作的表，只是在Mapper接口继承BaseMapper时，设置了泛型User，而操作的表为user表由此得出结论，MyBatis-Plus在确定操作的表时，由BaseMapper的泛型决定，即实体类型决定，且默认操作的表名和实体类型的类名一致 但是当实体类的名字与表名不一致时就会报错。 解决办法如下： 1）@TableName 在实体类类型上添加@TableName(“t_user”)，标识实体类对应的表，即可成功执行SQL语句 12345678@Data@TableName(&quot;t_user&quot;)public class User &#123;private Long id;private String name;private Integer age;private String email;&#125; 2）通过全局配置解决问题 在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如t_或tbl_，此时，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过@TableName标识实体类对应的表 12345# 设置mybatis-plus的全局配置 global-config: db-config: # 设置实体类所对应的表的统一前缀 table-prefix: t_ 2、@TableId经过以上的测试，MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id 若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？答案是不会 此时我们就可以用@TableId来指定id 1234567public class User &#123;@TableIdprivate Long uid;private String name;private Integer age;private String email;&#125; @TableId的type属性: IdType.ASSIGN_ID 基于雪花算法的策略生成数据id，与数据库id是否设置自增无关 IdType.AUTO 使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，否则无效 3、@TableField经过以上的测试，我们可以发现，MyBatis-Plus在执行SQL语句时，要保证实体类中的属性名和表中的字段名一致如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢？ 1）情况1 若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格例如实体类属性userName，表中字段user_name此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格相当于在MyBatis中配置 2）情况2 若实体类中的属性和表中的字段不满足情况1例如实体类属性name，表中字段username此时需要在实体类属性上使用@TableField(“username”)设置属性所对应的字段名 1234567public class User &#123;private Long uid;@TableField(&quot;username&quot;)private String name;private Integer age;private String email;&#125; 4、@TableLogic物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录使用场景：可以进行数据恢复 实现逻辑删除： 1）数据库中创建逻辑删除状态列，设置默认值为0（表示没有被删除） 2）实体类中添加逻辑删除属性 123 @TableLogic// @TableField(&quot;is_delete&quot;) private Integer isDelete; 3）测试测试删除功能，真正执行的是修改UPDATE t_user SET is_deleted&#x3D;1 WHERE id&#x3D;? AND is_deleted&#x3D;0测试查询功能，被逻辑删除的数据默认不会被查询SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted&#x3D;0 五、条件构造器和常用接口1、wapper介绍 Wrapper ： 条件构造抽象类，最顶端父类AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件QueryWrapper ： 查询条件封装UpdateWrapper ： Update 条件封装AbstractLambdaWrapper ： 使用Lambda 语法LambdaQueryWrapper ：用于Lambda语法使用的查询WrapperLambdaUpdateWrapper ： Lambda 更新封装Wrapper 2、QueryWrapper1）组装查询条件 123456789101112@Testpublic void test01()&#123;//查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息//SELECT id,username AS name,age,email,is_deleted FROM t_user WHEREis_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.like(&quot;username&quot;, &quot;a&quot;).between(&quot;age&quot;, 20, 30).isNotNull(&quot;email&quot;);List&lt;User&gt; list = userMapper.selectList(queryWrapper);list.forEach(System.out::println);&#125; 2）组装排序条件 123456789101112@Testpublic void test02()&#123;//按年龄降序查询用户，如果年龄相同则按id升序排列//SELECT id,username AS name,age,email,is_deleted FROM t_user WHEREis_deleted=0 ORDER BY age DESC,id ASCQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.orderByDesc(&quot;age&quot;).orderByAsc(&quot;id&quot;);List&lt;User&gt; users = userMapper.selectList(queryWrapper);users.forEach(System.out::println);&#125; 3）组装删除条件 12345678910@Testpublic void test03()&#123;//删除email为空的用户//DELETE FROM t_user WHERE (email IS NULL)QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.isNull(&quot;email&quot;);//条件构造器也可以构建删除语句的条件int result = userMapper.delete(queryWrapper);System.out.println(&quot;受影响的行数：&quot; + result);&#125; 4）条件的优先级 12345678910111213141516171819202122232425262728293031323334@Testpublic void test04() &#123;QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();//将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改//UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND age &gt; ? ORemail IS NULL)queryWrapper.like(&quot;username&quot;, &quot;a&quot;).gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;);User user = new User();user.setAge(18);user.setEmail(&quot;user@atguigu.com&quot;);int result = userMapper.update(user, queryWrapper);System.out.println(&quot;受影响的行数：&quot; + result);&#125;@Testpublic void test04() &#123;QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();//将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改//UPDATE t_user SET age=?, email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL))//lambda表达式内的逻辑优先运算queryWrapper.like(&quot;username&quot;, &quot;a&quot;).and(i -&gt; i.gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;));User user = new User();user.setAge(18);user.setEmail(&quot;user@atguigu.com&quot;);int result = userMapper.update(user, queryWrapper);System.out.println(&quot;受影响的行数：&quot; + result);&#125; 5）组装select子句 1234567891011@Testpublic void test05() &#123;//查询用户信息的username和age字段//SELECT username,age FROM t_userQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.select(&quot;username&quot;, &quot;age&quot;);//selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为nullList&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);maps.forEach(System.out::println);&#125; 6）实现子查询 123456789@Testpublic void test06() &#123;//查询id小于等于3的用户信息//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (id IN (select id from t_user where id &lt;= 3))QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.inSql(&quot;id&quot;, &quot;select id from t_user where id &lt;= 3&quot;);List&lt;User&gt; list = userMapper.selectList(queryWrapper);list.forEach(System.out::println);&#125; 3、UpdateWrapper1234567891011121314151617181920@Testpublic void test07() &#123;//将（年龄大于20或邮箱为null）并且用户名中包含有a的用户信息修改//组装set子句以及修改条件UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();//lambda表达式内的逻辑优先运算updateWrapper.set(&quot;age&quot;, 18).set(&quot;email&quot;, &quot;user@atguigu.com&quot;).like(&quot;username&quot;, &quot;a&quot;).and(i -&gt; i.gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;));//这里必须要创建User对象，否则无法应用自动填充。如果没有自动填充，可以设置为null//UPDATE t_user SET username=?, age=?,email=? WHERE (username LIKE ? AND (age &gt; ? OR email IS NULL))//User user = new User();//user.setName(&quot;张三&quot;);//int result = userMapper.update(user, updateWrapper);//UPDATE t_user SET age=?,email=? WHERE (username LIKE ? AND (age &gt; ? ORemail IS NULL))int result = userMapper.update(null, updateWrapper);System.out.println(result);&#125; 4、condition在真正开发的过程中，组装条件是常见的功能，而这些条件数据来源于用户输入，是可选的，因此我们在组装这些条件时，必须先判断用户是否选择了这些条件，若选择则需要组装该条件，若没有选择则一定不能组装，以免影响SQL执行的结果 思路一： 1234567891011121314151617181920212223@Testpublic void test08() &#123;//定义查询条件，有可能为null（用户未输入或未选择）String username = null;Integer ageBegin = 10;Integer ageEnd = 24;QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();//StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成if(StringUtils.isNotBlank(username))&#123;queryWrapper.like(&quot;username&quot;,&quot;a&quot;);&#125;if(ageBegin != null)&#123;queryWrapper.ge(&quot;age&quot;, ageBegin);&#125;if(ageEnd != null)&#123;queryWrapper.le(&quot;age&quot;, ageEnd);&#125;//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age &gt;=? AND age &lt;= ?)List&lt;User&gt; users = userMapper.selectList(queryWrapper);users.forEach(System.out::println);&#125; 思路二： 上面的实现方案没有问题，但是代码比较复杂，我们可以使用带condition参数的重载方法构建查询条件，简化代码的编写 123456789101112131415161718@Testpublic void test08UseCondition() &#123;//定义查询条件，有可能为null（用户未输入或未选择）String username = null;Integer ageBegin = 10;Integer ageEnd = 24;QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();//StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成queryWrapper.like(StringUtils.isNotBlank(username), &quot;username&quot;, &quot;a&quot;).ge(ageBegin != null, &quot;age&quot;, ageBegin).le(ageEnd != null, &quot;age&quot;, ageEnd);//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age &gt;=? AND age &lt;= ?)List&lt;User&gt; users = userMapper.selectList(queryWrapper);users.forEach(System.out::println);&#125; 5、LambdaQueryWrapper123456789101112131415@Testpublic void test09() &#123;//定义查询条件，有可能为null（用户未输入）String username = &quot;a&quot;;Integer ageBegin = 10;Integer ageEnd = 24;LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();//避免使用字符串表示字段，防止运行时错误queryWrapper.like(StringUtils.isNotBlank(username), User::getName, username).ge(ageBegin != null, User::getAge, ageBegin).le(ageEnd != null, User::getAge, ageEnd);List&lt;User&gt; users = userMapper.selectList(queryWrapper);users.forEach(System.out::println);&#125; 6、LambdaUpdateWrapper12345678910111213@Testpublic void test10() &#123;//组装set子句LambdaUpdateWrapper&lt;User&gt; updateWrapper = new LambdaUpdateWrapper&lt;&gt;();updateWrapper.set(User::getAge, 18).set(User::getEmail, &quot;user@atguigu.com&quot;).like(User::getName, &quot;a&quot;).and(i -&gt; i.lt(User::getAge, 24).or().isNull(User::getEmail)); //lambda表达式内的逻辑优先算User user = new User();int result = userMapper.update(user, updateWrapper);System.out.println(&quot;受影响的行数：&quot; + result);&#125; 六、插件1、分页插件MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能 1）添加配置类 1234567891011@Configuration@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;) //可以将主类中的注解移到此处public class MybatisPlusConfig &#123;@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() &#123;MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();interceptor.addInnerInterceptor(newPaginationInnerInterceptor(DbType.MYSQL));return interceptor;&#125;&#125; 2）测试 1234567891011121314151617@Testpublic void testPage()&#123;//设置分页参数// 第一个参数为页号，第二给参数为页长Page&lt;User&gt; page = new Page&lt;&gt;(1, 5);//第二个参数为查询条件userMapper.selectPage(page, null);//获取分页数据List&lt;User&gt; list = page.getRecords();list.forEach(System.out::println);System.out.println(&quot;当前页：&quot;+page.getCurrent());System.out.println(&quot;每页显示的条数：&quot;+page.getSize());System.out.println(&quot;总记录数：&quot;+page.getTotal());System.out.println(&quot;总页数：&quot;+page.getPages());System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious());System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; 2、xml自定义分页1）UserMapper中定义接口方法 123456789/*** 根据年龄查询用户列表，分页显示* @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位* @param age 年龄* @return*/IPage&lt;User&gt; selectPageVo(@Param(&quot;page&quot;) Page&lt;User&gt; page, @Param(&quot;age&quot;)Integer age); 2）UserMapper.xml中编写SQL 1234567&lt;!--SQL片段，记录基础字段--&gt;&lt;sql id=&quot;BaseColumns&quot;&gt;id,username,age,email&lt;/sql&gt;&lt;!--IPage&lt;User&gt; selectPageVo(Page&lt;User&gt; page, Integer age);--&gt;&lt;select id=&quot;selectPageVo&quot; resultType=&quot;User&quot;&gt;SELECT &lt;include refid=&quot;BaseColumns&quot;&gt;&lt;/include&gt; FROM t_user WHERE age &gt; #&#123;age&#125;&lt;/select&gt; 3）测试 123456789101112131415@Testpublic void testSelectPageVo()&#123;//设置分页参数Page&lt;User&gt; page = new Page&lt;&gt;(1, 5);userMapper.selectPageVo(page, 20);//获取分页数据List&lt;User&gt; list = page.getRecords();list.forEach(System.out::println);System.out.println(&quot;当前页：&quot;+page.getCurrent());System.out.println(&quot;每页显示的条数：&quot;+page.getSize());System.out.println(&quot;总记录数：&quot;+page.getTotal());System.out.println(&quot;总页数：&quot;+page.getPages());System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious());System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; 3、乐观锁与悲观锁1）场景：一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50&#x3D;150元存入了数据库；小王将商品减了30元，并将100-30&#x3D;70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1万多。 上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是120元。 2）乐观锁实现流程 数据库中添加version字段取出记录时，获取当前version 1SELECT id,`name`,price,`version` FROM product WHERE id=1 更新时，version + 1，如果where语句中的version版本不对，则更新失败 1UPDATE product SET price=price+50, `version`=`version` + 1 WHERE id=1 AND `version`=1 3）Mybatis-Plus实现乐观锁 修改实体类 1234567891011package com.atguigu.mybatisplus.entity;import com.baomidou.mybatisplus.annotation.Version;import lombok.Data;@Datapublic class Product &#123;private Long id;private String name;private Integer price;@Version//标识乐观锁版本号字段private Integer version;&#125; 添加乐观锁插件配置 1234567891011121314151617@Configuration//扫描mapper包下的mapper接口@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)public class MyBatisPlusConfig &#123;// 配置分页插件 @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); //添加乐观锁插件 interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor; &#125;&#125; 测试修改冲突小李查询商品信息：SELECT id,name,price,version FROM t_product WHERE id&#x3D;?小王查询商品信息：SELECT id,name,price,version FROM t_product WHERE id&#x3D;?小李修改商品价格，自动将version+1UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?Parameters: 外星人笔记本(String), 150(Integer), 1(Integer), 1(Long), 0(Integer)小王修改商品价格，此时version已更新，条件不成立，修改失败UPDATE t_product SET name&#x3D;?, price&#x3D;?, version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?Parameters: 外星人笔记本(String), 70(Integer), 1(Integer), 1(Long), 0(Integer)最终，小王修改失败，查询价格：150SELECT id,name,price,version FROM t_product WHERE id&#x3D;? 优化流程： 123456789101112131415161718192021222324252627@Testpublic void testProduct01()&#123; //小李查询商品价格 Product product1 = productMapper.selectById(1); System.out.println(&quot;小李查询的商品价格：&quot;+product1.getPrice()); //小王查询的商品价格 Product product2 = productMapper.selectById(1); System.out.println(&quot;小王查询的商品价格：&quot;+product2.getPrice()); //小李将商品价格+50 product1.setPrice(product1.getPrice()+50); //小王将商品价格-30 product2.setPrice((product2.getPrice() - 30)); productMapper.updateById(product1); int result = productMapper.updateById(product2); if(result == 0)&#123; //操作失败，重试 Product productSec = productMapper.selectById(1); productSec.setPrice(productSec.getPrice()-30); productMapper.updateById(productSec); &#125; //老板查询商品价格 Product productBoss = productMapper.selectById(1); System.out.println(&quot;老板查询的商品价格：&quot;+productBoss.getPrice());&#125; 七、通用枚举表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现 1、数据库添加字段sex 2、创建通用枚举类型1234567891011121314@Getterpublic enum SexEnum &#123; MALE(1,&quot;男&quot;), FEMALE(2,&quot;女&quot;); @EnumValue //将注解所标识的属性的值存储到数据库中 private Integer sex; private String sexName; SexEnum(Integer sex, String sexName) &#123; this.sex = sex; this.sexName = sexName; &#125;&#125; 3、配置扫描通用枚举1234567891011# 设置mybatis-plus的全局配置 global-config: db-config: # 设置实体类所对应的表的统一前缀 table-prefix: t_ # 设置统一的主键生成策略 id-type: auto # 配置类型别名所对应的包 type-aliases-package: com.atguigu.mybatisplus.pojo # 扫描通用枚举的包 type-enums-package: com.atguigu.mybatisplus.enums 4、测试1234567891011@Testpublic void testSexEnum()&#123;User user = new User();user.setName(&quot;Enum&quot;);user.setAge(20);//设置性别信息为枚举项，会将@EnumValue注解所标识的属性值存储到数据库user.setSex(SexEnum.MALE);//INSERT INTO t_user ( username, age, sex ) VALUES ( ?, ?, ? )//Parameters: Enum(String), 20(Integer), 1(Integer)userMapper.insert(user);&#125; 八、代码生成器1、引入依赖1234567891011&lt;!-- 逆向工程 ，代码生成器依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt; &lt;/dependency&gt; 2、快速生成1234567891011121314151617181920212223242526272829303132package com.atguigu.mybatisplus;import com.baomidou.mybatisplus.generator.FastAutoGenerator;import com.baomidou.mybatisplus.generator.config.OutputFile;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import java.util.Collections;public class FastAutoGeneratorTest &#123; public static void main(String[] args) &#123; FastAutoGenerator.create(&quot;jdbc:mysql://127.0.0.1:3306/mybatis_plus?characterEncoding=utf-8&amp;userSSL=false&quot;, &quot;root&quot;, &quot;ljc625995&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;atguigu&quot;) // 设置作者 //.enableSwagger() // 开启 swagger 模式 .fileOverride() // 覆盖已生成文件 .outputDir(&quot;D://mybatis_plus&quot;); // 指定输出目录 &#125;) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com.atguigu&quot;) // 设置父包名 .moduleName(&quot;mybatisplus&quot;) // 设置父包模块名 .pathInfo(Collections.singletonMap(OutputFile.mapperXml, &quot;D://mybatis_plus&quot;));// 设置mapperXml生成路径 &#125;) .strategyConfig(builder -&gt; &#123; builder.addInclude(&quot;t_user&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀 &#125;) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125;&#125; 九、多数据源适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等目前我们就来模拟一个纯粹多库的一个场景，其他场景类似场景说明：我们创建两个库，分别为：mybatis_plus（以前的库不动）与mybatis_plus_1（新建），将mybatis_plus库的product表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功 1、引入依赖12345 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.0&lt;/version&gt;&lt;/dependency&gt; 2、配置多数据源123456789101112131415161718192021spring:# 配置数据源信息 datasource: dynamic:# 设置默认的数据源或者数据源组,默认值即为master primary: master# 严格匹配数据源,默认false.true未匹配到指定数据源时抛异常,false使用默认数据源 strict: false datasource: #master为第一个数据源名称 master: url: jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false driver-class-name: com.mysql.jdbc.Driver username: root password: ljc625995 #slave_1为第二个数据源名称 slave_1: url: jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false driver-class-name: com.mysql.jdbc.Driver username: root password: ljc625995 3、创建当个不同数据源的serviceUser: 12public interface UserService extends IService&lt;User&gt; &#123;&#125; 1234@DS(&quot;master&quot;)//数据源为master@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125; Product: 12public interface ProductService extends IService&lt;Product&gt; &#123;&#125; 1234@DS(&quot;slave_1&quot;)//数据源为slave_1@Servicepublic class ProductServiceImpl extends ServiceImpl&lt;ProductMapper, Product&gt; implements ProductService &#123;&#125; 4、测试1234567891011121314151617181920@SpringBootTestclass MybatisPlusDatasourceApplicationTests &#123; @Test void contextLoads() &#123; &#125; @Autowired private UserService userService; @Autowired private ProductService productService; @Test public void test()&#123; System.out.println(userService.getById(1)); System.out.println(productService.getById(1)); &#125;&#125; 十、MyBatisX插件MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。 1、下载插件在idea的Settings的Plugins页面搜索下载，下载完之后需要重启idea才能生效 2、利用小鸟快速定位mapper接口和mapper的sql文件MyBatisX小鸟定位这个功能这太香了啊，当我们编写一个大一点的项目的时候可能会写很多的mapper接口以及mapper的sql文件，学过mybatis的都知道我们的这两个对象是一一对应的，当文件非常多的时候眼花缭乱的我们就会很难快速找到对应的文件，此时小鸟就发挥了很大的作用。 下面演示以下用小鸟定位的方法： 在上面的图片中我们可以看见有一只小鸟，当我们点击蓝色小鸟就会快速跳到这个mapper所对应的接口去 现在跳转过来了，当我们点击红色小鸟，就会跳回刚刚的mapper. 3、使用MyBatisX代码生成器1、点击idea右侧Database展开的”+“号 2、选择MySQL 3、填写连接数据库的基本信息（注意MySQL的驱动要和数据库对得上） 4、上面apply,ok后，我们就看到一个已经连上得数据库了，我们点击想要生成代码的表右键，点击Mybatis-Generator 5、填写各种信息，然后next 6、确认信息，finish，这样代码就生成了 7、这样代码就生成了 4、MyBatisX快速生成CRUD只需要我们在mapper接口里按照一定的命名规侧写完方法名之后，按住Alt+Enter就会补全此方法，并且会生成对应的SQL语句 生成对应的SQL后，我们就会看到方法前面有一只小鸟，点击小鸟就会跳转到对应的SQL语句那里","categories":[],"tags":[]},{"title":"SpringBoot","slug":"SpringBoot","date":"2022-08-25T07:06:45.000Z","updated":"2022-08-28T13:55:36.720Z","comments":true,"path":"2022/08/25/SpringBoot/","link":"","permalink":"http://example.com/2022/08/25/SpringBoot/","excerpt":"","text":"一、springboot介绍1.1SpringBoot是Spring中的一个成员， 可以简化Spring，SpringMVC的使用。 他的核心还是IOC容器。 特点： Create stand-alone Spring applications 创建spring应用 Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 内嵌的tomcat， jetty ， Undertow Provide opinionated ‘starter’ dependencies to simplify your build configuration 提供了starter起步依赖，简化应用的配置。 比如使用MyBatis框架 ， 需要在Spring项目中，配置MyBatis的对象 SqlSessionFactory ， Dao的代理对象 在SpringBoot项目中，在pom.xml里面, 加入一个 mybatis-spring-boot-starter依赖 Automatically configure Spring and 3rd party libraries whenever possible 尽可能去配置spring和第三方库。叫做自动配置（就是把spring中的，第三方库中的对象都创建好，放到容器中， 开发人员可以直接使用） Provide production-ready features such as metrics, health checks, and externalized configuration 提供了健康检查， 统计，外部化配置 Absolutely no code generation and no requirement for XML configuration 不用生成代码， 不用使用xml，做配置 1.2 为什么要使用 Spring Boot 因为Spring， SpringMVC 需要使用的大量的配置文件 （xml文件） 还需要配置各种对象，把使用的对象放入到spring容器中才能使用对象 需要了解其他框架配置规则。 SpringBoot 就相当于 不需要配置文件的Spring+SpringMVC。 常用的框架和第三方库都已经配置好了。 拿来就可以使用了。 SpringBoot开发效率高，使用方便多了 二、JavaConfig2.1、JavaConfig类JavaConfig: 使用java类作为xml配置文件的替代， 是配置spring容器的纯java的方式。 在这个java类这可以创建java对象，把对象放入spring容器中（注入到容器） JavaConfig配置类之所以能够代替xml配置文件是因为springboot为我们提供了各种功能强大的注解，下面我将介绍几个Config配置类常用的注解。 1、@Configuration 放在一个类上面，表示当前的类作为配置文件使用，类似于beans.xml。 2、@ImportResource 这个注解可以导入其他配置文件，将多个配置文件中的配置集中起来。要写清楚类路径 classpath:applicationContext.xml，例如： 1@ImportResource(value =&#123;&quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125; ) 3、@PropertySource 这个注解用来读取properties属性配置文件，使用属性配置文件可以实现外部化配置。 4、@ComponentScan 用来扫描指定包路径下的类，并将他们注入spring容器，例如： 1@ComponentScan(basePackages = &quot;com.bjpowernode.vo&quot;) 下面是一个配置类大概的样子： 1234567891011121314151617181920212223242526272829303132333435363738package com.bjpowernode.config;import com.bjpowernode.vo.Student;import org.springframework.context.annotation.*;/** * 1、@Configuration:表示当前类是作为配置文件使用的，类似于beans.xml * 2、 @ImportResource 导入其他配置文件，要写清楚类路径 classpath:applicationContext.xml * 3、@PropertySource：读取properties属性配置文件，使用属性配置文件可以实现外部化配置，在程序代码之外提供数据 */@Configuration@ImportResource(value =&#123;&quot;classpath:applicationContext.xml&quot;,&quot;classpath:beans.xml&quot;&#125; )@PropertySource(value = &quot;classpath:config.properties&quot;)@ComponentScan(basePackages = &quot;com.bjpowernode.vo&quot;)public class SpringConfig &#123; /** * 创建方法，方法的返回值是对象。在方法的上面加入@Bean * 方法的返回值对象就注入到spring容器中 * 默认对象的名称是方法名 createStudent */ @Bean public Student createStudent()&#123; Student s1 = new Student(&quot;张三&quot;, 23, &quot;male&quot;); return s1; &#125; /** * 指定对象在容器中的名称（指定&lt;bean&gt;&lt;/bean&gt;的id */ @Bean(name=&quot;StudentLi&quot;) public Student makeStudent()&#123; Student s1 = new Student(&quot;李四&quot;, 23, &quot;male&quot;); return s1; &#125;&#125; Tiger类: 123456789101112131415161718192021package com.bjpowernode.vo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(&quot;tiger&quot;)public class Tiger &#123; //tiger.name是properties文件里的数据只有配置类有引入在这里可以直接利用@Value注解获取注入到相应的属性中去 @Value(&quot;$&#123;tiger.name&#125;&quot;) private String name; @Value(&quot;$&#123;tiger.age&#125;&quot;) private Integer age; @Override public String toString() &#123; return &quot;Tiger&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 配置文件都放在resources下面 config.properties: 测试获取spring容器中的Tiger，Tiger里的属性直接从properties文件赋值了 123456@Testpublic void test05()&#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); Object tiger = context.getBean(&quot;tiger&quot;); System.out.println(tiger);&#125; 结果： 测试获取SpringConfig中注入的对象 12345678 @Test public void test02()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);// Object student = (Student)context.getBean(&quot;createStudent&quot;); Object student = (Student)context.getBean(&quot;StudentLi&quot;); System.out.println(&quot;使用JavaConfig创建的bean对象：&quot;+student); &#125; 2.2 Springboot的application配置类1234567891011121314@SpringBootApplicationpublic class Springboot002Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot002Application.class, args); &#125; //声明对象，对象能注入到容器中 @Bean public Student myStudent()&#123; return new Student(); &#125;&#125; @SpringBootApplication 是一个复合注解，它里面又包含了 @SpringBootConfiguration@EnableAutoConfiguration@ComponentScan 等注解，所以它也是一个配置类。 @EnableAutoConfiguration 启用自动配置， 把java对象配置好，注入到spring容器中。例如可以把mybatis的对象创建好，放入到容器中 三、Springboot的项目构建和依赖管理3.1、使用Spring Initializr来快速构建项目1、选择 Spring Initializr 填写项目基本信息 2、选择开发环境，maven会把相应开发环境需要的jar包都自动加载进来 3.2、依赖管理每个springboot项目都会继承这个parent，它就是用来做依赖管理。 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 我们按Ctrl+鼠标左键进入org.springframework.boot的内部我们会发现很多已经为我们准备好的依赖 如果我们想要搜索mysql的数据库依赖，就Ctrl+F就会搜到当前springboot为我们准备的mysql版本 值得注意的是springboot为我们准备好的这些依赖都是相互兼容的一般不会出什么问题，没特殊情况推荐不要改版本号。 四、springboot的多环境配置4.1、配置文件的种类在java开发中我们一般会使用两种配置文件，分别是properties文件和yaml（yml）文件 文件的后缀有三种分别是 .properties .yml .yaml 他们的优先级为 properties&gt;yml&gt;yaml ，也就是如果三个文件同时存在，springboot会优先使用properties中的配置。 下面是两种文件的风格： properties: yml: 4.2、多环境配置4.2.1有开发环境， 测试环境， 上线的环境。 每个环境有不同的配置信息， 例如端口， 上下文件， 数据库url，用户名，密码等等 使用多环境配置文件，可以方便的切换不同的配置。 使用方式： 创建多个配置文件， 名称规则： application-环境名称.properties(yml) 创建开发环境的配置文件： application-dev.properties( application-dev.yml ) 创建测试者使用的配置： application-test.properties 在resources下创建下列文件 顾名思义 application-dev.yml 是开发环境所用的配置文件 application-test.yml 是测试环境所用的配文件，application-online.yml 是上线环境所用的配置文件 我们用一个公共的配置文件 application.yml来指定具体情况使用什么配文件 4.2.2在application.yml 里配置使用test环境的配文件 123spring: profiles: active: test application-test.yml 里的配如下： 12345#测试使用的配置文件server: port: 8089 servlet: context-path: /mytest 我们用web环境来测试一下 需要有web环境： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; BootController: 12345678910111213141516package com.bjpowernode.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class BootController &#123; @ResponseBody @RequestMapping(&quot;/hello&quot;) public String doSome()&#123; return &quot;SpringBoot多环境配置&quot;; &#125;&#125; 访问成功： 以后只需在application.yml 稍微改一下就能迅速切换不同环境的配置文件。 五、5.1、properties映射java对象@ConfigurationProperties: 把配置文件的数据映射为java对象。 属性：prefix 为配置文件中的某些key的开头的内容。 在properties配置文件中自定义以school开头的属性： 1234#自定义key=valueschool.name=动力节点school.website=www.bjpowernode.cpmschool.address=北京大兴区 创建一个类为SchoolInfo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.bjpowernode.vo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;school&quot;)//让配置文件中前缀为school的数据为这个对象的同名属性赋值public class SchoolInfo &#123; private String name; private String website; private String address; public String getName() &#123; return name; &#125; public String getWebsite() &#123; return website; &#125; public String getAddress() &#123; return address; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setWebsite(String website) &#123; this.website = website; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;SchoolInfo&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, website=&#x27;&quot; + website + &#x27;\\&#x27;&#x27; + &quot;, address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public SchoolInfo() &#123; &#125;&#125; 这样就可以把配置文件这数据映射为一个java对象了 5.2、获取容器对象123456789101112package com.bjpowernode.service.impl;import com.bjpowernode.service.UserService;import org.springframework.stereotype.Service;@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123; @Override public void sayHello(String name) &#123; System.out.println(&quot;执行了业务方法的sayHello:&quot;+name); &#125;&#125; 1234567891011121314151617181920package com.bjpowernode;import com.bjpowernode.service.UserService;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;@SpringBootApplicationpublic class SpringbootContainer006Application &#123; public static void main(String[] args) &#123; //获取容器对象 ConfigurableApplicationContext ctx = SpringApplication.run(SpringbootContainer006Application.class, args); //从容器中获取对象 UserService userService = (UserService)ctx.getBean(&quot;userService&quot;); userService.sayHello(&quot;李四&quot;); &#125;&#125; 5.3、ApplicationRunner 与 CommandLineRunner 接口这两个接口都 有一个run方法。 执行时间在容器对象创建好后， 自动执行run（）方法。 可以完成自定义的在容器对象创建好的一些操作。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.bjpowernode;import com.bjpowernode.service.HelloService;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import javax.annotation.Resource;@SpringBootApplicationpublic class SpringbootCommandLinerunner007Application implements CommandLineRunner &#123;// public class SpringbootCommandLinerunner007Application implements ApplicationRunner &#123; @Resource private HelloService helloService; public static void main(String[] args) &#123; System.out.println(&quot;准备创建容器对象&quot;); //创建容器对象 context即为容器对象 ConfigurableApplicationContext context = SpringApplication.run(SpringbootCommandLinerunner007Application.class, args); Object helloServiceImpl = context.getBean(&quot;helloServiceImpl&quot;); System.out.println(&quot;容器对象创建之后&quot;); System.out.println(&quot;从容器中获取HelloServiceImpl对象：&quot;+helloServiceImpl); &#125; @Override public void run(String... args) throws Exception &#123; String str = helloService.sayHello((&quot;lisi&quot;)); System.out.println(&quot;调用容器中的对象：&quot;+str);// 可以做自定义操作，比如读取文件，数据库等等 System.out.println(&quot;容器对象创建完之后执行的方法&quot;); &#125;// @Override// public void run(ApplicationArguments args) throws Exception &#123;//// &#125;&#125; 运行结果： 六、Web组件6.1、拦截器拦截器是SpringMVC中一种对象，能拦截器对Controller的请求。 拦截器框架中有系统的拦截器， 还可以自定义拦截器。 实现对请求预先处理。 实现自定义拦截器： 创建类实现SpringMVC框架的HandlerInterceptor接口 1234567891011public interface HandlerInterceptor &#123; default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; &#125; default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; &#125;&#125; 2.需在SpringMVC的配置文件中，声明拦截器 123456&lt;mvc:interceptors&gt;&lt;mvc:interceptor&gt; &lt;mvc:path=&quot;url&quot; /&gt; &lt;bean class=&quot;拦截器类全限定名称&quot;/&gt;&lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; SpringBoot中注册拦截器： 1234567891011121314151617181920@Configurationpublic class MyAppConfig implements WebMvcConfigurer &#123; //添加拦截器对象， 注入到容器中 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //创建拦截器对象 HandlerInterceptor interceptor = new LoginInterceptor(); //指定拦截的请求uri地址 String path []= &#123;&quot;/user/**&quot;&#125;; //指定不拦截的地址 String excludePath [] = &#123;&quot;/user/login&quot;&#125;; registry.addInterceptor(interceptor) .addPathPatterns(path) .excludePathPatterns(excludePath); &#125;&#125; 6.2、过滤器Filter是Servlet规范中的过滤器，可以处理请求， 对请求的参数， 属性进行调整。 常常在过滤器中处理字符编码 在框架中使用过滤器： 创建自定义过滤器类 注册Filter过滤器对象 例子： 12345678// 自定义过滤器public class MyFilter implements Filter &#123; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;执行了MyFilter，doFilter &quot;); filterChain.doFilter(servletRequest,servletResponse); &#125;&#125; 注册Filter 1234567891011@Configurationpublic class WebApplicationConfig &#123; @Bean public FilterRegistrationBean filterRegistrationBean()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter( new MyFilter()); bean.addUrlPatterns(&quot;/user/*&quot;); return bean; &#125;&#125; 6.3、字符集过滤器CharacterEncodingFilter : 解决post请求中乱码的问题 在SpringMVC框架， 在web.xml 注册过滤器。 配置他的属性。 第一种方式： 使用步骤： 配置字符集过滤器 1234567891011121314151617181920212223242526272829303132@Configurationpublic class WebSystemConfig &#123; //注册Servlet @Bean public ServletRegistrationBean servletRegistrationBean()&#123; MyServlet myServlet = new MyServlet(); ServletRegistrationBean reg = new ServletRegistrationBean(myServlet,&quot;/myservlet&quot;); return reg; &#125; //注册Filter @Bean public FilterRegistrationBean filterRegistrationBean()&#123; FilterRegistrationBean reg = new FilterRegistrationBean(); //使用框架中的过滤器类 CharacterEncodingFilter filter = new CharacterEncodingFilter(); //指定使用的编码方式 filter.setEncoding(&quot;utf-8&quot;); //指定request ， response都使用encoding的值 filter.setForceEncoding(true); reg.setFilter(filter); //指定 过滤的url地址 reg.addUrlPatterns(&quot;/*&quot;); return reg; &#125;&#125; 2.修改application.properties文件， 让自定义的过滤器起作用 123#SpringBoot中默认已经配置了CharacterEncodingFilter。 编码默认ISO-8859-1#设置enabled=false 作用是关闭系统中配置好的过滤器， 使用自定义的CharacterEncodingFilterserver.servlet.encoding.enabled=false 第二种方式 修改application.properties文件 123456789server.port=9001server.servlet.context-path=/myboot#让系统的CharacterEncdoingFilter生效server.servlet.encoding.enabled=true#指定使用的编码方式server.servlet.encoding.charset=utf-8#强制request，response都使用charset属性的值server.servlet.encoding.force=true 七、ORM操作MySql 使用MyBatis框架操作数据， 在SpringBoot框架集成MyBatis 使用步骤： mybatis起步依赖 ： 完成mybatis对象自动配置， 对象放在容器中 pom.xml 指定把src&#x2F;main&#x2F;java目录中的xml文件包含到classpath中 创建实体类Student 创建Dao接口 StudentDao , 创建一个查询学生的方法 创建Dao接口对应的Mapper文件， xml文件， 写sql语句 创建Service层对象， 创建StudentService接口和他的实现类。 去dao对象的方法。完成数据库的操作 创建Controller对象，访问Service。 写application.properties文件 配置数据库的连接信息。 第一种方式 ： @Mapper@Mapper：放在dao接口的上面， 每个接口都需要使用这个注解。 123456789101112131415package com.bjpowernode.mapper;import com.bjpowernode.model.Student;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;/** * @Mapper 告诉MyBatis这是一个mapper接口，创建此接口的代理对象 */@Mapperpublic interface StudentMapper &#123; Student selectById(@Param(&quot;id&quot;) Integer id);&#125; 第二种方式 @MapperScan12345678910111213141516171819package com.bjpowernode;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @MapperScan(basePackages = &quot;com.bjpowernode.mapper&quot;) * 扫描com.bjpowernode.mapper包下的所有接口 */@MapperScan(basePackages = &quot;com.bjpowernode.mapper&quot;)@SpringBootApplicationpublic class SpringbootMapper008Application &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootMapper008Application.class, args); &#125;&#125; 第三种方式： Mapper文件和Mapper接口分开管理 现在把Mapper文件放在resources目录下 1）在resources目录中创建子目录 （自定义的） ， 例如mapper 2）把mapper文件放到 mapper目录中 3）在application.properties文件中，指定mapper文件的目录 1234#指定mapper文件的位置mybatis.mapper-locations=classpath:mapper/*.xml#指定mybatis的日志mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 4)、在pom.xml中指定 把resources目录中的文件 ， 编译到目标目录中 123456789 &lt;!--resources插件--&gt;&lt;resources&gt;&lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt;&lt;/resource&gt;&lt;/resources&gt; 第四个 事务Spring框架中的事务： 1） 管理事务的对象： 事务管理器（接口， 接口有很多的实现类） ​ 例如：使用Jdbc或mybatis访问数据库，使用的事务管理器：DataSourceTransactionManager 2 ) 声明式事务： 在xml配置文件或者使用注解说明事务控制的内容 ​ 控制事务： 隔离级别，传播行为， 超时时间 3）事务处理方式： ​ 1） Spring框架中的@Transactional ​ 2) aspectj框架可以在xml配置文件中，声明事务控制的内容 ​ SpringBoot中使用事务： 上面的两种方式都可以。 1）在业务方法或者service层的上面加入@Transactional , 加入注解后，方法有事务功能了。 2）明确的在 主启动类的上面 ，加入@EnableTransactionManager 例子： 1234567891011121314151617/** * @Transactional: 表示方法的有事务支持 * 默认：使用库的隔离级别， REQUIRED 传播行为； 超时时间 -1 * 抛出运行时异常，回滚事务 */@Transactional@Overridepublic int addStudent(Student student) &#123; System.out.println(&quot;业务方法addStudent&quot;); int rows = studentDao.insert(student); System.out.println(&quot;执行sql语句&quot;); //抛出一个运行时异常， 目的是回滚事务 //int m = 10 / 0 ; return rows;&#125; 1234567891011121314151617package com.bjpowernode;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.transaction.annotation.EnableTransactionManagement;@MapperScan(basePackages = &quot;com.bjpowernode.mapper&quot;)@EnableTransactionManagement@SpringBootApplicationpublic class SpringbootTransactional009Application &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootTransactional009Application.class, args); &#125;&#125; 七、Springboot整合RedisRedis ： 一个NoSQL数据库， 常用作 缓存使用 （cache） Redis的数据类型： string , hash ,set ,zset , list Redis是一个中间件： 是一个独立的服务器。 java中著名的客户端： Jedis ， lettuce ， Redisson Spring,SpringBoot中有 一个RedisTemplate（StringRedisTemplate） ，处理和redis交互 7.1、配置Windows版本的redisRedis-x64-3.2.100.rar 解压缩到一个 非中文 的目录 redis-server.exe：服务端， 启动后，不要关闭 redis-cli.exe：客户端， 访问redis中的数据 7.2、用springboot操作虚拟机linux系统中的redis1、用xshell连接linux系统并且开启redis服务 2、在properties配置文件中配置redis连接信息 1234spring.redis.host=192.168.153.128spring.redis.port=6379#因为redis没有设密码，所以这里注释掉#spring.redis.password= 3、引入redis起步依赖 12345&lt;!-- redis起步依赖，可以直接在项目中使用RedisTemplate(StringRedisTemplate)--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 4、编写Controller 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@RestControllerpublic class RedisController &#123; /** * 注入RedisTemplate * * RedisTemplate泛型: * RedisTemplate&lt;String,String&gt; * RedisTemplate&lt;Object,Object&gt; * 泛型可行可不写 * * 注意：RedisTemplate对象的名称 redisTemplate * */ @Resource private RedisTemplate redisTemplate; @Resource private StringRedisTemplate stringRedisTemplate; //添加数据到redis @PostMapping(&quot;/redis/addstring&quot;) public String addToRedis(String name,String value)&#123; //操作Redis中的String类型的数据,先获取 ValueOperations对象 ValueOperations valueOperations = redisTemplate.opsForValue(); //添加数据到redis valueOperations.set(&quot;myname&quot;,&quot;lisi&quot;); return &quot;向redis添加string类型的数据&quot;; &#125; //从redis获取数据 @GetMapping(&quot;/redis/getk&quot;) public String getData(String k)&#123; ValueOperations valueOperations = redisTemplate.opsForValue(); Object o = valueOperations.get(k); return &quot;key是&quot;+k+&quot;，他的值是：&quot;+o; &#125; @PostMapping(&quot;/redis/&#123;k&#125;/&#123;v&#125;&quot;) public String addStringKV(@PathVariable String k, @PathVariable String v)&#123; //使用StringRedisTemplate对象 stringRedisTemplate.opsForValue().set(k,v); return &quot;使用StringRedisTemplate对象&quot;; &#125; @GetMapping(&quot;/redis/getstr/&#123;k&#125;&quot;) public String getStringValue(@PathVariable String k)&#123; String v = stringRedisTemplate.opsForValue().get(k); return &quot;k的value:&quot;+v; &#125;&#125; 4、用Postman测试连接 向redis里添加数据 查看redis里以及添加进去数据了，只不过这里没有经过序列化就存进去了，不直观 再用Postman把数据取出来看看 7.3 StringRedisTemplate 和 RedisTemplateStringRedisTemplate ： 把k，v 都是作为String处理， 使用的是String的序列化 ， 可读性好 1234567@PostMapping(&quot;/redis/&#123;k&#125;/&#123;v&#125;&quot;)public String addStringKV(@PathVariable String k, @PathVariable String v)&#123; //使用StringRedisTemplate对象 stringRedisTemplate.opsForValue().set(k,v); return &quot;使用StringRedisTemplate对象&quot;;&#125; RedisTemplate ： 把k，v 经过了序列化存到redis。 k，v 是序列化的内容， 不能直接识别，只能经过手动序列化才能直接识别（测试图片在7.2展示过了） 7.4 序列化序列化：把对象转化为可传输的字节序列过程称为序列化。 反序列化：把字节序列还原为对象的过程称为反序列化。 为什么需要序列化 序列化最终的目的是为了对象可xu以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。 什么情况下需要序列化 通过上面我想你已经知道了凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。 本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。 序列化的方式 序列化只是一种拆装组装对象的规则，那么这种规则肯定也可能有多种多样，比如现在常见的序列化方式有： JDK（不支持跨语言）、JSON、XML、Hessian、Kryo（不支持跨语言）、Thrift、Protofbuff、 Student( name&#x3D;zs, age&#x3D;20) —- { “name”:”zs”, “age”:20 } java的序列化： 把java对象转为byte[], 二进制数据 json序列化：json序列化功能将对象转换为 JSON 格式或从 JSON 格式转换对象。例如把一个Student对象转换为JSON字符串{“name”:”李四”, “age”:29} )，反序列化(将JSON字符串 {“name”:”李四”, “age”:29} 转换为Student对象) 设置key或者value的序列化方式 1234567891011121314151617/** * 设置 RedisTemplate 序列化 * 可以设置 key 的序列化，可以设置value的序列化，也可以同时设置 */@PostMapping(&quot;/redis/addstr&quot;)public String addString(String k,String v)&#123; //RedisTemplate //设置key 使用String的序列化 redisTemplate.setKeySerializer(new StringRedisSerializer()); //设置 value的序列化 redisTemplate.setValueSerializer(new StringRedisSerializer()); redisTemplate.opsForValue().set(k,v); return &quot;定义RedisTemplate 对象的key,value的序列化&quot;;&#125; json序列化 1234567891011121314151617/** * 使用json序列化，把java对象转换为json存储 */@PostMapping(&quot;/redis/addjson&quot;)public String addJson()&#123; Student student = new Student(); student.setId(1001); student.setName(&quot;zhangsan&quot;); student.setAge(20); redisTemplate.setKeySerializer(new StringRedisSerializer()); //把值作为json序列化 redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer(Student.class)); redisTemplate.opsForValue().set(&quot;mystudent&quot;,student); return &quot;json序列化&quot;;&#125; json反序列化 12345678910@PostMapping(&quot;/redis/getjson&quot;)public String getJson()&#123; redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer(Student.class)); Object mystudent = redisTemplate.opsForValue().get(&quot;mystudent&quot;); return &quot;json反序列化：&quot;+mystudent;&#125; 结果： 八、Springboot集成Dubbo Dubbo的原理图 Container负责启动（上面的容器为Spring容器），加载，运行服务提供者； 服务提供者在启动时，向注册中心注册自己提供的服务； 服务消费者在启动时，向注册中心订阅自己所需的服务； 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者； 服务消费者，从提供者地址列表中，基于软负载均衡算法，选择一台提供者进行调用，如果调用失败，再选另一个台调用； 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 一个简单Dubbo项目主要由三个部分组成：公共接口、提供者、消费者 公共接口项目：先定义一个实体类Student: 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.bjpowernode.model;import java.io.Serializable;public class Student implements Serializable &#123; private static final long serialVersionUID = 1901229007746699151L; private Integer id; private String name; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 定义接口StudentService: 123456789package com.bjpowernode.service;import com.bjpowernode.model.Student;public interface StudentService &#123; Student queryStudent(Integer id);&#125; 项目地址为： 123&lt;groupId&gt;com.bjpowernode&lt;/groupId&gt;&lt;artifactId&gt;interface-api-011&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 提供者：关键依赖： 123456789101112131415161718192021222324252627&lt;!-- 加入公共接口项目的gav--&gt; &lt;dependency&gt; &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt; &lt;artifactId&gt;interface-api-011&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;!-- dubbo依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;/dependency&gt;&lt;!-- zookeeper注册中心依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; application.properties配置文件： 123456789101112#配置服务名称 相当于dubbo:application name=&quot;&quot;spring.application.name=studentservice-provider#配置扫描的包，扫描的@DubboServicedubbo.scan.base-packages=com.bjpowernode.service#配置dubbo协议#dubbo.protocol.name=dubbo#dubbo.protocol.port=20881#注册中心dubbo.registry.address=zookeeper://localhost:2181 实现StudentService接口： 1234567891011121314151617181920212223242526272829package com.bjpowernode.service.impl;import com.bjpowernode.model.Student;import com.bjpowernode.service.StudentService;import org.apache.dubbo.config.annotation.DubboService;import org.springframework.stereotype.Component;/** * 使用dubbo中的注解暴露服务 *///@Component 可加可不加@DubboService(interfaceClass = StudentService.class,version = &quot;1.0&quot;,timeout = 5000)public class StudentServiceImpl implements StudentService &#123; @Override public Student queryStudent(Integer id) &#123; Student student = new Student(); if(1001 == id)&#123; student.setId(1001); student.setName(&quot;+++++1001-张三&quot;); student.setAge(20); &#125;else if(1002 == id)&#123; student.setId(1002); student.setName(&quot;=====1002-李四&quot;); student.setAge(22); &#125; return student; &#125;&#125; 启动类需要标@EnableDubbo注解来启动Dubbo 1234567891011121314151617181920package com.bjpowernode;import org.apache.dubbo.config.spring.context.annotation.EnableDubbo;import org.apache.dubbo.config.spring.context.annotation.EnableDubboConfig;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @EnableDubbo 启用dubbo */@EnableDubbo//@EnableDubboConfig == @EnableDubbo@SpringBootApplicationpublic class ServiceProvider012Application &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceProvider012Application.class, args); &#125;&#125; 消费者：关键依赖： 12345678910111213141516171819202122232425262728&lt;!-- 这个在消费者这里可加可不加--&gt;&lt;!-- 加入公共接口项目的gav--&gt;&lt;dependency&gt; &lt;groupId&gt;com.bjpowernode&lt;/groupId&gt; &lt;artifactId&gt;interface-api-011&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;!-- dubbo依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- zookeeper依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; application.properties配置文件： 1234#指定服务名称spring.application.name=consumer-application#指定注册中心dubbo.registry.address=zookeeper://localhost:2181 调用接口： 12345678910111213141516171819202122232425262728293031package com.bjpowernode.controller;import com.bjpowernode.model.Student;import com.bjpowernode.service.StudentService;import org.apache.dubbo.config.annotation.DubboReference;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DubboController &#123; /** * @DubboReference 引用远程服务，把创建好的代理对象，注入给studentService * version = &quot;1.0&quot; 版本号，要和调用者保持一致 */ //@DubboReference(interfaceClass = StudentService.class,version = &quot;1.0&quot;) /** * 没有使用interfaceClass,默认的就是 引用类型 的数据类型 */ @DubboReference(version = &quot;1.0&quot;) private StudentService studentService; @RequestMapping(&quot;/query&quot;) public String queryStudent(Integer id)&#123; Student student = studentService.queryStudent(id); return &quot;调用远程接口，获取对象：&quot;+student; &#125;&#125; 测试结果： 八、Thymleaf模板引擎8.1、依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 8.2、application.properties配置文件1234567891011121314#开发阶段，关闭模板引擎，让修改立即生效spring.thymeleaf.cache=false#编码格式spring.thymeleaf.encoding=UTF-8#模板的类型（默认是HTML，模板是html文件）spring.thymeleaf.mode=HTML#模板的前缀：类路径的 classpath:/templates(默认的)spring.thymeleaf.prefix=/templates/#后缀 默认为 .htmlspring.thymeleaf.suffix=.html 8.3、表达式1、标准变量表达式 语法： ${key} 作用： 获取key对于的文本数据， key 是request作用域中的key ， 使用request.setAttribute(), model.addAttribute() 在页面中的 html标签中， 使用 th:text&#x3D;”${key}” 1234567891011&lt;div style=&quot;margin-left: 400px&quot;&gt; &lt;h3&gt;标准变量表达式: $&#123;key&#125;&lt;/h3&gt; &lt;p th:text=&quot;$&#123;site&#125;&quot;&gt;key不存在&lt;/p&gt; &lt;br/&gt; &lt;p&gt;获取SysUser对象 属性值&lt;/p&gt; &lt;p th:text=&quot;$&#123;myuser.id&#125;&quot;&gt;id&lt;/p&gt; &lt;p th:text=&quot;$&#123;myuser.name&#125;&quot;&gt;姓名&lt;/p&gt; &lt;p th:text=&quot;$&#123;myuser.sex&#125;&quot;&gt;姓名：m男&lt;/p&gt; &lt;p th:text=&quot;$&#123;myuser.age&#125;&quot;&gt;年龄&lt;/p&gt; &lt;p th:text=&quot;$&#123;myuser.getName()&#125;&quot;&gt;获取姓名使用getXXX&lt;/p&gt;&lt;/div&gt; 2、选择变量表达式（ 星号变量表达式） 语法： *{key} 作用： 获取这个key对应的数据， *{key}需要和th:object 这个属性一起使用。 目的是简单获取对象的属性值。 12345678910&lt;p&gt;使用 *&#123;&#125; 获取SysUser的属性值&lt;/p&gt;&lt;div th:object=&quot;$&#123;myuser&#125;&quot;&gt; &lt;p th:text=&quot;*&#123;id&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;*&#123;name&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;*&#123;sex&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;使用*&#123;&#125;完成的表示 对象的属性值&lt;/p&gt;&lt;p th:text=&quot;*&#123;myuser.name&#125;&quot; &gt;&lt;/p&gt; 3、链接表达式 语法： @{url} 作用： 表示链接 1&lt;script src=&quot;@&#123;http://www.baidu.com&#125;&quot;&gt; , &lt;link href=&quot;...&quot;&gt; &lt;a href=&quot;..&quot;&gt; ,&lt;form action=&quot;...&quot;&gt; &lt;img src=&quot;...&quot;&gt; 8.4 Thymeleaf属性属性是放在html元素中的，就是html元素的属性，加入了th前缀。 属性的作用不变。 加入上th， 属性的值由模板引擎处理了。 在属性可以使用变量表达式 例如： 123&lt;form action=&quot;/loginServlet&quot; method=&quot;post&quot;&gt;&lt;/form&gt;&lt;form th:action=&quot;/loginServlet&quot; th:method=&quot;$&#123;methodAttr&#125;&quot;&gt;&lt;/form&gt; 8.5 each each循环， 可以循环List，Array 语法： 在一个html标签中，使用th:each 12345&lt;div th:each=&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;&gt; &lt;p th:text=&quot;$&#123;集合循环成员&#125;&quot; &gt;&lt;/p&gt;&lt;/div&gt;集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot; each循环Map 在一个html标签中，使用th:each 123456789&lt;div th:each=&quot;集合循环成员,循环的状态变量:$&#123;key&#125;&quot;&gt; &lt;p th:text=&quot;$&#123;集合循环成员.key&#125;&quot; &gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;集合循环成员.value&#125;&quot; &gt;&lt;/p&gt;&lt;/div&gt;集合循环成员,循环的状态变量:两个名称都是自定义的。 “循环的状态变量”这个名称可以不定义，默认是&quot;集合循环成员Stat&quot;key:map集合中的keyvalue：map集合key对应的value值 8.5 th:if“th:if” : 判断语句， 当条件为true， 显示html标签体内， 反之不显示 没有else语句 12语法：&lt;div th:if=&quot; 10 &gt; 0 &quot;&gt; 显示文本内容 &lt;/div&gt; 还有一个 th:unless 和 th:if相反的行为 12语法：&lt;div th:unless=&quot; 10 &lt; 0 &quot;&gt; 当条件为false显示标签体内容 &lt;/div&gt; 例子：if 12345678910&lt;div style=&quot;margin-left: 400px&quot;&gt; &lt;h3&gt; if 使用&lt;/h3&gt; &lt;p th:if=&quot;$&#123;sex==&#x27;m&#x27;&#125;&quot;&gt;性别是男&lt;/p&gt; &lt;p th:if=&quot;$&#123;isLogin&#125;&quot;&gt;已经登录系统&lt;/p&gt; &lt;p th:if=&quot;$&#123;age &gt; 20&#125;&quot;&gt;年龄大于20&lt;/p&gt; &lt;!--&quot;&quot;空字符是true--&gt; &lt;p th:if=&quot;$&#123;name&#125;&quot;&gt;name是“”&lt;/p&gt; &lt;!--null是false--&gt; &lt;p th:if=&quot;$&#123;isOld&#125;&quot;&gt; isOld是null&lt;/p&gt; &lt;/div&gt; 例子： unless 123456&lt;div style=&quot;margin-left: 400px&quot;&gt; &lt;h3&gt;unless: 判断条件为false，显示标签体内容&lt;/h3&gt; &lt;p th:unless=&quot;$&#123;sex==&#x27;f&#x27;&#125;&quot;&gt;性别是男的&lt;/p&gt; &lt;p th:unless=&quot;$&#123;isLogin&#125;&quot;&gt;登录系统&lt;/p&gt; &lt;p th:unless=&quot;$&#123;isOld&#125;&quot;&gt; isOld是null &lt;/p&gt; &lt;/div&gt; 8.6 th:switchth:switch 和 java中的swith一样的 1234567891011121314语法：&lt;div th:switch=&quot;要比对的值&quot;&gt; &lt;p th:case=&quot;值1&quot;&gt; 结果1 &lt;/p&gt; &lt;p th:case=&quot;值2&quot;&gt; 结果2 &lt;/p&gt; &lt;p th:case=&quot;*&quot;&gt; 默认结果 &lt;/p&gt; 以上的case只有一个语句执行 &lt;/div&gt; 8.7 th:inline1、内联text： 在html标签外，获取表达式的值 语法： 1234567891011121314&lt;p&gt;显示姓名是：[[$&#123;key&#125;]]&lt;/p&gt; &lt;div style=&quot;margin-left: 400px&quot;&gt; &lt;h3&gt;内联 text, 使用内联表达式显示变量的值&lt;/h3&gt; &lt;div th:inline=&quot;text&quot;&gt; &lt;p&gt;我是[[$&#123;name&#125;]]，年龄是[[$&#123;age&#125;]]&lt;/p&gt; 我是&lt;span th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/span&gt;,年龄是&lt;span th:text=&quot;$&#123;age&#125;&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;使用内联text&lt;/p&gt; &lt;p&gt;我是[[$&#123;name&#125;]],性别是[[$&#123;sex&#125;]]&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 2、内联javascript 1234567891011例子： &lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt; var myname = [[$&#123;name&#125;]]; var myage = [[$&#123;age&#125;]]; //alert(&quot;获取的模板中数据 &quot;+ myname + &quot;,&quot;+myage) function fun()&#123; alert(&quot;单击事件，获取数据 &quot;+ myname + &quot;,&quot;+ [[$&#123;sex&#125;]]) &#125; &lt;/script&gt; 8.8 字面量12345678910111213&lt;div style=&quot;margin-left: 400px&quot;&gt; &lt;h3&gt;文本字面量: 使用单引号括起来的字符串&lt;/h3&gt; &lt;p th:text=&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;&gt;数据显示&lt;/p&gt; &lt;h3&gt;数字字面量&lt;/h3&gt; &lt;p th:if=&quot;$&#123;20&gt;5&#125;&quot;&gt; 20大于 5&lt;/p&gt; &lt;h3&gt;boolean字面量&lt;/h3&gt; &lt;p th:if=&quot;$&#123;isLogin == true&#125;&quot;&gt;用户已经登录系统&lt;/p&gt; &lt;h3&gt;null字面量&lt;/h3&gt; &lt;p th:if=&quot;$&#123;myuser != null&#125;&quot;&gt;有myuser数据&lt;/p&gt; &lt;/div&gt; 8.9 字符串连接连接字符串有两种语法 1） 语法使用 单引号括起来字符串 ， 使用 + 连接其他的 字符串或者表达式 1&lt;p th:text=&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;&gt;数据显示&lt;/p&gt; 2）语法：使用双竖线， |字符串和表达式| 123&lt;p th:text=&quot;|我是$&#123;name&#125;,我所在城市$&#123;city|&quot;&gt; 显示数据&lt;/p&gt; 例子： 12345678&lt;div style=&quot;margin-left: 400px&quot;&gt; &lt;h3&gt;字符串连接方式1：使用单引号括起来的字符串&lt;/h3&gt; &lt;p th:text=&quot;&#x27;我是&#x27;+$&#123;name&#125;+&#x27;,我所在的城市&#x27;+$&#123;city&#125;&quot;&gt;数据显示&lt;/p&gt; &lt;br/&gt; &lt;br/&gt; &lt;h3&gt;字符串连接方式2：|字符串和表达式|&lt;/h3&gt; &lt;p th:text=&quot;|我是$&#123;name&#125;,所在城市$&#123;city&#125;,其他人$&#123;myuser.name&#125;|&quot;&gt;&lt;/p&gt;&lt;/div&gt; 8.10 运算符12345678910111213141516171819202122算术运 算： + , - - , * , / , %关系比较 : &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )相等判断： == , != ( eq , ne )&lt;div style=&quot;margin-left: 400px&quot;&gt; &lt;h3&gt;使用运算符&lt;/h3&gt; &lt;p th:text=&quot;$&#123;age &gt; 10&#125;&quot;&gt;年龄大于 10 &lt;/p&gt; &lt;p th:text=&quot;$&#123; 20 + 30 &#125;&quot;&gt;显示运算结果&lt;/p&gt; &lt;p th:if=&quot;$&#123;myuser == null&#125;&quot;&gt;myuser是null&lt;/p&gt; &lt;p th:if=&quot;$&#123;myuser eq null&#125;&quot;&gt;myuser是null&lt;/p&gt; &lt;p th:if=&quot;$&#123;myuser ne null&#125;&quot;&gt;myuser不是null&lt;/p&gt; &lt;p th:text=&quot;$&#123;isLogin == true ? &#x27;用户已经登录&#x27; : &#x27;用户需要登录&#x27;&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;isLogin == true ? ( age &gt; 10 ? &#x27;用户是大于10的&#x27; : &#x27;用户年龄比较小&#x27;) : &#x27;用户需要登录&#x27;&#125;&quot;&gt;&lt;/p&gt; &lt;/div&gt;三元运算符： 表达式 ？ true的结果 : false的结果三元运算符可以嵌套 8.11 内置对象#request 表示 HttpServletRequest #session 表示 HttpSession对象 session 表示Map对象的， 是#session的简单表示方式， 用来获取session中指定的key的值 ​ #session.getAttribute(“loginname”) &#x3D;&#x3D; session.loginname 这些是内置对象，可以在模板文件中直接使用。 123456789101112131415161718例子： &lt;div style=&quot;margin-left: 350px&quot;&gt; &lt;h3&gt;内置对象#request,#session，session的使用&lt;/h3&gt; &lt;p&gt;获取作用域中的数据&lt;/p&gt; &lt;p th:text=&quot;$&#123;#request.getAttribute(&#x27;requestData&#x27;)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#session.getAttribute(&#x27;sessionData&#x27;)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;session.loginname&#125;&quot;&gt;&lt;/p&gt; &lt;br/&gt; &lt;br/&gt; &lt;h3&gt;使用内置对象的方法&lt;/h3&gt; getRequestURL=&lt;span th:text=&quot;$&#123;#request.getRequestURL()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt; getRequestURI=&lt;span th:text=&quot;$&#123;#request.getRequestURI()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt; getQueryString=&lt;span th:text=&quot;$&#123;#request.getQueryString()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt; getContextPath=&lt;span th:text=&quot;$&#123;#request.getContextPath()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt; getServerName=&lt;span th:text=&quot;$&#123;#request.getServerName()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt; getServerPort=&lt;span th:text=&quot;$&#123;#request.getServerPort()&#125;&quot;&gt;&lt;/span&gt;&lt;br/&gt;&lt;/div&gt; 8.12 内置工具类 内置工具类型： Thymeleaf自己的一些类，提供对string， date ，集合的一些处理方法 #dates: 处理日器的工具类 #numbers:处理数字的 #lists: 处理list集合的 12345678910111213141516171819202122232425262728293031323334353637&lt;div style=&quot;margin-left: 350px&quot;&gt; &lt;h3&gt;日期类对象 #dates&lt;/h3&gt; &lt;p th:text=&quot;$&#123;#dates.format(mydate )&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#dates.format(mydate,&#x27;yyyy-MM-dd&#x27;)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#dates.format(mydate,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#dates.year(mydate)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#dates.month(mydate)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#dates.monthName(mydate)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#dates.createNow()&#125;&quot;&gt;&lt;/p&gt; &lt;br/&gt; &lt;h3&gt;内置工具类#numbers，操作数字的&lt;/h3&gt; &lt;p th:text=&quot;$&#123;#numbers.formatCurrency(mynum)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#numbers.formatDecimal(mynum,5,2)&#125;&quot;&gt;&lt;/p&gt; &lt;br/&gt; &lt;h3&gt;内置工具类#strings,操作字符串&lt;/h3&gt; &lt;p th:text=&quot;$&#123;#strings.toUpperCase(mystr)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#strings.indexOf(mystr,&#x27;power&#x27;)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#strings.substring(mystr,2,5)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#strings.substring(mystr,2)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#strings.concat(mystr,&#x27;---java开发的黄埔军校---&#x27;)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#strings.length(mystr)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;$&#123;#strings.length(&#x27;hello&#x27;)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:unless=&quot;$&#123;#strings.isEmpty(mystr)&#125;&quot;&gt; mystring 不是 空字符串 &lt;/p&gt; &lt;br/&gt; &lt;h3&gt;内置工具类#lists,操作list集合&lt;/h3&gt; &lt;p th:text=&quot;$&#123;#lists.size(mylist)&#125;&quot;&gt;&lt;/p&gt; &lt;p th:if=&quot;$&#123;#lists.contains(mylist,&#x27;a&#x27;)&#125;&quot;&gt;有成员a&lt;/p&gt; &lt;p th:if=&quot;!$&#123;#lists.isEmpty(mylist)&#125;&quot;&gt; list 集合有多个成员&lt;/p&gt; &lt;br/&gt; &lt;h3&gt;处理null&lt;/h3&gt; &lt;p th:text=&quot;$&#123;zoo?.dog?.name&#125;&quot;&gt;&lt;/p&gt; &lt;/div&gt; 8.12 自定义模板模板是内容复用， 定义一次，在其他的模板文件中多次使用。 模板使用： 1.定义模板 2.使用模板 模板定义语法： 1234567891011th:fragment=&quot;模板自定义名称&quot;例如：&lt;div th:fragment=&quot;head&quot;&gt; &lt;p&gt; 动力节点-java开发 &lt;/p&gt; &lt;p&gt; www.bjpowernode.com &lt;/p&gt;&lt;/div&gt; 引用模板语法： ~{templatename :: selector}templatename: 文件名称selector： 自定义模板名称2）templatename :: selectortemplatename: 文件名称selector： 自定义模板名称 对于使用模板：有包含模板（th:include）， 插入模板(th:insert) 例子： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;使用模板&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot;margin: 0 auto&quot;&gt; &lt;h3&gt;插入模板格式一：th:insert&lt;/h3&gt; &lt;div th:insert=&quot;~&#123;head :: top&#125;&quot;&gt; 第一种方式使用模板 &lt;/div&gt; &lt;h3&gt;格式二&lt;/h3&gt; &lt;p th:insert=&quot;head :: top&quot;&gt; 第二种方式使用模板&lt;/p&gt; &lt;h3&gt;包含模板格式一：th:include&lt;/h3&gt; &lt;div th:include=&quot;~&#123;head :: top&#125;&quot;&gt; 第一种方式使用模板 &lt;/div&gt; &lt;h3&gt;格式二&lt;/h3&gt; &lt;div th:include=&quot;head :: top&quot;&gt;第二种方式使用模板&lt;/div&gt; &lt;br&gt; &lt;hr&gt; &lt;h3&gt;使用整个文件作为复用的内容（整个文件作为模板使用）&lt;/h3&gt;&lt;!-- 这里footer代表文件名，html代表整个文件 --&gt; &lt;div th:include=&quot;footer :: html&quot;&gt;&lt;/div&gt; &lt;hr&gt; &lt;div th:include=&quot;footer&quot;&gt;&lt;/div&gt; &lt;hr&gt; &lt;h3&gt;使用其他目录中的文件&lt;/h3&gt; &lt;div th:insert=&quot;common/left :: html&quot;&gt;&lt;/div&gt; &lt;br&gt; &lt;div th:include=&quot;common/left&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 九、打包9.1 打包为jar包1.创建了一个jsp应用 2.修改pom.xml 1)指定打包后的文件名称 1234&lt;build&gt; &lt;!--打包后的文件名称--&gt; &lt;finalName&gt;myboot&lt;/finalName&gt;&lt;/build&gt; 2)指定jsp编译目录 1234567891011121314151617181920212223242526&lt;!--resources插件， 把jsp编译到指定的目录--&gt;&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!--使用了mybatis ，而且mapper文件放在src/main/java目录--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!--把src/main/resources下面的所有文件，都包含到classes目录--&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt;&lt;/resources&gt; 3）执行打包是war 12&lt;!--打包类型--&gt;&lt;packaging&gt;war&lt;/packaging&gt; 4）主启动类继承SpringBootServletInitializer 123456789101112131415/** * SpringBootServletInitializer: 继承这个类， 才能使用独立tomcat服务器 */@SpringBootApplicationpublic class JspApplication extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(JspApplication.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(JspApplication.class); &#125;&#125; 5）部署war 把war放到tomcat等服务器的发布目录中。 tomcat为例， myboot.war放到tomcat&#x2F;webapps目录。 9.2 打包为jar包1.创建了一个包含了jsp的项目 2.修改pom.xml ​ 1) 指定打包后的文件名称 1234&lt;build&gt; &lt;!--打包后的文件名称--&gt; &lt;finalName&gt;myboot&lt;/finalName&gt;&lt;/build&gt; 3.指定springboot-maven-plugin版本 12345678&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;!--打包jar， 有jsp文件时，必须指定maven-plugin插件的版本是 1.4.2.RELEASE--&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;/plugin&gt;&lt;/plugins&gt; 4.最后执行 maven clean package 在target目录中，生成jar 文件， 例子是myboot.jar 执行独立的springboot项目 在cmd中 java -jar myboot.jar 十、总结Spring + SpringMVC + SpringBoot 创建对象的：@Controller: 放在类的上面，创建控制器对象，注入到容器中@RestController: 放在类的上面，创建控制器对象，注入到容器中。 作用：复合注解是@Controller , @ResponseBody, 使用这个注解类的，里面的控制器方法的返回值 都是数据 @Service ： 放在业务层的实现类上面，创建service对象，注入到容器@Repository : 放在dao层的实现类上面，创建dao对象，放入到容器。 没有使用这个注解，是因为现在使用MyBatis框 架， dao对象是MyBatis通过代理生成的。 不需要使用@Repository、 所以没有使用。@Component: 放在类的上面，创建此类的对象，放入到容器中。 赋值的：@Value ： 简单类型的赋值， 例如 在属性的上面使用@Value(“李四”) private String name 还可以使用@Value,获取配置文件者的数据（properties或yml）。 @Value(“${server.port}”) private Integer port @Autowired: 引用类型赋值自动注入的，支持byName, byType. 默认是byType 。 放在属性的上面，也可以放在构造 方法的上面。 推荐是放在构造方法的上面@Qualifer: 给引用类型赋值，使用byName方式。 @Autowird, @Qualifer都是Spring框架提供的。 @Resource ： 来自jdk中的定义， javax.annotation。 实现引用类型的自动注入， 支持byName, byType. 默认是byName, 如果byName失败， 再使用byType注入。 在属性上面使用 其他：@Configuration ： 放在类的上面，表示这是个配置类，相当于xml配置文件 @Bean：放在方法的上面， 把方法的返回值对象，注入到spring容器中。 @ImportResource ： 加载其他的xml配置文件， 把文件中的对象注入到spring容器中 @PropertySource ： 读取其他的properties属性配置文件 @ComponentScan： 扫描器 ，指定包名，扫描注解的 @ResponseBody: 放在方法的上面，表示方法的返回值是数据， 不是视图@RequestBody : 把请求体中的数据，读取出来， 转为java对象使用。 @ControllerAdvice: 控制器增强， 放在类的上面， 表示此类提供了方法，可以对controller增强功能。 @ExceptionHandler : 处理异常的，放在方法的上面 @Transcational : 处理事务的， 放在service实现类的public方法上面， 表示此方法有事务 SpringBoot中使用的注解 @SpringBootApplication ： 放在启动类上面， 包含了@SpringBootConfiguration @EnableAutoConfiguration， @ComponentScan ​MyBatis相关的注解 @Mapper ： 放在类的上面 ， 让MyBatis找到接口， 创建他的代理对象@MapperScan :放在主类的上面 ， 指定扫描的包， 把这个包中的所有接口都创建代理对象。 对象注入到容器中@Param ： 放在dao接口的方法的形参前面， 作为命名参数使用的。 Dubbo注解@DubboService: 在提供者端使用的，暴露服务的， 放在接口的实现类上面@DubboReference: 在消费者端使用的， 引用远程服务， 放在属性上面使用。@EnableDubbo : 放在主类上面， 表示当前引用启用Dubbo功能。","categories":[],"tags":[]},{"title":"Mybatis","slug":"Mybatis","date":"2022-07-20T04:14:12.000Z","updated":"2022-07-20T14:45:20.336Z","comments":true,"path":"2022/07/20/Mybatis/","link":"","permalink":"http://example.com/2022/07/20/Mybatis/","excerpt":"","text":"何为Mybatis呢？用官网的话来说： MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results. MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records. MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 用比较直白的话来说： mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 MyBatis的主要设计目的就是让我们对执行SQL语句时对输入输出的数据管理更加方便，所以方便地写出SQL和方便地获取SQL的执行结果才是MyBatis的核心竞争力。 Mybatis-demo1此demo以及后面的demo都是以maven作为项目构建工具的 一、项目的一些配置1、首先我们要先引入一些必要依赖，pom.xml中的所有依赖如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.mybatis&lt;/groupId&gt; &lt;artifactId&gt;MyBatis_demo1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;16&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;16&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt;&lt;!-- Mybatis核心--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt;&lt;!-- junit测试--&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;!-- Mysql驱动--&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 日志--&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、mybatis中最重要的就是核心配置文件了，核心配置文件主要就是配置数据库的连接池、引入映射文件、设置全局参数、设置类型别名等等。 以下为核心配置文件mybatis-config.xml: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;!-- Mybatis核心配置文件中。标签的顺序： &quot;(properties?,settings?,typeAliases?,typeHandlers?, objectFactory?,objectWrapperFactory?,reflectorFactory?, plugins?,environments?,databaseIdProvider?,mappers?)&quot;.--&gt;&lt;!-- 引入properties文件--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt;&lt;!-- 设置类型别名--&gt;&lt;!-- alias=&quot;User&quot; 可写可不写,默认就是类名user(不区分大小写)--&gt; &lt;typeAliases&gt;&lt;!-- &lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot; alias=&quot;User&quot; &gt;&lt;/typeAlias&gt;--&gt;&lt;!-- 以包为单位,将包下所有类型设置默认的类型别名,及类名且不区分大小写--&gt; &lt;package name=&quot;com.atguigu.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;!-- environments :配置多个连接数据库的环境 属性： default:设置默认使用的环境的id--&gt; &lt;environments default=&quot;development&quot;&gt;&lt;!-- environment:配置某个具体的环境 属性： id:表示连接数据库的环境的唯一标识，不能重复--&gt; &lt;environment id=&quot;development&quot;&gt;&lt;!-- 事务管理器类型为JDBC 属性： type=&quot;JDBC/MANAGED&quot; JDBC:表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式 MANAGED:被管理，例如Spring--&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!-- type=&quot;POOLED&quot;表示使用数据库连接池，会对我们当前的数据库连接进行保存 dataSource:配置数据源 属性： type:设置数据源的类型 type=&quot;POOLED/UNPOOLED/JNDI&quot; POOLED:表示使用数据库连接池缓存数据库连接 UNPOOLED:表示不使用数据库连接池 JNDI:表示使用上下文中的连接源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- 引入映射文件--&gt; &lt;mappers&gt;&lt;!-- &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;--&gt;&lt;!-- 以包为单位引入映射文件 要求: 1.mapper接口所在的包要和映射文件所在的包一致 2.mapper接口要和映射文件的名字一致--&gt; &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 连接池的具体参数都写在了jdbc.properties文件里利用properties标签引入的 jdbc.properties文件如下： 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=rootjdbc.password=ljc625995 由上面的代码可知，properties文件里的参数在mybatis-config里引用的时候，可以用${}来获取。 3、另外，为了更方便调试和管理程序我们还需要配置一个log4j日志，log4j.xml配置如下： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 二、主要核心代码及测试其实mybatis的主要使用方法就是，需要定义一个接口，我们可以在此接口中定义很多方法。然后根据此接口编写一个xml的mapper文件，这个文件名必须要和接口名一样，在mapper中对应编写id和接口中方法名一致的各种sql语句。 mybatis的主要用途无非就是对数据库中的数据进行增删改查 增删改查代码示例如下：首先我们需要在mysql中建立一个名为mybatis的数据库，然后创建一个名为t_user的表 对应上面的表我们需要创建一个User类来接收从数据库查出的数据，User如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atguigu.mybatis.pojo;public class User &#123; private Integer id; private String username; private String password; private Integer age; private String sex; private String email; public User(Integer id, String username, String password, Integer age, String sex, String email) &#123; this.id = id; this.username = username; this.password = password; this.age = age; this.sex = sex; this.email = email; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 我们需要创建一个UserMapper接口来定义对数据库的操作方法 ，Usermapper如下： 123456789101112131415161718192021222324252627282930package com.atguigu.mybatis.mapper;import com.atguigu.mybatis.pojo.User;import java.util.List;public interface UserMapper &#123; /** * Mybatis面向接口编程的两个一致： * 1、映射文件的namespace要和mapper接口的全类名保持一致 * 2、映射文件中SQL语句的id要和mapper接口中的方法名保持一致 */ //添加用户信息 int insertUser(); //修改用户信息 void updateUser(); //删除用户信息 void deleteUser(); //根据id查询用户信息 User getUserById(); //查询所有用户信息 List&lt;User&gt; getAllUser();&#125; UserMapper接口所对应的UserMapper,xml如下： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt;&lt;!-- int insertUser();--&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,&#x27;user&#x27;,&#x27;123456&#x27;,23,&#x27;女&#x27;,&#x27;13345@qq.com&#x27;); &lt;/insert&gt;&lt;!-- void updateUser();--&gt; &lt;update id=&quot;updateUser&quot;&gt; update t_user set username = &#x27;张三&#x27; where id = 1001; &lt;/update&gt;&lt;!-- void deleteUser();--&gt; &lt;delete id=&quot;deleteUser&quot;&gt; delete from t_user where id = 1008; &lt;/delete&gt;&lt;!-- User getUserById();--&gt;&lt;!-- 查询功能的标签必须设置resultType或者resultMap resultType:设置默认的映射关系（当数据库字段名和对象属性名相同时使用,且是一对一关系） resultMap：设置自定义映射关系（反之） --&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt; select * from t_user where id = 1001; &lt;/select&gt;&lt;!-- List&lt;User&gt; getAllUser();--&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;USER&quot;&gt; select * from t_user; &lt;/select&gt;&lt;/mapper&gt; 值得注意的是mapper接口和mapper.xml的包路径一定要相同，不同就会报错。还有每段sql代码的id一定要对应一个mapper接口中的方法。 测试1、插入数据 sql代码如下： 123&lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,&#x27;xxx&#x27;,&#x27;123456&#x27;,100,&#x27;男&#x27;,&#x27;13345@qq.com&#x27;);&lt;/insert&gt; 测试代码如下： 123456789101112131415161718 @Test public void testMyBatis() throws IOException &#123; //加载核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //获取SqlSessionFactoryBuilder SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //sqlSessionFactory SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(true);//true表示自动提交事务 //获取mapper接口对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //测试功能 int result = mapper.insertUser(); //提交事务// sqlSession.commit(); System.out.println(&quot;result:&quot; + result); &#125; 运行结果： 控制台日志信息如下： 根据日志判断代码运行成功 查看数据库数据已成功插入： 2、更新数据 sql代码如下： 1234&lt;!-- void updateUser();--&gt; &lt;update id=&quot;updateUser&quot;&gt; update t_user set username = &#x27;小小怪&#x27; where id = 1007; &lt;/update&gt; 测试代码如下： 12345678@Testpublic void testUpdate() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.updateUser();&#125; 日志： 数据库： 3、数据删除 sql代码： 1234&lt;!-- void deleteUser();--&gt; &lt;delete id=&quot;deleteUser&quot;&gt; delete from t_user where id = 1007; &lt;/delete&gt; 测试代码： 12345678@Test public void testCRUD() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.deleteUser(); &#125; 日志： 数据库： id为1007的记录已被删除 4、查询数据 123&lt;!-- 查询功能的标签必须设置resultType或者resultMap resultType:设置默认的映射关系（当数据库字段名和对象属性名相同时使用,且是一对一关系） resultMap：设置自定义映射关系（反之） （1）查询一条数据，用一个User对象接收，也就是数据库字段名和对象属性相同时 sql代码： 123&lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt; select * from t_user where id = 1001;&lt;/select&gt; 测试代码： 123456789@Testpublic void testCRUD() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User userById = mapper.getUserById(); System.out.println(userById);&#125; 日志及控制台输出： （2）查询多条数据，用List集合来接收 sql代码： 1234&lt;!-- List&lt;User&gt; getAllUser();--&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;USER&quot;&gt; select * from t_user; &lt;/select&gt; 测试代码： 123456789@Testpublic void testCRUD() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = mapper.getAllUser(); list.forEach(user -&gt; System.out.println(user));&#125; 日志及控制台输出： Mybatis-demo2一、Mybatis获取参数值12345678910111213141516171819202122/** * Mybatis获取参数值的两种方式：$&#123;&#125;和#&#123;&#125; * $&#123;&#125;本质是字符串拼接 * #&#123;&#125;本质是占位符赋值 * Mybatis获取参数值的各种情况： * 1.mapper接口方法的参数为单个字面量类型 * 可以通过$&#123;&#125;和#&#123;&#125;以任意的名称获取参数值，但是需要注意$&#123;&#125;的单引号问题 * 2.mapper接口方法的参数为多个时 * 此时Mybatis会将这些参数放在一个map集合中，以两种方式进行存储 * 以arg0,arg1...为键，以参数为值 * 以param1,param2...为键，以参数为值 * 因此只需要通过#&#123;&#125;和$&#123;&#125;以键的方式访问即可，但是需要注意$&#123;&#125;的单引号问题 * 3.若mapper接口方法的参数有多个时，可以手动将这些参数放在一个map集合中存储 * 这个可以用自己设置的键进行访问 * 4.mapper接口方法的参数是一个实体类类型的参数 * 只需要通过#&#123;&#125;和$&#123;&#125;以属性的方式访问属性值即可，但是需要注意$&#123;&#125;单引号的问题 * 5.使用@Param注解命名参数 *此时Mybatis会将这些参数放在一个map集合中，以两种方式进行存储 * 以@Param注解的值为键，以参数为值 * 以param1,param2...为键，以参数为值 * 因此只需要通过#&#123;&#125;和$&#123;&#125;以键的方式访问值即可 */ Mybatis获取参数值的两种方式：${}和#{} ${}本质是字符串拼接（需要注意字符的引号问题） #{}本质是占位符赋值 Mybatis获取参数值的各种情况： 1.mapper接口方法的参数为单个字面量类型 可以通过${}和#{}以任意的名称获取参数值，但是需要注意${}的单引号问题 2.mapper接口方法的参数为多个时 此时Mybatis会将这些参数放在一个map集合中，以两种方式进行存储 以arg0,arg1…为键，以参数为值 以param1,param2…为键，以参数为值 因此只需要通过#{}和${}以键的方式访问即可，但是需要注意${}的单引号问题 3.若mapper接口方法的参数有多个时，可以手动将这些参数放在一个map集合中存储 这个可以用自己设置的键进行访问 4.mapper接口方法的参数是一个实体类类型的参数 只需要通过#{}和${}以属性的方式访问属性值即可，但是需要注意${}单引号的问题 5.使用@Param注解命名参数 *此时Mybatis会将这些参数放在一个map集合中，以两种方式进行存储 以@Param注解的值为键，以参数为值 以param1,param2…为键，以参数为值 因此只需要通过#{}和${}以键的方式访问值即可 1、mapper接口方法的参数为单个字面量类型时： sql代码： 123456&lt;!-- User GetUserByUsername(String username);--&gt; &lt;select id=&quot;GetUserByUsername&quot; resultType=&quot;User&quot;&gt;-- username = &#x27;$&#123;username&#125;&#x27;; select * from t_user where username = #&#123;username&#125;; &lt;/select&gt; 此时#{}随便填一个名称，Mybatis最终获取到的username都是从GetUserByUsername方法传进来的。 2、mapper接口方法的参数为多个时： sql代码： 12345&lt;!-- select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;;--&gt;&lt;!-- User checkLogin(String username,String password);--&gt; &lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;param1&#125; and password = #&#123;param2&#125;; &lt;/select&gt; 此时如果我们每有在mapper接口的方法上加上特定注解，那我们就只能利用arg0、arg1…或者param1、param2…按传参的顺序获取参数 3、若mapper接口方法的参数有多个时，可以手动将这些参数放在一个map集合中存储 sql代码： 1234&lt;!-- User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt; &lt;select id=&quot;checkLoginByMap&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;; &lt;/select&gt; 测试代码： 12345678910@Testpublic void testCheckLoginByMap()&#123; SqlSession sqlSession = SqlSessionUtils.GetSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;username&quot;,&quot;user&quot;); map.put(&quot;password&quot;,&quot;123456&quot;); User user = mapper.checkLoginByMap(map); System.out.println(user);&#125; 4、mapper接口方法的参数是一个实体类类型的参数 sql代码： 1234&lt;!-- int insertUser(User user);--&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;) &lt;/insert&gt; 测试代码： 1234567@Testpublic void testInsertUser()&#123; SqlSession sqlSession = SqlSessionUtils.GetSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); int result = mapper.insertUser(new User(null,&quot;李四&quot;,&quot;123&quot;,23,&quot;男&quot;,&quot;123435@qq.cpm&quot;)); System.out.println(result);&#125; 5、使用@Param注解命名参数 mapper接口的方法代码： 12//验证登录（使用@Param）User checkLoginByParam(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password); sql代码： 1234&lt;!-- User checkLoginByParam(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password);--&gt; &lt;select id=&quot;checkLoginByParam&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;; &lt;/select&gt; 在mapper接口的方法上加上@Param注解后就可以在注解里随意命名参数名，然后再xml里用此参数名获取参数就可以了 二、Mybatis接收各种查询结果12345678910111213/** * Mybatis的各种查询功能 * 1.若查询出的数据只有一条，可以通过实体类对象接收或集合接收 * 2.若查询出的对象有多条，一定不能通过实体类对象接收能以集合接受，此时会抛异常TooManyResultsException *a&gt;可以通过实体类型的list集合接收 *b&gt;可以通过map类型的list集合接受 *c&gt;可以在mapper接口的方法上添加@Mapkey注解，此时可以将每条数据转换的map集合作为值，以某个字段的值作为键，放在同一个Map集合中 * Mybatis中设置了默认的类型别名 * java.Lang.Integer---&gt;int,integer * int---&gt;_int,_integer * Map---&gt;map * String---&gt;string */ 有几种接收查询结果的方式前面都已经出现过了，这里主要讲一下怎么用map来接收查询结果 1、通过map集合收一条数据 mapper接口的方法： 12//根据ID查询用户信息为一个map集合Map&lt;String,Object&gt; getUserByIdToMap(@Param(&quot;id&quot;) Integer id); sql代码： 1234&lt;!-- Map&lt;String,Object&gt; getUserByIdToMap(@Param(&quot;id&quot;) Integer id);--&gt; &lt;select id=&quot;getUserByIdToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user where id = #&#123;id&#125;; &lt;/select&gt; 测试代码： 1234567@Testpublic void testGetUserByIdToMap()&#123; SqlSession sqlSession = SqlSessionUtils.GetSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); Map&lt;String, Object&gt; userByIdToMap = mapper.getUserByIdToMap(1001); System.out.println(userByIdToMap.get(&quot;email&quot;));&#125; 这个方式就是把以数据库表的字段为key,具体的数据为value，把一条数据存入到一个map集合中。 2、通过map类型的list集合接收多条数据 mapper接口的方法： 12//查询所有用户信息为map集合List&lt;Map&lt;String,Object&gt;&gt; getAllUserToMap(); sql代码： 1234&lt;!-- List&lt;Map&lt;String,Object&gt;&gt; getAllUserToMap();--&gt; &lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user; &lt;/select&gt; 测试代码： 1234567@Testpublic void testGetAllUserToMap()&#123; SqlSession sqlSession = SqlSessionUtils.GetSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); List&lt;Map&lt;String,Object&gt;&gt; userList = mapper.getAllUserToMap(); userList.forEach(map -&gt; System.out.println(map));&#125; 3、在mapper接口的方法上添加@Mapkey注解 mapper接口的方法： 123//使用@MapKey(&quot;id&quot;)注解@MapKey(&quot;id&quot;)Map&lt;String,Object&gt; getAllUserToMap1(); sql代码： 12345&lt;!-- @MapKey(&quot;id&quot;) Map&lt;String,Object&gt; getAllUserToMap1();--&gt; &lt;select id=&quot;getAllUserToMap1&quot; resultType=&quot;map&quot;&gt; select * from t_user; &lt;/select&gt; 测试代码： 1234567@Testpublic void testGetAllUserToMap1()&#123; SqlSession sqlSession = SqlSessionUtils.GetSqlSession(); SelectMapper mapper = sqlSession.getMapper(SelectMapper.class); Map&lt;String,Object&gt; map1 = mapper.getAllUserToMap1(); System.out.println(map1);&#125; 运行结果： 此时可以将每条数据转换的map集合作为值，以某个字段的值作为键，放在同一个Map集合中 三、Mybatis的一些用法示例 1、模糊查询 sql代码： 123456&lt;!-- List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;&lt;!-- select * from t_user where username like &#x27;%$&#123;username&#125;%&#x27; select * from t_user where username like concat(&#x27;%&#x27;,#&#123;username&#125;,&#x27;%&#x27;)--&gt; &lt;select id=&quot;getUserByLike&quot; resultType=&quot;user&quot;&gt; select * from t_user where username like &quot;%&quot;#&#123;username&#125;&quot;%&quot; &lt;/select&gt; 2、批量删除 mapper接口方法： 12//批量删除int deleteMore(@Param(&quot;ids&quot;) String ids); sql代码： 12345&lt;!-- int deleteMore(@Param(&quot;ids&quot;) String ids);--&gt;&lt;!-- (#&#123;ids&#125;) 也可以--&gt; &lt;delete id=&quot;deleteMore&quot;&gt; delete from t_user where id in ($&#123;ids&#125;) &lt;/delete&gt; 测试代码： 1234567@Testpublic void testDeleteMore()&#123; SqlSession sqlSession = SqlSessionUtils.GetSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); int result = mapper.deleteMore(&quot;1002,1004,1005&quot;); System.out.println(result);&#125; 3、查询指定表中的数据 mapper接口方法： 12//查询指定表中的数据List&lt;User&gt; getUserByTableName(@Param(&quot;tableName&quot;) String tableName); sql代码： 1234&lt;!-- List&lt;User&gt; getUserByTableName(@Param(&quot;tableName&quot;) String tableName);--&gt; &lt;select id=&quot;getUserByTableName&quot; resultType=&quot;User&quot;&gt; select * from $&#123;tableName&#125;; &lt;/select&gt; 测试代码： 1234567@Testpublic void testGetUserByTableName()&#123; SqlSession sqlSession = SqlSessionUtils.GetSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); List&lt;User&gt; user = mapper.getUserByTableName(&quot;t_user&quot;); System.out.println(user);&#125; 4、获取自增的主键 需要先在数据库中将表设置为自增 mapper接口方法： 12//添加用户信息void insertUser(User user); sql代码： 12345678&lt;!-- void insertUser(User user);--&gt;&lt;!-- useGeneratedKeys:设置当前标签中的sql使用了自增的主键 keyProperty:将自增的主键的赋值传输到映射文件中参数的某个属性--&gt; &lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;); &lt;/insert&gt; 测试代码： 12345678@Testpublic void testInsertUser()&#123; SqlSession sqlSession = SqlSessionUtils.GetSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); User user = new User(null, &quot;里更&quot;, &quot;123&quot;, 34, &quot;男&quot;, &quot;65432@qq.com&quot;); mapper.insertUser(user); System.out.println(user);&#125; 运行结果： 数据库： 由上述代码及截图可知我们将数据封装在一个User对象实例中，然后将对象实例作为参数传入insertUser方法中，最后竟然奇迹般的在User对象的实例中得到了自增的主键。这得全靠 useGeneratedKeys&#x3D;”true” keyProperty&#x3D;”id”两个参数，前者设置当前标签中的sql使用了自增的主键，后者将自增的主键赋值给user实例的id属性，因此我们就可以在user实例中获取自增的主键了。 Mybatis-demo3一、解决字段名和属性名不一致的情况这里我们需要明白一点，就是在数据库中我们为字段取名通常靠下划线“_”连接两个单词，而在java中我们的属性名通常用驼峰命名法来命名，这就导致了当我们用一个java对象取去接收从数据库里查出来的数据时就会出现映射问题。目前在mybatis中有三种常用的解决方法。 1、为字段起别名 就是利用sql语句可以给查出来的数据起别名的方法，使别名和java属性的名称一样就可以了。 2、设置全局配置，将“_”自动映射为驼峰 这种方法需要在mybatis-confgi.xml里进行全局配置如下： 12345&lt;!-- 设置Mybatis的全局配置 --&gt; &lt;settings&gt;&lt;!-- 将下划线自动映射为驼峰，emp_name:empName--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; 3、通过resultMap设置自定义的映射关系 需要在mapper.xml中配置如下： 12345678910111213141516&lt;!-- resultMap 自定义映射关系 id 唯一标识不能重复 type 设置映射关系中的实体类类型--&gt; &lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&gt;&lt;!-- id 设置主键的映射关系 result 设置普通字段的映射关系 property 设置映射关系中的属性名,必须是type属性所设置的实体类类型中的属性名 column 设置映射关系中的字段名,必须是sql语句查询出的字段名 --&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; 1234&lt;!-- List&lt;Emp&gt; getAllEmp();--&gt;&lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empResultMap&quot;&gt; select * from t_emp;&lt;/select&gt; 注意resultMap&#x3D;”empResultMap”的empResultMap一定要和id&#x3D;”empResultMap”的empResultMap相同 二、处理多对一的映射关系1、级联属性赋值 1234567891011&lt;!-- 处理多对一映射关系一:级联属性赋值--&gt; &lt;resultMap id=&quot;empAndDeptResultMapOne&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;result property=&quot;dept.did&quot; column=&quot;did&quot;&gt;&lt;/result&gt; &lt;result property=&quot;dept.deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; 2、利用association标签 1234567891011121314151617&lt;!-- 处理多对一映射关系方式二 association --&gt; &lt;resultMap id=&quot;empAndDeptResultMapTwo&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;&lt;!-- association 处理多对一的映射关系 property 需要处理多对的映射关系的属性名 javaType 该属性的类型--&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; 3、分步查询（也是日常开发中最常用的） 假如我们有两个表t_emp和t_dept t_emp： t_dept: 当我们要查询一个员工的所有信息时，就会查到此员工所对应的did和dept_name，此时员工对象里的属性did就需要设置为Dept类型对应did和dept_name。 EmpMapper接口方法如下： 123//通过分步查询查询员工以及员工所对应的部门信息//分步查询第一步:查询员工信息Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid); EmpMapper.xml配置如下： 123456789101112131415161718192021222324 &lt;resultMap id=&quot;empAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;&lt;!-- select:设置分步查询得sql得唯一标识(namespace.SQLId或mapper接口得全类名.方法名) column:设置分步查询的查询条件 fetchType:当开启了全局延迟加载之后,可通过此属性手动控制延迟加载的效果 默认为lazy 设置为eager后为立即加载--&gt; &lt;association property=&quot;dept&quot; select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot; column=&quot;did&quot; fetchType=&quot;eager&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;!-- Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt; &lt;select id=&quot;getEmpAndDeptByStepOne&quot; resultMap=&quot;empAndDeptByStepResultMap&quot;&gt; select * from t_emp where eid = #&#123;eid&#125; &lt;/select&gt; DeptMapper接口方法如下： 123//通过分步查询查询员工以及员工所对应得部门信息//分步查询第二步:通过did查询员工所对应得部门Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did); DeptMapper.xml配置如下： 1234&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt; &lt;select id=&quot;getEmpAndDeptByStepTwo&quot; resultMap=&quot;empAndDeptByStepMap&quot;&gt; select * from t_dept where did = #&#123;did&#125;; &lt;/select&gt; 三、处理一对多的映射关系1、利用collection DeptMapper接口方法： 12//获取部门以及部门中所有的员工信息Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did); DeptMapper.xml配置如下： 123456789101112131415161718192021222324 &lt;resultMap id=&quot;deptAndEmpResultMap&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt;&lt;!-- collection 处理一对多的映射关系 ofType 表示该属性所对应的集合中存储数据的类型--&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt; &lt;select id=&quot;getDeptAndEmp&quot; resultMap=&quot;deptAndEmpResultMap&quot;&gt; select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;; &lt;/select&gt; 2、利用分步查询 DeptMapper接口方法如下： 123//通过分步查询查询部门以及部门中所有员工的信息//分步查询第一步:查询部门信息Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did); DeptMapper.xml配置如下： 12345678910111213 &lt;resultMap id=&quot;deptAndEmpByStepResultMap&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;emps&quot; select=&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot; column=&quot;did&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt; &lt;select id=&quot;getDeptAndEmpByStepOne&quot; resultMap=&quot;deptAndEmpByStepResultMap&quot;&gt; select * from t_dept where did = #&#123;did&#125;; &lt;/select&gt; EmpMapper接口方法如下： 123//通过分步查询查询部门以及部门中所有员工的信息//分步查询第二步:根据id查询员工信息List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did); EmpMapper.xml配置如下： 1234&lt;!-- List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt; &lt;select id=&quot;getDeptAndEmpByStepTwo&quot; resultMap=&quot;getDeptAndEmpByStepResultMap&quot;&gt; select * from t_emp where did = #&#123;did&#125;; &lt;/select&gt; 四、Mybatis的各种复杂增删改查12345678910111213141516171819202122/** * 动态SQL * 1.if:根据标签中test属性所对应的表达式决定标签中的内容是否需要拼接到SQL中 * 2.where:当where标签中有内容时,会自动生成where关键字,并且将内容前多余的and或or去掉 * 当where标签中没有内容时,此时where标签没有任何效果 * 注意:where标签不能将其内容后面多余的and或or去掉 * 3.trim * prefix/suffix 将trim标签中内容前面或后面添加指定内容 * suffixOverrides/prefixOverrides 将trim标签中内容前面或者后面去掉指定内容 *若标签中没有内容时,trim标签也没有任何效果 * 4.choose when otherwise 相当于if...else if ...else *when 至少要有一个 otherwise 最多只能有一个 * 5.foreach * collection 设置需要循环的数组或集合 * item 表示数组或者集合中的每一个数据 * separator 循环体之间的分隔符 * open:foreach标签所循环的所有内容的开始符 * close:foreach标签所循环的所有内容的结束符 * 6.sql标签 * 设置SQL片段:&lt;sql id=&quot;empColumns&quot;&gt;eid,emp_name,age,sex,email&lt;/sql&gt; * 引用SQL片段:&lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.DynamicSQLMapper&quot;&gt; &lt;sql id=&quot;empColumns&quot;&gt;eid,emp_name,age,sex,email&lt;/sql&gt;&lt;!-- List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt; &lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt; select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp where 1=1 &lt;if test=&quot;empName != null and empName !=&#x27;&#x27;&quot;&gt; and emp_name = #&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age != null and age != &#x27;&#x27;&quot;&gt; and age = #&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt; and email= #&#123;email&#125; &lt;/if&gt; &lt;/select&gt; &lt;select id=&quot;getEmpByCondition2&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;where&gt; &lt;if test=&quot;empName != null and empName !=&#x27;&#x27;&quot;&gt; and emp_name = #&#123;empName&#125; &lt;/if&gt; &lt;if test=&quot;age != null and age != &#x27;&#x27;&quot;&gt; and age = #&#123;age&#125; &lt;/if&gt; &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt; and email= #&#123;email&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;getEmpByCondition1&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot; &gt; &lt;if test=&quot;empName != null and empName !=&#x27;&#x27;&quot;&gt; emp_name = #&#123;empName&#125; and &lt;/if&gt; &lt;if test=&quot;age != null and age != &#x27;&#x27;&quot;&gt; age = #&#123;age&#125; or &lt;/if&gt; &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt; sex = #&#123;sex&#125; and &lt;/if&gt; &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt; email= #&#123;email&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt;&lt;!-- List&lt;Emp&gt; getEmpByChoose(Emp emp);--&gt; &lt;select id=&quot;getEmpByChoose&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;empName != null and empName != &#x27;&#x27;&quot;&gt; emp_name = #&#123;empName&#125; &lt;/when&gt; &lt;when test=&quot;age != null and age != &#x27;&#x27;&quot;&gt; age = #&#123;age&#125; &lt;/when&gt; &lt;when test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt; sex = #&#123;sex&#125; &lt;/when&gt; &lt;when test=&quot;email != null and email != &#x27;&#x27;&quot;&gt; email = #&#123;email&#125; &lt;/when&gt; &lt;otherwise&gt; did = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt;&lt;!-- int deleteMoreByArray(@Param(&quot;eids&quot;) Integer[] eids);--&gt; &lt;delete id=&quot;deleteMoreByArray&quot;&gt;&lt;!-- delete from t_emp where eid in--&gt;&lt;!-- &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;--&gt;&lt;!-- #&#123;eid&#125;--&gt;&lt;!-- &lt;/foreach&gt;--&gt; delete from t_emp where &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;or&quot;&gt; eid = #&#123;eid&#125; &lt;/foreach&gt; &lt;/delete&gt;&lt;!-- int insertMoreByList(@Param(&quot;emps&quot;) List emps);--&gt; &lt;insert id=&quot;insertMoreByList&quot;&gt; insert into t_emp values &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null) &lt;/foreach&gt; &lt;/insert&gt;&lt;/mapper&gt; 五、Mybatis的缓存1、Mybatis的一级缓存 一级缓存是SqlSession级别的，通过一个SqlSession查询数据会被缓存，下次查询相同数据，就会从缓存中直接获取，不会从数据库重新访问 一级缓存失效的四种情况： （1）、不同的SqlSession对应不同的一级缓存 （2）、同一个SqlSession但是查询条件不同 （3）、同一个SqlSeeeion两次查询期间执行的任何一次增删改操作 （4）、同一个SqlSession两次查询期间手动清空了缓存 2、Mybatis的二级缓存 二级缓存是SqlSessionFactory级别的，通过同一个SqlSessionFactory创建的SqlSession的查询结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 二级缓存的开启条件： a&gt;在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”,默认为true,不需要设置。 b&gt;在映射文件中设置标签 c&gt;二级缓存必须在SqlSession关闭或提交后有效 d&gt;查询的数据所转换的实体类类型必须实现序列化的接口 使二级缓存失效的情况： 两次查询之间执行了任意的增删改 3、二级缓存的相关配置 在mapper配置文件中添加的cache标签可以设置一些属性： a&gt;evlction属性：缓存回收策略 LRU(Least Recently Used) 最近最少使用的：移除最长时间步被使用的对象。 FIFO(First in First out) 先进先出：按对象进入缓存的顺序来移除它们。 SOFT 软引用：移除基于垃圾回收器状态和软引用规则的对象 WEAK 弱引用：更积极的移除基于垃圾收集器和弱引用规则的对象。 默认是LRU. b&gt;flushInterval属性：刷新间隔，单位毫秒 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 c&gt;size属性:引用数目，正整数 代表缓存最多可以存多少个对象，太大容易导致内存溢出 d&gt;readOnly属性：只读，true&#x2F;false e&gt;true:只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势 f&gt;false:读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false 4、Mybatis缓存查询的顺序 a&gt;先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以直接拿来用。 b&gt;如果二级缓存没有命中，则再查一级缓存 c&gt;如果一级缓存也没有命中，则查询数据库 d&gt;SqlSession关闭之后，一级缓存中的数据会写入二级缓存 Mybatis-MBG第一次接触这个逆向工程感觉太高级了，竟然可以一键生成mapper接口、mapper配置文件以及数据库表对应的java类，啊这，还有天理吗。 不说废话了，下面我们来看看什么是逆向工程： 其实逆向工程就是根据数据库里已经存在的表生成对应的mapper接口、mapper配置文件以及数据库表对应的java类，说白了就是一个代码生成器。 逆向工程配置步骤：一、引入依赖123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;build&gt;&lt;!--构建过程中用到得插件--&gt; &lt;plugins&gt;&lt;!-- 具体插件,逆向工程的操作是以构建过程中插件形式出现的--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-maven-plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;dependencies&gt;&lt;!-- 逆向工程的核心依赖--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 数据库连接池--&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.2&lt;/version&gt; &lt;/dependency&gt;&lt;!-- MySQL驱动--&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 二、配置generatorConfig.xml123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD（清新简洁版） MyBatis3: 生成带条件的CRUD（奢华尊享版） --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!-- 数据库的连接信息 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;ljc625995&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- javaBean的生成策略--&gt; &lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.pojo&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- SQL映射文件的生成策略 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- Mapper接口的生成策略 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 逆向分析的表 --&gt; &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt; &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt; &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt; &lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 测试： 只需双击mybatis-generator:generate即可生成如下东西： 太美妙了 分页插件一、依赖引入123456&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.1&lt;/version&gt;&lt;/dependency&gt; 二、设置分页插件1234&lt;!-- 分页插件--&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt; &lt;/plugins&gt; 上面这个是在核心配置文件中配置 测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.mybatis;import com.atguigu.mybatis.mapper.EmpMapper;import com.atguigu.mybatis.pojo.Emp;import com.github.pagehelper.Page;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;public class PageHelperTest &#123; /** * limit index,pageSize * index:当前页的起始索引 * pageSize:每页显示的条款 * pageNum:当前页的页码 * index = (pageNum-1)*pageSize * * 使用Mybatis的分页插件实现分页功能 * 1. 需要在查询功能之前开启分页 * PageHelper.startPage(int pageNum,int pageSize); * 2.在查询功能之后获取分页相关信息 * PageInfo&lt;Emp&gt; page = new PageInfo&lt;&gt;(list,3); * list表示分页数据 * 3表示当前导航分页的数据 */ @Test public void testPageHelper() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);// Page&lt;Object&gt; page = PageHelper.startPage(1, 4); PageHelper.startPage(2, 4); List&lt;Emp&gt; list = mapper.selectByExample(null); list.forEach(emp -&gt; System.out.println(emp));// PageInfo&lt;Emp&gt; page = new PageInfo&lt;&gt;(list,3);// list.forEach(emp -&gt; System.out.println(emp));// System.out.println(page); &#125;&#125;","categories":[],"tags":[]},{"title":"springMVC-annotation","slug":"springMVC-annotation","date":"2022-06-25T15:42:08.000Z","updated":"2022-06-25T15:49:58.102Z","comments":true,"path":"2022/06/25/springMVC-annotation/","link":"","permalink":"http://example.com/2022/06/25/springMVC-annotation/","excerpt":"","text":"这个Demo就单纯的展示一下springMVC的纯注解开发 用来代替web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.atguigu.mvc.config;/** * 纯注解MVC */import org.springframework.web.filter.CharacterEncodingFilter;import org.springframework.web.filter.HiddenHttpMethodFilter;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import javax.servlet.Filter;//web工程的初始化类，用来代替web.xmlpublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定spring的配置类 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; /** * 指定springMVC的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; /** * 注册过滤器 * @return */ @Override protected Filter[] getServletFilters() &#123; CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(&quot;UTF-8&quot;); characterEncodingFilter.setForceResponseEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]&#123;characterEncodingFilter,hiddenHttpMethodFilter&#125;; &#125;&#125; 用来代替springMVC.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.atguigu.mvc.config;import com.atguigu.mvc.interceptor.TestInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.context.ContextLoader;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.multipart.MultipartResolver;import org.springframework.web.multipart.commons.CommonsMultipartResolver;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.*;import org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;import org.thymeleaf.spring5.SpringTemplateEngine;import org.thymeleaf.spring5.view.ThymeleafViewResolver;import org.thymeleaf.templatemode.TemplateMode;import org.thymeleaf.templateresolver.ITemplateResolver;import org.thymeleaf.templateresolver.ServletContextTemplateResolver;import java.util.List;import java.util.Properties;/** * 代替SpringMVC的配置文件： * 1.扫描组件 2、视图解析器 3、veiw_controller * 4.default-servlet-handler 5.mvc注解驱动 * 6.文件上传解析器 7.异常处理 8.拦截器 *///将当前类标识为配置类@Configuration//扫描组件@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)//开启MVC注解驱动@EnableWebMvcpublic class WebConfig implements WebMvcConfigurer &#123;//WebMvcConfigurer 提供了很多配置的组件 //配置生成模板解析器 @Bean public ITemplateResolver templateResolver()&#123; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext() ); //设置前缀 templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); //设置后缀 templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; &#125; //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver)&#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; &#125; //生成视图解析器并为解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine)&#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; &#125;// 4.default-servlet-handler @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;// 8.拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; TestInterceptor testInterceptor = new TestInterceptor(); registry.addInterceptor(testInterceptor).addPathPatterns(&quot;/**&quot;); &#125;// 3、veiw_controller @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/hello&quot;).setViewName(&quot;hello&quot;); &#125;// 6.文件上传解析器 @Bean public MultipartResolver multipartResolver()&#123; CommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver(); return commonsMultipartResolver; &#125;// 7.异常处理 @Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties properties = new Properties(); properties.setProperty(&quot;java.lang.ArithmeticException&quot;,&quot;error&quot;); exceptionResolver.setExceptionMappings(properties); exceptionResolver.setExceptionAttribute(&quot;exception&quot;); resolvers.add(exceptionResolver); &#125;&#125;","categories":[],"tags":[]},{"title":"springMVC-demo5","slug":"springMVC-demo5","date":"2022-06-25T12:51:55.000Z","updated":"2022-06-25T15:36:26.497Z","comments":true,"path":"2022/06/25/springMVC-demo5/","link":"","permalink":"http://example.com/2022/06/25/springMVC-demo5/","excerpt":"","text":"springMVC的拦截器SpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandleInterceptor或者继承HandleInterceptorAdapter类 SpringMVC的拦截器必须在SpringMVC文件中进行配置 123456789101112131415161718192021222324252627282930&lt;!-- 配置拦截器 --&gt; &lt;mvc:interceptors&gt;&lt;!-- 有二种方法添加拦截器 --&gt;&lt;!--第一种写法 --&gt; &lt;bean class=&quot;com.atguigu.mvc.interceptors.Firstinterceptor&quot;&gt;&lt;/bean&gt; &lt;!--第二种写法 --&gt; &lt;ref bean=&quot;firstinterceptor&quot;&gt;&lt;/ref&gt; &lt;!-- 指定拦截规则 --&gt; &lt;mvc:interceptor&gt;&lt;!-- /** 表示拦截所有 --&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt;&lt;!-- exclude-mapping 排除不被拦截 --&gt;&lt;!-- / 表示主页不被拦截 --&gt; &lt;mvc:exclude-mapping path=&quot;/&quot;/&gt; &lt;ref bean=&quot;firstinterceptor&quot;&gt;&lt;/ref&gt; &lt;/mvc:interceptor&gt; &lt;!--配置在前的拦截器先执行 --&gt; &lt;ref bean=&quot;firstinterceptor&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;secondInterceptor&quot;&gt;&lt;/ref&gt; &lt;/mvc:interceptors&gt; 其实拦截器主要就是两种配置方式 1、 ​ 这种配置方式不需要在拦截器对应的java类上面加注解@Component 2、 这种配置方式需要在拦截器对应的java类上面加注解@Component 拦截器对应的java类 1234567891011121314151617181920212223242526272829package com.atguigu.mvc.interceptors;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Componentpublic class Firstinterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;Firstinterceptor----&gt;preHandle&quot;); //返回false表示拦截，true表示放行（在控制器之前拦截） return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;Firstinterceptor----&gt;postHandle&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;Firstinterceptor----&gt;afterCompletion&quot;); &#125;&#125; 从上面的代码中我们可以看到拦截器由三个方法 preHandle 在控制器之前运行 postHandle 在控制器之后运行 afterCompletion 在视图渲染完之后运行 在控制器中编写代码如下 12345@RequestMapping(&quot;/**/testInterceptor&quot;)public String testInterceptor()&#123; System.out.println(&quot;控制器运行&quot;); return &quot;success&quot;;&#125; html中编写代码如下 1&lt;a th:href=&quot;@&#123;/testInterceptor&#125;&quot;&gt;测试拦截器&lt;/a&gt;&lt;br&gt; 点击上图中的链接，控制台输出如下 再配置一个拦截器SecondInterceptor 12345678910111213141516171819202122232425262728package com.atguigu.mvc.interceptors;import org.springframework.stereotype.Component;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Componentpublic class SecondInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;Secondinterceptor----&gt;preHandle&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;Secondinterceptor----&gt;postHandle&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;Secondinterceptor----&gt;afterCompletion&quot;); &#125;&#125; 点击链接两个拦截器的各个方法执行顺序如下 springMVC的自定义异常处理springMVC的异常处理配置有xml配置和注解配置 xml配置 1234567891011&lt;!-- 配置异常处理--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;!-- 这里用来存储异常信息，将异常信息共享在请求域中的键 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 注解配置 1234567891011121314151617181920package com.atguigu.mvc.controller;/** * 利用注解来处理异常 */import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;//此注解内部有@Component注解，可以生成对象@ControllerAdvicepublic class ExceptionController &#123; @ExceptionHandler(value = &#123;ArithmeticException.class,NullPointerException.class&#125;) public String testException(Exception ex, Model model)&#123; model.addAttribute(&quot;ex&quot;,ex); return &quot;error&quot;; &#125;&#125; 创建一个视图error.html来反馈异常信息 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;出现错误&lt;p th:text=&quot;$&#123;ex&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在控制器中故意制造异常 12345@RequestMapping(&quot;/testExceptionHandler&quot;)public String testExceptionHandler()&#123; System.out.println(1/0); return &quot;success&quot;;&#125; 如果发生异常就会返回error.html，而不会返回success.html 点击链接 如图发生了除0异常","categories":[],"tags":[]},{"title":"springMVC-rest","slug":"springMVC-rest","date":"2022-06-24T12:14:45.000Z","updated":"2022-06-25T05:53:26.150Z","comments":true,"path":"2022/06/24/springMVC-rest/","link":"","permalink":"http://example.com/2022/06/24/springMVC-rest/","excerpt":"","text":"本Demo源码先把源码放这里后面再分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.rest.bean;public class Employee &#123; private Integer id; private String lastName; private String email; private Integer gender; public Employee() &#123; &#125; public Employee(Integer id, String lastName, String email, Integer gender) &#123; this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Integer getId() &#123; return id; &#125; public String getLastName() &#123; return lastName; &#125; public String getEmail() &#123; return email; &#125; public Integer getGender() &#123; return gender; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &quot;, lastName=&#x27;&quot; + lastName + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &quot;, gender=&quot; + gender + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.rest.dao;import com.atguigu.rest.bean.Employee;import org.springframework.stereotype.Repository;import java.util.Collection;import java.util.HashMap;import java.util.Map;@Repositorypublic class EmployeeDao &#123; private static Map&lt;Integer, Employee&gt; employees = null; static &#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001,new Employee(1001,&quot;E-AA&quot;,&quot;aa@163.com&quot;,1)); employees.put(1002,new Employee(1002,&quot;E-BB&quot;,&quot;bb@163.com&quot;,1)); employees.put(1003,new Employee(1003,&quot;E-CC&quot;,&quot;cc@163.com&quot;,0)); employees.put(1004,new Employee(1004,&quot;E-DD&quot;,&quot;dd@163.com&quot;,0)); employees.put(1005,new Employee(1005,&quot;E-EE&quot;,&quot;ee@163.com&quot;,1)); &#125; private static Integer initId = 1006; public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(initId++); &#125; employees.put(employee.getId(),employee); &#125; public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; public Employee get(Integer id)&#123; return employees.get(id); &#125; public void delete(Integer id)&#123; employees.remove(id); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu.rest.controller;import com.atguigu.rest.bean.Employee;import com.atguigu.rest.dao.EmployeeDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.Collection;@Controllerpublic class EmployeeController &#123; @Autowired private EmployeeDao employeeDao; @RequestMapping(value=&quot;/employee&quot;,method = RequestMethod.GET) public String getAllEmployee(Model model)&#123; Collection&lt;Employee&gt; employeeList = employeeDao.getAll(); model.addAttribute(&quot;employeeList&quot;,employeeList); return &quot;employee_list&quot;; &#125; @RequestMapping(value=&quot;/employee/&#123;id&#125;&quot;,method = RequestMethod.DELETE) public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); return &quot;redirect:/employee&quot;; &#125; @RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.POST) public String addEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;; &#125; @RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;,method = RequestMethod.GET) public String getEmployeeById(@PathVariable(&quot;id&quot;) Integer id,Model model)&#123; Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;,employee); return &quot;employee_update&quot;; &#125; @RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.PUT) public String updateEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Employee Info&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- border=1 取消间距--&gt; &lt;table id=&quot;dataTable&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; style=&quot;text-align: center&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;options（&lt;a th:href=&quot;@&#123;/toAdd&#125;&quot;&gt;add&lt;/a&gt;）&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;!-- &lt;a th:href=&quot;@&#123;/employee/&#125;+$&#123;employee.id&#125;&quot;&gt;delete&lt;/a&gt;--&gt; &lt;a @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27; + $&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;form id=&quot;deleteForm&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#dataTable&quot;, methods:&#123; deleteEmployee:function(event)&#123; //根据id获取表单元素 var deleteForm = document.getElementById(&quot;deleteForm&quot;); //将触发点击事件的超链接的href属性赋值给表单的action deleteForm.action = event.target.href; //提交表单 deleteForm.submit(); //取消超链接的默认行为 event.preventDefault(); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;add employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; lastname:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;add&quot;&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;update employee&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; lastname:&lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;br&gt;&lt;!-- th:field=&quot;$&#123;employee.gender&#125;&quot; 如果employee.gender的值等于value它就默认选中 checked --&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;update&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎来到首页&lt;/h1&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/employee&#125;&quot;&gt;查看员工信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 用springMVC实现网页数据的增、删、改、查1、查询数据这里所查询的数据是直接用一个静态代码块加Map模拟数据库数据 1234567891011private static Map&lt;Integer, Employee&gt; employees = null;static &#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001,new Employee(1001,&quot;E-AA&quot;,&quot;aa@163.com&quot;,1)); employees.put(1002,new Employee(1002,&quot;E-BB&quot;,&quot;bb@163.com&quot;,1)); employees.put(1003,new Employee(1003,&quot;E-CC&quot;,&quot;cc@163.com&quot;,0)); employees.put(1004,new Employee(1004,&quot;E-DD&quot;,&quot;dd@163.com&quot;,0)); employees.put(1005,new Employee(1005,&quot;E-EE&quot;,&quot;ee@163.com&quot;,1));&#125; 123456@RequestMapping(value=&quot;/employee&quot;,method = RequestMethod.GET)public String getAllEmployee(Model model)&#123; Collection&lt;Employee&gt; employeeList = employeeDao.getAll(); model.addAttribute(&quot;employeeList&quot;,employeeList); return &quot;employee_list&quot;;&#125; 上面这段代码表示当我们访问名称为&#x2F;employee的路径并且请求方式为get时，服务器就会调用EmployeeController控制器里的这个getAllEmployee函数，在这个函数里利用Model向请求域里添加数据，然后返回一个employee_list.html视图用来把数据展示在页面上。 123456789101112131415161718192021222324&lt;!-- border=1 取消间距--&gt; &lt;table id=&quot;dataTable&quot; border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; style=&quot;text-align: center&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;options（&lt;a th:href=&quot;@&#123;/toAdd&#125;&quot;&gt;add&lt;/a&gt;）&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;!-- &lt;a th:href=&quot;@&#123;/employee/&#125;+$&#123;employee.id&#125;&quot;&gt;delete&lt;/a&gt;--&gt; &lt;a @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27; + $&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 上面的代码就表示把request域里的数据经过循环获取打印在页面的table里 运行效果展示 2、修改数据在employee_list里有一句代码update 这句代码表示只要点击table中的update链接就会访问到下面这个函数 123456@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;,method = RequestMethod.GET)public String getEmployeeById(@PathVariable(&quot;id&quot;) Integer id,Model model)&#123; Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;,employee); return &quot;employee_update&quot;;&#125; 在这个函数里根据id查询到对应的employee的信息然后利用Model加入到request域中，最后返回视图employee_update.html展示要更新的数据 12345678910111213&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; lastname:&lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;br&gt;&lt;!-- th:field=&quot;$&#123;employee.gender&#125;&quot; 如果employee.gender的值等于value它就默认选中 checked --&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;update&quot;&gt;&lt;br&gt;&lt;/form&gt; 可以在上面的表单中修改数据然后提交，服务器会根据&#x2F;employee和请求方式put访问就访问到下面这个函数，将表单中提交的数据封装在对象employee里，然后保存在employeeDao里，最后重定向到函数getAllEmployee返回employee_list.html展示修改后的数据。 12345@RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.PUT)public String updateEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 注意上面表单提交的本来是post请求，但是被服务器根据隐藏域中的信息转换成了put请求 这里需要用到一个叫HiddenHttpMethodFilter的过滤器，需要在web.xml中配置如下 1234567891011 &lt;!-- 配置HiddenHttpMethodFilter作用是把form提交的post请求根据条件转换成 PUT或者delete请求--&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 值得注意的是name&#x3D;”_method”是固定写法，千万不能变。这是源码中固定死了的，源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class HiddenHttpMethodFilter extends OncePerRequestFilter &#123; private static final List&lt;String&gt; ALLOWED_METHODS; public static final String DEFAULT_METHOD_PARAM = &quot;_method&quot;; private String methodParam = &quot;_method&quot;; public HiddenHttpMethodFilter() &#123; &#125; public void setMethodParam(String methodParam) &#123; Assert.hasText(methodParam, &quot;&#x27;methodParam&#x27; must not be empty&quot;); this.methodParam = methodParam; &#125; protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; HttpServletRequest requestToUse = request; if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; request.getAttribute(&quot;javax.servlet.error.exception&quot;) == null) &#123; String paramValue = request.getParameter(this.methodParam); if (StringUtils.hasLength(paramValue)) &#123; String method = paramValue.toUpperCase(Locale.ENGLISH); if (ALLOWED_METHODS.contains(method)) &#123; requestToUse = new HiddenHttpMethodFilter.HttpMethodRequestWrapper(request, method); &#125; &#125; &#125; filterChain.doFilter((ServletRequest)requestToUse, response); &#125; static &#123; ALLOWED_METHODS = Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.PATCH.name())); &#125; private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper &#123; private final String method; public HttpMethodRequestWrapper(HttpServletRequest request, String method) &#123; super(request); this.method = method; &#125; public String getMethod() &#123; return this.method; &#125; &#125;&#125; 运行效果如下 点击1001后面的update，效果如下 修改图中信息为 点击提交 如上图我们已经成功的修改了1001的信息了(这里0表示male，1表示female) 3、添加数据在employee_list.html中有这么一条语句options（add） 这条语句表示点击add超链接服务器就会根据&#x2F;toAdd直接定位到springMVC.xml中的这条语句 1234&lt;!-- 根据/toAdd访问视图employee_add--&gt;&lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;employee_add&quot;&gt;&lt;/mvc:view-controller&gt; &lt;!-- 开启mvc注解驱动--&gt;&lt;mvc:annotation-driven/&gt; 然后找到视图employee_add.html，下面为这个视图里的form表单 12345678&lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; lastname:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;add&quot;&gt;&lt;br&gt;&lt;/form&gt; 在这个表单中输入数据提交，服务器会根据&#x2F;employee和post找到下面这个函数 12345@RequestMapping(value = &quot;/employee&quot;,method = RequestMethod.POST)public String addEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;;&#125; 然后重定向回employee_list.html。 运行效果如下 接着前面的图点击添加add，效果如下 输入信息 点击提交 4、删除数据这里的删除数据的方法有点复杂。需要用到vue框架 我们必须先vue.js导入环境 在employee_list.html中delete超链接须这样写 1&lt;a @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; 给这个超链接动作起名为deleteEmployee 12345678910111213141516171819202122&lt;form id=&quot;deleteForm&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#dataTable&quot;, methods:&#123; deleteEmployee:function(event)&#123; //根据id获取表单元素 var deleteForm = document.getElementById(&quot;deleteForm&quot;); //将触发点击事件的超链接的href属性赋值给表单的action deleteForm.action = event.target.href; //提交表单 deleteForm.submit(); //取消超链接的默认行为 event.preventDefault(); &#125; &#125; &#125;); &lt;/script&gt; 当我们点击链接时不会立马跳转而是由先执行标签里的语句，将超链接的属性赋给id为deleteForm的隐藏表单，让再提交表单。 这里之所以要弄那么负责是因为超链接默认是get请求，而get请求不能被HiddenHttpMethodFilter转换为delete请求，所有这里我们就必须利用vue框架和form表单来将超链接的get请求转化为form的post请求然后再由HiddenHttpMethodFilter转换为delete请求。最后根据路径与请求方式找到下面这个函数 12345@RequestMapping(value=&quot;/employee/&#123;id&#125;&quot;,method = RequestMethod.DELETE)public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); return &quot;redirect:/employee&quot;;&#125; 根据id将对应的数据删除，然后重定向回employee_list.html。 运行效果如下 点击图中1001对应的delete 可以看到1001对应的行已经被删除了","categories":[],"tags":[]},{"title":"springMVC-demo4","slug":"springMVC-demo4","date":"2022-06-24T11:18:37.000Z","updated":"2022-06-25T14:50:15.674Z","comments":true,"path":"2022/06/24/springMVC-demo4/","link":"","permalink":"http://example.com/2022/06/24/springMVC-demo4/","excerpt":"","text":"用spring实现文件的上传与下载1、文件上传123456&lt;!-- enctype=&quot;multipart/form-data&quot; 让表单里的数据以二进制方式传输 --&gt;&lt;form th:action=&quot;@&#123;/testUp&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;photo&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; 上面这个表单中 type&#x3D;”file”，就表示表单可以上传文件。 1234567891011121314151617181920212223242526272829303132// 文件上传 @RequestMapping(&quot;/testUp&quot;) public String testUP(MultipartFile photo,HttpSession session) throws IOException &#123;// 获取上传的变量名// System.out.println(photo.getName());// 获取上传文件的名字 System.out.println(photo.getOriginalFilename()); String fileName = photo.getOriginalFilename(); //获取上传文件的后缀名 String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); //将UUID作为文件名 String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;); //将UUID和后缀名拼接后的结果作为最终的文件名 fileName = uuid + suffixName; ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(&quot;photo&quot;); File file = new File(photoPath);// 判断photoPath所对应路径是否存在 if(!file.exists())&#123; //若不存在则创建目录 file.mkdir(); &#125; //File.separator 获取一个 “\\” String finalPath = photoPath + File.separator + fileName; System.out.println(&quot;File.separator:&quot;+File.separator); photo.transferTo(new File(finalPath)); System.out.println(finalPath); System.out.println(&quot;文件上传成功！&quot;); return &quot;success&quot;; &#125; 12&lt;!-- 配置文件上传解析器，将上传的文件封装为MultipartFile --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; 点击表单中的上传按钮，服务器就找到上面这个函数用MultipartFile 获取文件。然后获取到文件的全名，分离出文件的后缀，再利用UUID获取一个任意的文件名（原因是用UUID获得的文件名几乎不会出现重名得情况。如果出现重名，后面的文件会将前面的文件覆盖）。利用ServletContext 获得服务器的项目路径，再生成一个名为photo的文件夹用来存放上传的文件。最后将路径与UUID文件名拼接起来生成一个最终路径，用函数photo.transferTo(new File(finalPath));保存文件。 运行效果 上传前 点击选择文件 点击上传 上传成功 找的相应文件夹看效果 上面的文件名就是用UUID获取的。 2、文件下载1&lt;a th:href=&quot;@&#123;/testDown&#125;&quot;&gt;下载1.opg&lt;/a&gt;&lt;br&gt; 点击链接下载图片 1234567891011121314151617181920212223242526272829@RequestMapping(&quot;/testDown&quot;)@ResponseBodypublic ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws Exception &#123; //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/img/cover2.jpg&quot;); System.out.println(realPath); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()];//is.available() 获取当前的输入流所对应的文件的所有字节数 //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String,String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 //设置下载方式 attachment 表示以附件方式下载 headers.add(&quot;Content-Disposition&quot;,&quot;attachment;filename=cover2.jpg&quot;); //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes,headers,statusCode); //关闭输入流 is.close(); System.out.println(&quot;哈哈哈哈哈哈哈&quot;); return responseEntity;&#125; 这里就不描述了，注释已经讲的很清楚了。 运行效果 服务器文件夹对应的图片vover2.jpg 点击超链接下载图片 效果 浏览器已经下载了文件 用springMVC获取浏览器请求html中编写两个表单 123456789101112&lt;p&gt;测试获取请求体&lt;/p&gt;&lt;form th:action=&quot;@&#123;/testRequestBody&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;测试@RequestBody&quot;&gt;&lt;/form&gt;&lt;p&gt;测试获取整个请求&lt;/p&gt;&lt;form th:action=&quot;@&#123;testRequestEntity&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;测试@RequestEntity&quot;&gt;&lt;/form&gt; 在控制器中写相应的函数接收请求，然后在控制台输出。 12345678910111213@RequestMapping(&quot;/testRequestBody&quot;)public String testRequest(@RequestBody String requestBody)&#123; System.out.println(&quot;请求体：&quot; + requestBody); return &quot;success&quot;;&#125;@RequestMapping(&quot;/testRequestEntity&quot;)public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123; //当前requestEntity表示整个请求报文的信息 System.out.println(&quot;请求头：&quot; + requestEntity.getHeaders()); System.out.println(&quot;请求体：&quot; + requestEntity.getBody()); return &quot;success&quot;;&#125; 运行效果 获取请求体 输入数据提交 控制台输出 获取整个请求 输入数据提交 控制台输出 用springMVC响应浏览器数据html中编写代码如下 123&lt;a th:href=&quot;@&#123;testResponse&#125;&quot;&gt;测试通过servletAPI的response对象响应浏览器数据&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testResponseBody&#125;&quot;&gt;测试通过@ResponseBody对象响应浏览器数据&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testResponseUser&#125;&quot;&gt;测试通过@ResponseBody对象响应浏览器User对象&lt;/a&gt;&lt;br&gt; 控制器中的代码如下 1234567891011121314151617181920//原生servlet@RequestMapping(&quot;/testResponse&quot;)public void testResponse(HttpServletResponse response) throws IOException &#123; response.setContentType(&quot;text/html;charset=UTF-8&quot;); response.getWriter().println(&quot;你好 response&quot;);&#125;@RequestMapping(&quot;/testResponseBody&quot;)//@ResponseBody//表示控制器方法public String testResponse()&#123; return &quot;success&quot;;&#125;@RequestMapping(&quot;/testResponseUser&quot;)@ResponseBodypublic User testResponseUser()&#123; return new User(1001,&quot;admin&quot;,&quot;123456&quot;,&quot;23&quot;,&quot;男&quot;);&#125; User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.atguigu.mvc.controller.bean;public class User &#123; private Integer id; private String username; private String password; private String age; private String sex; public User() &#123; &#125; public User(Integer id, String username, String password, String age, String sex) &#123; this.id = id; this.username = username; this.password = password; this.age = age; this.sex = sex; &#125; public Integer getId() &#123; return id; &#125; public String getUsername() &#123; return username; &#125; public String getPassword() &#123; return password; &#125; public String getAge() &#123; return age; &#125; public String getSex() &#123; return sex; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAge(String age) &#123; this.age = age; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; 运行效果 点击第一个超链接 点击第二个链接 点击第三个链接 用springMVC处理ajaxajax是啥？ajax是一种用于创建快速动态网页的技术。 ajax通过在不刷新整个页面的情况下与服务器进行少量数据交换，使网页实现异步更新。传统的网页（不使用ajax）如果需要更新内容，必须要重载整个页面。 这次我们用axios来实现ajax的功能，因为axios里面封装了ajax。另外我们还用vue来结合ajax实现数据传输。需要以下两个依赖 html中编写代码如下 123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;a @click=&quot;testAxios&quot; th:href=&quot;@&#123;/testAxios&#125;&quot;&gt;测试SpringMVC处理ajax&lt;/a&gt;&lt;br&gt; &lt;a th:href=&quot;@&#123;/testAxios&#125;&quot;&gt;测试没有使用ajax的情况&lt;/a&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&quot;#app&quot;, methods:&#123; testAxios:function(event)&#123; axios(&#123; method:&quot;post&quot;, url:event.target.href, params:&#123; username:&quot;admin&quot;, password:&quot;123456&quot; &#125; &#125;).then(function(response)&#123; alert(response.data); &#125;); event.preventDefault(); &#125; &#125; &#125;); &lt;/script&gt; 控制器中编写代码如下 1234567@RequestMapping(&quot;/testAxios&quot;)@ResponseBodypublic String testAxios(String username,String password)&#123; System.out.println(&quot;----------------------------&quot;); System.out.println(username + &quot;,&quot; + password); return &quot;hello,axios&quot;;&#125; 运行效果 点击第一个的超链接，用了ajax的情况 浏览器显示，直接在没有刷新页面的情况下收到服务器发来的信息 控制台输出 点击第二个链接， 浏览器显示，进入了一个新的页面 控制台输出","categories":[],"tags":[]},{"title":"springMVC-demo3","slug":"springMVC-demo3","date":"2022-05-21T07:09:38.000Z","updated":"2022-05-21T09:12:39.401Z","comments":true,"path":"2022/05/21/springMVC-demo3/","link":"","permalink":"http://example.com/2022/05/21/springMVC-demo3/","excerpt":"","text":"springMVC的几种域共享数据方式配置文件前面的demo中已经写过了，这里就不再赘述了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import java.util.Map;@Controllerpublic class ScopeController &#123; //通过servletAPI向request域共享数据 @RequestMapping(&quot;/testRequestByServletAPI&quot;) public String testRequestByServletAPI(HttpServletRequest request)&#123; request.setAttribute(&quot;testRequestScope&quot;,&quot;hello,servletAPI&quot;); return &quot;success&quot;; &#125;//通过ModelAndView向request域对象共享数据 @RequestMapping(&quot;/testModelAndView&quot;) public ModelAndView testModelAndView()&#123; ModelAndView mav = new ModelAndView(); //处理模型数据，即向请求域request共享数据 mav.addObject(&quot;testRequestScope&quot;,&quot;hello,ModelAndView&quot;); //设置设计图名称 mav.setViewName(&quot;success&quot;); System.out.println(mav); return mav; &#125;// 使用MOdel向request域对象共享数据 @RequestMapping(&quot;/testModel&quot;) public String testModel(Model model)&#123; model.addAttribute(&quot;testRequestScope&quot;,&quot;hello MODEL&quot;); System.out.println(model); return &quot;success&quot;; &#125;// 使用map向request域对象共享数据 @RequestMapping(&quot;/testMap&quot;) public String testMap(Map&lt;String,Object&gt; map)&#123; map.put(&quot;testRequestScope&quot;,&quot;hello,MAP&quot;); System.out.println(map); return &quot;success&quot;; &#125;// 使用ModelMap向request域对象共享数据 @RequestMapping(&quot;/testModelMap&quot;) public String testModelMap(ModelMap modelMap)&#123; modelMap.addAttribute(&quot;testRequestScope&quot;,&quot;hello ModeMap&quot;); System.out.println(modelMap); return &quot;success&quot;; &#125;// 通过servletAPI向session中共享数据 @RequestMapping(&quot;/testSession&quot;) public String testSession(HttpSession session)&#123; session.setAttribute(&quot;testSessionScope&quot;,&quot;hello Session&quot;); return &quot;success&quot;; &#125;// 向application域共享数据 @RequestMapping(&quot;/testApplication&quot;) public String testApplication(HttpSession session)&#123; ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;,&quot;hello application&quot;); return &quot;success&quot;; &#125;&#125; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a th:href=&quot;@&#123;/testRequestByServletAPI&#125;&quot;&gt;通过servletAPI向与对象共享数据&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testModelAndView&#125;&quot;&gt;通过ModelAndView向request域对象共享数据&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testModel&#125;&quot;&gt;使用MOdel向request域对象共享数据&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testMap&#125;&quot;&gt; 使用map向request域对象共享数据&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testModelMap&#125;&quot;&gt; 使用ModelMap向request域对象共享数据&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testSession&#125;&quot;&gt;通过servletAPI向session中共享数据&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testApplication&#125;&quot;&gt;通过servletAPI向application域共享数据&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;test_rest&#125;&quot;&gt;go test_rest&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;SUCCESS!&lt;/h1&gt;&lt;br&gt;&lt;p th:text=&quot;$&#123;testRequestScope&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;session.testSessionScope&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;application.testApplicationScope&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1、request域共享数据 从上面的代码中我们可以看出在springMVC中一共有五种方法它们分别为 HttpServletRequest、ModelAndView、Model、Map&lt;&gt;、ModelMap。 2、session域共享数据和application域共享数据 session域共享数据可以直接用servletAPI的方式来实现。如果我们想实现application域共享数据，需要先获取session对象，然后用session得到application，具体方式为 ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;,&quot;hello application&quot;); 来运行一下上面的代码 我们点击第一个链接会跳转到success页面 会得到这样一个结果。 它内部得运行机制为：当我们点击链接时会发送一个http请求到前端控制器，然后经过一系列映射、对象生成，前端控制器会找到 testRequestByServletAPI 方法，然后我们在这个方法内获得了request请求，我们利用 request.setAttribute() 向 request 域中添加键值对数据，然后 return 后又经过前端控制器的一系列模块视图处理，我们就来到了success页面，在success页面中通过key取value。 request,session,application域的生命周期（1）request域的生命周期只限一次请求，当我进行第二次请求后，第一此的请求域就消失了 （2）session域的生命周期是一次会话，简单来说就是我们打开浏览器无论你做什么操作这个session始终存在，向里面添加数据，只要你不移除，在你关闭浏览器之前它会一直存在。但是当你关闭浏览器之后再打开上一个session域就已经消失了。 （3）application域的生命周期是只要开启服务器它就存在了，只要服务器不关闭它就一直存在。 用form表单以put的方式提交数据12345@RequestMapping(value=&quot;/user&quot;,method=RequestMethod.PUT)public String updateUser(String username,String password)&#123; System.out.println(&quot;修改用户信息：&quot;+username+&quot;,&quot;+password); return &quot;success&quot;;&#125; 1234567&lt;form th:action=&quot;@&#123;/user&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; 修改用户信息：&lt;br&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt;&lt;/form&gt; web.xml配置 1234567891011&lt;!-- 配置HiddenHttpMethodFilter作用是把form提交的post请求根据条件转换成 PUT或者delete请求--&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 以上面这种方式可以将我们的post请求方式在HiddenHttpMethodFilter 这个过滤器中转变为put请求方式。为什么要这样做呢，其实现在的大部分浏览器只能支持发送get和post请求方式，我们只能在服务器端改变或者利用vue改变请求方式。 上面这行代码尤为重要，type&#x3D;”hidden”表示我们在浏览器上面是看不到这个input的，这里name&#x3D;”_method”写法是固定的，这里一定要这样写我们的HiddenHttpMethodFilter才能把value对应的请求方式给到控制器。 内部执行过程：当我们的请求到达服务器会先进入HiddenHttpMethodFilter ，首先判断如果请求方式为post,且 name&#x3D;”_method”,就会把请求方式改变成put，然后找到相应的控制器方法。 视图的转发与重定向123456789101112131415161718192021222324252627282930package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ViewController &#123; @RequestMapping(&quot;/testThymeleafView&quot;) public String testThymeleafView()&#123; return &quot;success&quot;; &#125;// forward转发 @RequestMapping(&quot;/testForward&quot;) public String testForward()&#123; return &quot;forward:/testThymeleafView&quot;; &#125;// 重定向视图RedirectView// @RequestMapping(&quot;/testRedirect&quot;) public String Redirect()&#123; return &quot;redirect:/testThymeleafView&quot;; &#125;&#125; 1、当我们用forward转发视图时，我们的请求必须要通过testForward方法取访问success页面 访问前后浏览器显示的URL都为 http://localhost:8080/springMVC-demo3/testForward 我们从浏览器无法得知success的真实路径 2、当我们用redirect重定向视图时，我们可以直接以success的真实路径访问success 访问跳转前 URL: 跳转后URL: 通过mvc:view-controller配置直接访问视图123456&lt;!-- 视图控制器如果控制器中不需要处理的视图可以用它来直接访问，path:设置处理的地址view-name:设置请求地址所对应的视图名称--&gt; &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt; 此时我们可以直接在浏览器端以 http://localhost:8080/springMVC-demo3/ + path 来直接访问视图","categories":[],"tags":[]},{"title":"springMVC-demo2","slug":"springMVC-demo2","date":"2022-05-20T13:35:59.000Z","updated":"2022-05-20T16:56:55.887Z","comments":true,"path":"2022/05/20/springMVC-demo2/","link":"","permalink":"http://example.com/2022/05/20/springMVC-demo2/","excerpt":"","text":"例1 springMVC的一些基本知识1234567891011121314151617181920package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestController &#123; @RequestMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @RequestMapping(&quot;/param&quot;) public String testParam()&#123; return &quot;test_param&quot;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller// 如果加上下面这个 /hello 参数，那么请求路径里就必须包含 /hello//@RequestMapping(&quot;/hello&quot;)public class RequestMappingController &#123; @RequestMapping(value=&#123;&quot;/testRequestMapping&quot;,&quot;/test&quot;&#125;, // 请求方式必须为 gte，或者 post方式才能访问这个方法 method = &#123;RequestMethod.GET,RequestMethod.POST&#125;, //username表示我们当前的请求映射所能够匹配的请求必须携带username参数// !username表示当前所匹配的请求中一定不能有username这个参数// username=admin表示username的值必须为admin// username!=admin表示必须携带username但是username的值一定不能为admin params = &#123;&quot;username=admin&quot;&#125; ) public String success()&#123; return &quot;success&quot;; &#125; //get请求方式的注解 @GetMapping(&quot;/testGetMapping&quot;) public String testGetMapping()&#123; return &quot;success&quot;; &#125; @RequestMapping(value=&quot;/testPut&quot;,method= &#123;RequestMethod.PUT&#125;) public String testPut()&#123; return &quot;success&quot;; &#125; //headers和params要求差不多 //就是要要求请求的报文的报头要满足类似 Host=localhost:8081 的键值对的格式才能访问目标网页 @RequestMapping(value=&quot;/testParamsAndHeaders&quot;, params = &#123;&quot;username&quot;,&quot;password=123456&quot;&#125;, headers=&#123;&quot;Host=localhost:8081&quot;&#125;) public String testParamsAndHeaders()&#123; return &quot;success&quot;; &#125; //写 a?a 表示两个a之间可以加任意的一个字符 /和?除外 //写a*a 表示两个a之间可以加任意的0至多个字符 同样 /和?除外 //// @RequestMapping(&quot;/a?a/testAnt&quot;)// @RequestMapping(&quot;/a*a/testAnt&quot;)// @RequestMapping(&quot;/a**a/testAnt&quot;)// ** 表示任意的一层或者多层目录 就可以加任意的 / 了// 但是我加了 ? 它就返回上一个网页，不知道是为什么 @RequestMapping(&quot;/**/testAnt&quot;) public String testAnt()&#123; return &quot;success&quot;; &#125; //@RequestMapping(&quot;/testPath/&#123;id&#125;&quot;)中的id就是我们要传递的参数 @RequestMapping(&quot;/testPath/&#123;id&#125;/&#123;username&#125;&quot;) public String testPath(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String username)&#123;//加上@PathVariable(&quot;id&quot;)注解就可以将形参id赋值为传过来的参数 System.out.println(&quot;id::&quot;+id); System.out.println(&quot;username::&quot;+username); return &quot;success&quot;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;!--视图解析器的命名空间--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/hello/testRequestMapping&#125;&quot;&gt;测试RequestMapping注解的位置&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testRequestMapping&#125;&quot;&gt;测试/testRequestMapping&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试/test&lt;/a&gt;&lt;form th:action=&quot;@&#123;/test&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试RequestMapping注解的method属性---》post&quot;&gt;&lt;/form&gt;&lt;form th:action=&quot;@&#123;/testGetMapping&#125;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试testGetMapping注解&quot;&gt;&lt;/form&gt;&lt;form th:action=&quot;@&#123;/testPut&#125;&quot; method=&quot;put&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试form表单是否可以设置put请求方式&quot;&gt;&lt;/form&gt;&lt;a th:href=&quot;@&#123;/testParamsAndHeaders(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试Params属性&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/a1a/testAnt&#125;&quot;&gt;测试匹配Ant风格的路径？&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/a5678k/testAnt&#125;&quot;&gt;测试匹配Ant风格的路径*&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/a1a/testAnt&#125;&quot;&gt;测试匹配Ant风格的路径**&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testPath/1/werwsd&#125;&quot;&gt;测试RequestMapping可以支持路径中的占位符--》/testPath&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/param&#125;&quot;&gt;跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 1、访问第一个链接 出现404是因为我把类上面的 @RequestMapping(“&#x2F;hello”) 注释了找不到资源 2、访问第二个链接 由报错提示可知因为 username&#x3D;admin 这个条件不满足所以不能访问 3、访问第三个链接会出现和访问第二个链接同样的错误 4、点击图中第一个按钮以post方式发送请求，但是还是不满足 username&#x3D;admin 的条件无法访问 5、点击第二个按钮 成功访问success页面 对应代码 12345//get请求方式的注解@GetMapping(&quot;/testGetMapping&quot;)public String testGetMapping()&#123; return &quot;success&quot;;&#125; 123&lt;form th:action=&quot;@&#123;/testGetMapping&#125;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试testGetMapping注解&quot;&gt;&lt;/form&gt; 由此可知 @GetMapping() 这个注解可以接受 get 请求 6、点击第三个按钮 12345@RequestMapping(value=&quot;/testPut&quot;,method= &#123;RequestMethod.PUT&#125;)public String testPut()&#123; return &quot;success&quot;;&#125; 123&lt;form th:action=&quot;@&#123;/testPut&#125;&quot; method=&quot;put&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试form表单是否可以设置put请求方式&quot;&gt;&lt;/form&gt; 对应代码我们可以看到路径没错，对应方法也是一致的，但是就是访问不了，看错误提示 Request method ‘GET’ not supported 翻译过来就是 请求方法不被支持 ，其实原因就是再浏览器上面只有两种请求方,就是post和get请求，当我们用put方式请求时其实它默认为get方式，而我们控制器中没有对应的方法，所以它就表示 请求方法不被支持。 7、点击“ 测试Params属性” 链接 12345678//headers和params要求差不多//就是要要求请求的报文的报头要满足类似 Host=localhost:8080 的键值对的格式才能访问目标网页@RequestMapping(value=&quot;/testParamsAndHeaders&quot;, params = &#123;&quot;username&quot;,&quot;password=123456&quot;&#125;, headers=&#123;&quot;Host=localhost:8080&quot;&#125;)public String testParamsAndHeaders()&#123; return &quot;success&quot;;&#125; 1&lt;a th:href=&quot;@&#123;/testParamsAndHeaders(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试Params属性&lt;/a&gt;&lt;br&gt; 由此可知请求需要满足 含有 username,password属性 且 password&#x3D;123456,Host&#x3D;localhost:8080才能找到对应的方法进而访问成功 8、Ant风格的路径 1234567891011 //写 a?a 表示两个a之间可以加任意的一个字符 /和?除外 //写a*a 表示两个a之间可以加任意的0至多个字符 同样 /和?除外// @RequestMapping(&quot;/a?a/testAnt&quot;)// @RequestMapping(&quot;/a*a/testAnt&quot;)// @RequestMapping(&quot;/a**a/testAnt&quot;)// ** 表示任意的一层或者多层目录 就可以加任意的 / 了// 但是我加了 ? 它就返回上一个网页，不知道是为什么 @RequestMapping(&quot;/**/testAnt&quot;) public String testAnt()&#123; return &quot;success&quot;; &#125; 9、RequestMapping可以支持路径中的占位符 12345678//@RequestMapping(&quot;/testPath/&#123;id&#125;&quot;)中的id就是我们要传递的参数@RequestMapping(&quot;/testPath/&#123;id&#125;/&#123;username&#125;&quot;)public String testPath(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String username)&#123;//加上@PathVariable(&quot;id&quot;)注解就可以将形参id赋值为传过来的参数 System.out.println(&quot;id::&quot;+id); System.out.println(&quot;username::&quot;+username); return &quot;success&quot;;&#125; 1&lt;a th:href=&quot;@&#123;/testPath/1/werwsd&#125;&quot;&gt;测试RequestMapping可以支持路径中的占位符--》/testPath&lt;/a&gt;&lt;br&gt; 点击链接在服务器控制台得到以下输出 占位符 {} 位于两个 &#x2F; 之间，当我们在控制器的路径中加上占位符后，我们就可以用restFul风格传送数据，取数据的时候只需在控制器方法的形参位置加上 @PathVariable 注解就可以获取到值 例2 springMVC参数的获取1234567891011121314151617181920package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestController &#123; @RequestMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @RequestMapping(&quot;/param&quot;) public String testParam()&#123; return &quot;test_param&quot;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.atguigu.mvc.controller;import com.atguigu.mvc.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;@Controllerpublic class ParamController &#123; @RequestMapping(&quot;/testServletAPI&quot;) //形参位置的request表示当前的请求对象request public String testServletAPI(HttpServletRequest request)&#123; request.getSession(); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot; + username); System.out.println(&quot;password:&quot; + password); return &quot;success&quot;; &#125; /* @RequestParam @RequestHeader */ //若多个请求参数中出现多个同名的参数，可以在控制器方法的形参位置设置字符串类型或字符串数组来接收此请求参数 //若用字符串类型的形参，最终结果为请求参数的每一个值之间使用逗号进行拼接 //此外这里形参的参数名必须要跟请求对象里的相同 @RequestMapping(&quot;/testParam&quot;) //required = false 表示可以不传username 的值，为true就必须要传值，不传就报错.required默认为true //defaultValue = &quot;hehe&quot; 表示不传值是默认为hehe,不管required的值为true还是false,只要传过来的值为空字符串就使用defaultValue 所指定的默认值 public String testParam(@RequestParam(value = &quot;user_name&quot;,required = false,defaultValue = &quot;hehe&quot;) String username, String password , String hobby ,//String[] hobby 会获取到一个字符串数组 @RequestHeader(value = &quot;Hos&quot;,required = true,defaultValue = &quot;cfffs&quot;) String host, @CookieValue(&quot;JSESSIONID&quot;) String JSESSIONID)&#123; System.out.println(&quot;username:&quot; + username +&quot;\\npassword:&quot; + password+&quot;\\nhobby:&quot;+hobby); System.out.println(&quot;host:&quot; + host+&quot;\\nJSESSIONID&quot; + JSESSIONID); return &quot;success&quot;; &#125; @RequestMapping(&quot;/testBean&quot;) public String testBean(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试请求参数&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;测试请求参数&lt;/h1&gt;&lt;br&gt; &lt;a th:href=&quot;@&#123;/testServletAPI(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试使用ServletAPI来获取请求参数&lt;/a&gt; &lt;br&gt; &lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试使用控制器的形参来获取请求参数&lt;/a&gt; &lt;br&gt;&lt;form th:action=&quot;@&#123;/testParam&#125;&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user_name&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name = &quot;password&quot;&gt;&lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;a&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;b&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;c&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;d&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;测试使用控制器的形参获取请求参数&quot;&gt;&lt;/form&gt;&lt;hr&gt;&lt;form th:action=&quot;@&#123;/testBean&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;使用实体类接受请求参数&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.mvc.bean;import org.springframework.stereotype.Component;public class User &#123; private String username; private String password; private Integer age; private String sex; private String email; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot; username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 1、测试用原生的servletAPI来获取request请求参数 12345678910111213@RequestMapping(&quot;/testServletAPI&quot;)//形参位置的request表示当前的请求对象requestpublic String testServletAPI(HttpServletRequest request)&#123; request.getSession(); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot; + username); System.out.println(&quot;password:&quot; + password); return &quot;success&quot;;&#125; 1&lt;a th:href=&quot;@&#123;/testServletAPI(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试使用ServletAPI来获取请求参数&lt;/a&gt; &lt;br&gt; 服务器控制台输出结果 2、测试使用控制器的形参来获取请求参数 12345678910111213141516171819//若多个请求参数中出现多个同名的参数，可以在控制器方法的形参位置设置字符串类型或字符串数组来接收此请求参数 //若用字符串类型的形参，最终结果为请求参数的每一个值之间使用逗号进行拼接 //此外这里形参的参数名必须要跟请求对象里的相同 @RequestMapping(&quot;/testParam&quot;) //required = false 表示可以不传username 的值，为true就必须要传值，不传就报错.required默认为true //defaultValue = &quot;hehe&quot; 表示不传值是默认为hehe,不管required的值为true还是false,只要传过来的值为空字符串就使用defaultValue 所指定的默认值 public String testParam(@RequestParam(value = &quot;user_name&quot;,required = false,defaultValue = &quot;hehe&quot;) String username, String password , String hobby ,//String[] hobby 会获取到一个字符串数组 @RequestHeader(value = &quot;Host&quot;,required = true,defaultValue = &quot;cfffs&quot;) String host, @CookieValue(&quot;JSESSIONID&quot;) String JSESSIONID)&#123; System.out.println(&quot;username:&quot; + username +&quot;\\npassword:&quot; + password+&quot;\\nhobby:&quot;+hobby); System.out.println(&quot;host:&quot; + host+&quot;\\nJSESSIONID&quot; + JSESSIONID); return &quot;success&quot;; &#125; 1234567891011 &lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试使用控制器的形参来获取请求参数&lt;/a&gt; &lt;br&gt;&lt;form th:action=&quot;@&#123;/testParam&#125;&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user_name&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name = &quot;password&quot;&gt;&lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;a&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;b&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;c&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;d&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;测试使用控制器的形参获取请求参数&quot;&gt;&lt;/form&gt; 浏览器界面 （1） 当我们点击 “测试使用控制器的形参来获取请求参数 ”这个链接的时候服务器控制台就会输出 这里输出的host和Cookie对应请求头里的 host和Cookie ，我们可以在浏览器页面上右键点击 检查，点击 网络 查看host和Cookie和我们打印出来的一样 请求头里的数据都是以键值对的方式保存的，我们只需用相应的注解就可以获取到数据 （2）在浏览器端输入以下数据然后提交 服务器控制台输出 这里原理已经被我写在了注释里，就不多说了 （3）使用实体类接受请求参数 定义一个实体类User 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.mvc.bean;import org.springframework.stereotype.Component;public class User &#123; private String username; private String password; private Integer age; private String sex; private String email; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot; username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 1234567@RequestMapping(&quot;/testBean&quot;)public String testBean(User user)&#123; System.out.println(user); return &quot;success&quot;;&#125; 12345678&lt;form th:action=&quot;@&#123;/testBean&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;使用实体类接受请求参数&quot;&gt;&lt;br&gt;&lt;/form&gt; 在浏览器输入，点击提交 服务器控制台输出 这里简单的用一个对象来接收参数，需要要注意的是我们传输的参数名和对象里的属性名一定要一一对应 最后说一下，如果不做任何处理从浏览器发来的中文在服务器控制台输出一定会出现乱码。我这里之所以没有出现乱码是因为我在web.xml里加了一个过滤器，更改了编码方式。 1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","categories":[],"tags":[]},{"title":"springMVC简介","slug":"springMVC简介","date":"2022-05-20T12:13:57.000Z","updated":"2022-05-20T13:32:34.637Z","comments":true,"path":"2022/05/20/springMVC简介/","link":"","permalink":"http://example.com/2022/05/20/springMVC%E7%AE%80%E4%BB%8B/","excerpt":"","text":"springMVC是啥呢springMVC是spring的一个后续产品，是spring的一个子项目。 springMVC是spring为表述层开发提供的一整套完备的解决方案。在表述层框架经历Strust,webWork.Strust2等诸多产品的历代更迭之后，目前springMVC可以说是java EE项目表述层开发的最佳方案。springMVC中的MVC就可以很好的解释springMVC的功能，M表示model模块,V表示view视图,C表示controller控制器，这三个模块差不多就是springMVC的主要内容了。 springMVC原理原理图 springMVC工作流程概述 1、客户端向web服务器(如tomcat)发送一个http请求，web服务器对http请求进行解析，解析后的URL地址如果匹配了DispatcherServlet的映射路径(通过web.xml中的servlet-mapping配置),web容器就将请求交给DispatcherServlet处理。 2、DispatcherServlet接收到这个请求后，再对URL进行解析，得到请求资源标识符（URI）。然后调用相应方法得到的HandlerMapping对象，再根据URI，调用这个对象的相应方法获得Handler对象以及它对应的拦截器。（在这里只是获得了Handler对象，并不会操作它，在SpringMVC中，是通过HandlerAdapter对Handler进行调用、控制的） 3、DispatcherServlet根据得到的Handler对象，选择一个合适的HandlerAdapter，创建其实例对象，执行拦截器中的preHandler()方法。 4、在拦截器方法中，提取请求中的数据模型，填充Handler入参，所以所有准备工作都已做好，开始执行Handler（我们写的controller代码并不是能被直接执行，需要有刚才那些操作，才能转变为Handler被执行）。 5、Handler执行完毕后返回一个ModelAndView对象给DispatcherServlet。 6、这个ModleAndView只是一个逻辑视图，并不是真正的视图，DispatcherServlet通过ViewResolver视图解析器将逻辑视图转化为真正的视图（通俗理解为将视图名称补全，如加上路径前缀，加上.jsp后缀，能指向实际的视图）。 7、DispatcherServlet通过Model将ModelAndView中得到的处数据解析后用于渲染视图。将得到的最终视图通过http响应返回客户端。 (上面的图和流程是转载的，我感觉这个流程总结超级好) 第一个springMVC程序1、开发环境 IDE:idea 2021 构建工具：maven(超级推荐用maven构建项目，因为太好用了) 服务器：Tomcat(推荐用tomcat7以上的，有一些东西7不支持) Spring版本：5.3.18 2、构建maven工程 （1）用maven创建一个Web工程 （2）打包方式：war （3）引入依赖 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.mvc&lt;/groupId&gt; &lt;artifactId&gt;springMVC-demo1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;16&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;16&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;!-- spring依赖 --&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 日志 --&gt; &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt;&lt;!-- &lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt;&lt;!-- servlet依赖 --&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 视图解析器依赖 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.thymeleaf/thymeleaf-spring5 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 构建--&gt; &lt;build&gt; &lt;!-- 设置插件--&gt; &lt;plugins&gt; &lt;!-- 具体的插件配置--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置springMVC的前端控制器，对浏览器发送的请求进行统一的处理--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 配置SpringMVC配置文件的位置和名称--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 将前端控制器DispatcherServlet的初始化时间提前到服务器启动时--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- / 表示服务器默认访问路径为http://localhost:8080/springMVC-demo1 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; springMVC.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 扫描组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 配置Thymeleaf视图解析器--&gt; &lt;bean id=&quot;viewResoler&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;&lt;!-- 视图前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;&lt;!-- 视图后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 配置好了接下来我们进入主题部分 1、先创建一个index.html页面作为首页。 2、创建一个HelloController作为控制器来控制页面的跳转 3、再创建一个target.html 4、在index里写一个超链接实现点击跳转到target页面 index.html123456789101112&lt;!DOCTYPE html&gt;&lt;!-- xmlns:th=&quot;http://www.thyemleaf.org&quot; 实现这种风格的href th:href=&quot;@&#123;/target&#125;&quot; /target为目标路径 --&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你哈!&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/target&#125;&quot;&gt;访问目标页面target.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; HelloContriller1234567891011121314151617181920212223242526package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; // value = &quot;/&quot; 经过web.xml配置只要访问http://localhost:8080/springMVC-demo1 //前端控制器就自动找到这里这个index()方法 @RequestMapping(value = &quot;/&quot;) public String index()&#123; //返回视图名称，经过视图解析器，加上 前缀/WEB-INF/templates/ //加上后缀 .html就 得到 http://localhost:8080/springMVC-demo1/WEB-INF/templates/index.html //这样我们就可以访问到index.html文件了 return &quot;index&quot;; &#125; @RequestMapping(&quot;/target&quot;) public String toTarget()&#123; return &quot;target&quot;; &#125;&#125; target.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;HELLO WORLD&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 运行结果","categories":[],"tags":[]},{"title":"Spring-事务","slug":"Spring-事务","date":"2022-04-30T15:15:10.000Z","updated":"2022-04-30T15:51:52.239Z","comments":true,"path":"2022/04/30/Spring-事务/","link":"","permalink":"http://example.com/2022/04/30/Spring-%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务：其实就是Spring 用来解决在现实场景中会出现的一些逻辑错误例子：比如你去银行要转账给某人，在你刚刚进行完转账操作，数据库里把你账户上的钱扣除相应的部分，如果这时突然停电但是系统还在转账过程中，这就有可能造成你的钱是被扣除了，但是对方还未收到你的转账。一、propagation:事务传播行为也就是带有事务的方法调用不带事务的方法会默认使不带事务的方法带上事务 二、ioslation:事务隔离级别（1）事务有特性成为隔离性，多事务操作之间不会产生影响，不考虑隔离性会产生很多问题（2）有三个读问题：脏读、不可重复读、虚读（幻读）脏读：一个未提交事务读取到另一个未提交事务的数据不可重复读：一个未提交的事务读取到另一个提交事务修改数据虚读：一个未提交事务读取到另一个提交事务添加数据解决：通过设置事务隔离级别，解决读问题 REPEATABLE_READ:无脏读，无不可重复读READ_COMMITTED：只无脏读SERIALIZABLE：无脏读、无不可重复读、无虚读READ_UNCOMMITTED：啥都不能解决 三、timeout事务需要在一定时间内进行提交，如果不提交进行回滚默认值时-1，设置时间以秒为单位进行 四、readOnly:是否只读1、读：查询操作，写：添加修改删除操作2、readOnly默认值false,表示可以查询，可以进行添加修改删除操作3、设置readOnly 值为true，只能进行查询操作 五、rollbackFor:回滚设置出现哪些异常进行回滚 六、noRollbackFor:不回滚设置出现哪些异常不进行回滚 代码模拟银行转账问题1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;!-- 开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 数据库连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;ljc625995&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;/bean&gt;&lt;!-- jdbcTemplate 对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;!-- 注入dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 创建事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!-- 注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt; 1234567package com.atguigu.spring5.dao;public interface UserDao &#123; public void addMoney(); public void reduceMoney();&#125; 1234567891011121314151617181920212223242526272829303132package com.atguigu.spring5.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoImpl implements UserDao&#123; @Autowired private JdbcTemplate jdbcTemplate; //lucy转帐100给mary //加钱 @Override public void addMoney() &#123; String sql = &quot;update t_account set money = money + ? where username = ?&quot;; int money = 100; jdbcTemplate.update(sql,money,&quot;mary&quot;); System.out.println(&quot;mary加&quot;+money+&quot;元&quot;); &#125; //减钱 @Override public void reduceMoney() &#123; String sql = &quot;update t_account set money = money - ? where username = ?&quot;; int money = 100; jdbcTemplate.update(sql,money,&quot;lucy&quot;); System.out.println(&quot;lucy减&quot;+money+&quot;元&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.spring5.service;import com.atguigu.spring5.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;//如果@Transactional 里啥都不写就默认propagation = Propagation.REQUIRED 表示事务会在被调用方法和调用方法间传播//添加到类上面：表示类里面所有的方法都添加事务。添加到方法上面：表示仅仅此方法添加事务。mysql 默认REPEATABLE_READ 隔离级别@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ,timeout = -1)@Servicepublic class UserService &#123; //注入 @Autowired private UserDao userDao; //转账的方法 public void accountMoney()&#123; //lucy少100 userDao.reduceMoney(); //用除零错误模拟转账过程中断电或者出现异常 //int i = 10/0; //mary多100 userDao.addMoney(); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.atguigu.spring5.test;import com.atguigu.spring5.config.TxConfig;import com.atguigu.spring5.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.GenericApplicationContext;public class TestBook &#123; @Test public void testAccount()&#123; // PlatformTransactionManager ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); userService.accountMoney(); &#125; @Test public void testAccount1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); userService.accountMoney(); &#125;&#125; 正常情况 转账前数据库 执行结果 转账后数据库 异常情况 制造异常并运行 出现异常 出现这种请况按道理就是lucy少了100,但是mary没有收到钱 但是这里我们启用了事务当发生异常时就能对这件事情进行回滚，保住了lucy的100块钱 数据库不变","categories":[],"tags":[]},{"title":"Spring-JdbcTemplate","slug":"Spring-JdbcTemplate","date":"2022-04-30T14:22:20.000Z","updated":"2022-04-30T16:00:20.264Z","comments":true,"path":"2022/04/30/Spring-JdbcTemplate/","link":"","permalink":"http://example.com/2022/04/30/Spring-JdbcTemplate/","excerpt":"","text":"Spring框架把JDBC封装在JdbcTemplate 里大大简化了对数据库的操作 在Spring里数据库的连接池一般用的都是 阿里巴巴 的德鲁伊连接池，所有再做数据库的操作时一定要先引入德鲁伊的依赖以及所用数据库的依赖 下面展示用Spring 怎么对数据库进行操作 1、用xml配置好连接池以及Jdbctemplate，并把数据源注入Jdbctemplate 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 数据库连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///salesdb&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;ljc625995&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;/bean&gt;&lt;!-- jdbcTemplate 对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;!-- 注入dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2、创建一个Book类，设置好属性，对应数据库的列名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atguigu.spring5.entity;public class Book &#123; private String cno; private String cname; private String city; private String manager; private String tel; public void setCno(String cno) &#123; this.cno = cno; &#125; public void setCname(String cname) &#123; this.cname = cname; &#125; public void setCity(String city) &#123; this.city = city; &#125; public void setManager(String manager) &#123; this.manager = manager; &#125; public void setTel(String tel) &#123; this.tel = tel; &#125; public String getCno() &#123; return cno; &#125; public String getCname() &#123; return cname; &#125; public String getCity() &#123; return city; &#125; public String getManager() &#123; return manager; &#125; public String getTel() &#123; return tel; &#125; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;cno=&#x27;&quot; + cno + &#x27;\\&#x27;&#x27; + &quot;, cname=&#x27;&quot; + cname + &#x27;\\&#x27;&#x27; + &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; + &quot;, manager=&#x27;&quot; + manager + &#x27;\\&#x27;&#x27; + &quot;, tel=&#x27;&quot; + tel + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 3、创建接口BookDao定义方法 1234567891011121314151617181920212223242526package com.atguigu.spring5.dao;import com.atguigu.spring5.entity.Book;import java.util.List;public interface BookDao &#123; //添加的方法 void add(Book book); void updateCum(Book book); void deletes(Book book); int selectCount(Book book); Book findCoustomerInfo(String cname); List&lt;Book&gt; findAllCustomer(); void batchAddCust(List&lt;Object[]&gt; batchArgs); void batchUpdateCust(List&lt;Object[]&gt; batchArgs); void batchDeleteCust(List&lt;Object[]&gt; batchArgs);&#125; 4、创建接口实现类BookDaoImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.atguigu.spring5.dao;import com.atguigu.spring5.entity.Book;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic class BookDaoImpl implements BookDao&#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; //添加的方法 @Override public void add(Book book) &#123; //1 创建sql语句 //？号代表要填入的数据 String sql = &quot;insert into customer values(?,?,?,?,?)&quot;; //调用方法实现 //这里的这些book.get 方法就代表对上面的问号填入实际的数据 int update = jdbcTemplate.update(sql,book.getCno(),book.getCname(),book.getCity(), book.getManager(),book.getTel()); System.out.println(&quot;成功添加&quot;+update); &#125; @Override public void updateCum(Book book) &#123; String sql = &quot;update customer set cname=?,city=?,manager=? where cno=?&quot;; int update = jdbcTemplate.update(sql,book.getCname(),book.getCity(),book.getManager(),book.getCno()); System.out.println(&quot;成功修改&quot;+update); &#125; @Override public void deletes(Book book) &#123; String sql = &quot;delete from customer where cno=?&quot;; int update = jdbcTemplate.update(sql,book.getCno()); System.out.println(&quot;成功删除&quot;+update); &#125; @Override public int selectCount(Book book) &#123; String sql = &quot;select count(*) from customer&quot;; Integer count = jdbcTemplate.queryForObject(sql,Integer.class); return count; &#125; //查询返回对象 @Override public Book findCoustomerInfo(String cname) &#123; String sql = &quot;select * from customer where cname=?&quot;; //调用方法 Book book = jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class),cname); return book; &#125; @Override public List&lt;Book&gt; findAllCustomer() &#123; String sql = &quot;select * from customer&quot;; //调用方法 //new BeanPropertyRowMapper&lt;Book&gt;(Book.class) 方法用来临时存放从数据库里查出来的数据 List&lt;Book&gt; custList = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class)); //custLid里的就是所查询到的数据 return custList; &#125; @Override public void batchAddCust(List&lt;Object[]&gt; batchArgs) &#123; //其实这里就是把很多个字段的数据放到batchArgs数组中 String sql = &quot;insert into testCustomer values(?,?,?,?,?)&quot;; //在batchUpdate（）内部遍历batchArgs数组，每遍历一次就调用一次sql语句插入一个字段 jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;成功批量添加&quot;); &#125; @Override public void batchUpdateCust(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;update testCustomer set cname=?,city=?,manager=? where cno=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;成功修改&quot;+ints); &#125; @Override public void batchDeleteCust(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;delete from testCustomer where cno=?&quot;; jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;成功批量删除&quot;); &#125; &#125; 5、创建一个BookService类定义BookDao属性，定义方法调用相应的sql语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atguigu.spring5.service;import com.atguigu.spring5.dao.BookDao;import com.atguigu.spring5.entity.Book;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class BookService &#123; //注入Dao @Autowired private BookDao bookDao; //添加的方法 public void addCustomer(Book book)&#123; bookDao.add(book); &#125; //修改 public void updateCustomer(Book book)&#123; bookDao.updateCum(book); &#125; //删除 public void deleteCumtomer(Book book)&#123; bookDao.deletes(book); &#125; //查询表中的记录数 public int findCount(Book book)&#123; return bookDao.selectCount(book); &#125; //查询返回对象 public Book findOne(String cname)&#123; Book book = bookDao.findCoustomerInfo(cname); return book; &#125; public List&lt;Book&gt; findAll()&#123; return bookDao.findAllCustomer(); &#125; //批量添加 public void batchAdd(List&lt;Object[]&gt; batchArgs)&#123; bookDao.batchAddCust(batchArgs); &#125; //批量修改 public void batchUpdate(List&lt;Object[]&gt; batchArgs)&#123; bookDao.batchUpdateCust(batchArgs); &#125; //批量删除 public void batchDelete(List&lt;Object[]&gt; batchArgs)&#123; bookDao.batchDeleteCust(batchArgs); &#125;&#125; 6、创建TestBook测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.atguigu.spring5.test;import com.atguigu.spring5.entity.Book;import com.atguigu.spring5.service.BookService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.ArrayList;import java.util.List;public class TestBook &#123; @Test public void testJDBC()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class); Book book = new Book(); //添加数据// book.setCno(&quot;00009&quot;);// book.setCname(&quot;贵州公司&quot;);// book.setCity(&quot;威宁&quot;);// book.setManager(&quot;李锦超&quot;);// book.setTel(&quot;17580&quot;); // bookService.addCustomer(book); //修改数据// book.setCname(&quot;兴旺&quot;);// book.setCity(&quot;六盘水&quot;);// book.setManager(&quot;王小姐&quot;);// book.setCno(&quot;12345&quot;);// bookService.updateCustomer(book); //删除数据// book.setCno(&quot;00009&quot;);// bookService.deleteCumtomer(book); //查询字段数目// int count = bookService.findCount(book);// System.out.println(count); //查询返回对象// Book boo = bookService.findOne(&quot;兴旺&quot;);// System.out.println(boo); //查询返回集合// List&lt;Book&gt; all = bookService.findAll();////// for(Book bo : all)&#123;// System.out.println(bo);// &#125; //批量添加// List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();// Object[] o1 = &#123;&quot;10086&quot;,&quot;盛世公司&quot;,&quot;威宁&quot;,&quot;李显示&quot;,&quot;22343400&quot;&#125;;// Object[] o2 = &#123;&quot;10087&quot;,&quot;完美公司&quot;,&quot;威宁&quot;,&quot;李显&quot;,&quot;233234343400&quot;&#125;;// Object[] o3 = &#123;&quot;10088&quot;,&quot;刘芳公司&quot;,&quot;威宁&quot;,&quot;显示&quot;,&quot;229000003400&quot;&#125;;// batchArgs.add(o1);// batchArgs.add(o2);// batchArgs.add(o3);// bookService.batchAdd(batchArgs); //批量修改// List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();// Object[] o1 = &#123;&quot;c++公司&quot;,&quot;美国&quot;,&quot;mark&quot;,&quot;10086&quot;&#125;;// Object[] o2 = &#123;&quot;c语言公司&quot;,&quot;法国&quot;,&quot;lilii&quot;,&quot;10087&quot;&#125;;// Object[] o3 = &#123;&quot;java公司&quot;,&quot;中国&quot;,&quot;李先生&quot;,&quot;10088&quot;&#125;;// batchArgs.add(o1);// batchArgs.add(o2);// batchArgs.add(o3);// bookService.batchUpdate(batchArgs); //批量删除 List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); Object[] o1 = &#123;&quot;10086&quot;&#125;; Object[] o2 = &#123;&quot;10087&quot;&#125;; Object[] o3 = &#123;&quot;10088&quot;&#125;; batchArgs.add(o1); batchArgs.add(o2); batchArgs.add(o3); bookService.batchDelete(batchArgs); &#125;&#125; 数据库 这就是Spring操作数据库的大部分方法了","categories":[],"tags":[]},{"title":"Spring5-AOP","slug":"Spring5-AOP","date":"2022-04-30T13:06:58.000Z","updated":"2022-04-30T15:59:58.578Z","comments":true,"path":"2022/04/30/Spring5-AOP/","link":"","permalink":"http://example.com/2022/04/30/Spring5-AOP/","excerpt":"","text":"AOP原理 Spring的AOP实现原理其实很简单，就是通过动态代理实现的。如果我们为Spring的某个bean配置了切面，那么Spring在创建这个bean的时候，实际上创建的是这个bean的一个代理对象，我们后续对bean中方法的调用，实际上调用的是代理类重写的代理方法。而Spring的AOP使用了两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理。AOP其实就是面向切面编程。 那动态代理又是什么呢？我用一个通俗易懂的例子来描述一下 其实动态代理就像现实生活中那些房地产商人有房子，但是他不会直接向普通人出售，一般都是通过房产中介来帮他卖房子，而普通人想要买房子就必须通过房产中介这个Proxy来实现。而房产中介作为理工中间人他可以为我们办理一系列手续，提供咨询等等的事情，这就相当于把我们买房子这个动作增强了。这就是动态代理的大概含义。 JDK动态代理必须要有接口实现类，而这个类中的方法便可以通过JDK动态代理实现功能的增强。 CGLib动态代理是通过继承的方法实现的，有一个唯一的局限就是含有切点（要增强的方法）的类不能由finally修饰，因为有finally 修饰就不能进行类的继承了。 就效率而言CGLib动态代理比JDK动态代理要高很多，但奈何JDK动态代理是java源码，而CGLib是第三方库，在默认情况下都是使用JDK动态代理。 下面是JDK动态代理的具体实现方式1、先创建一个接口里面定义切点（要增强的方法） 1234567package com.atguigu.spring5;public interface UserDao &#123; public int add(int a,int b); public String update(String id);&#125; 2、创建一个接口实现类，实现接口中的方法 123456789101112131415package com.atguigu.spring5;public class UserDaoImpl implements UserDao&#123; @Override public int add(int a, int b) &#123; System.out.println(&quot;add方法执行了....&quot;); return a+b; &#125; @Override public String update(String id) &#123; System.out.println(&quot;update方法之执行了.....&quot;); return id; &#125;&#125; 3、创建一个JDKProxy.java ,包含JDKProx类和UserDaoProxy类 UserDaoProxy类用来实现 InvocationHandler 接口 重写它的 public Object invoke(Object proxy, Method method, Object[] args) 方法，我们想要增强的方法就可以在invoke里实现增强 公共类JDKProx 调用 Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 方法生成代理对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.spring5;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class JDKProxy &#123; public static void main(String[] args)&#123; //创建接口实现类代理对象 Class[] interfaces = &#123;UserDao.class&#125;; //匿名内部类// Proxy.newProxyInstance(JDKProxy.class.getClassLoader(),interfaces,new InvocationHandler()&#123;//// @Override// public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// return null;// &#125;// &#125;); UserDaoImpl userDao = new UserDaoImpl(); //先在下面创建了一个类来继承 Invocationhandler 接口就不用写匿名内部类了 UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(),interfaces, new UserDaoProxy(userDao)); int result = dao.add(1,2); System.out.println(&quot;result:&quot;+result); String id = dao.update(&quot;20117899&quot;); System.out.println(&quot;学号为：&quot;+id); &#125;&#125;//创建代理对象代码class UserDaoProxy implements InvocationHandler &#123;/* 1 创建的是谁的代理对象把谁传进来 */ //有参数构造传递 private Object obj; public UserDaoProxy(Object obj)&#123; this.obj = obj; &#125; //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //方法之前 System.out.println(&quot;方法之前执行...&quot; +method.getName()+&quot;:传递的参数...&quot;+ Arrays.toString(args)); //被增强的方法执行 Object res = method.invoke(obj,args); System.out.println(&quot;res:&quot;+res); //方法之后 System.out.println(&quot;方法之后执行...&quot;+obj); return res; &#125;&#125; 利用Spring框架来实现动态代理1、XML加注解混用实现1234567891011package com.atguigu.spring5.aopanno;import org.springframework.stereotype.Component;//被增强的类@Componentpublic class User &#123; public void add()&#123; System.out.println(&quot;add.....&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.spring5.aopanno;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;//增强的类@Component@Aspect//加上这个注解就使这个类成为代理类@Order(6)//数值越小优先级越高public class UserProxy &#123; //相同的切入点进行抽取,这样就可以用 //pointdemo()来代替execution(* com.atguigu.spring5.aopanno.User.add())了 //当我们需要改切入点的时候只需改一处就可以了 @Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void pointdemo()&#123; &#125; //前置通知 //@Before注解表示作为前置通知 @Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void before()&#123; System.out.println(&quot;before....&quot;); &#125; //最终通知，就算有异常它也执行 @After(value = &quot;pointdemo()&quot;) public void after()&#123; System.out.println(&quot;after.....&quot;); &#125; //后置通知（返回通知）在返回结果后执行 @AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void afterReturning()&#123; System.out.println(&quot;afterReturning....&quot;); &#125; //异常通知，只有发生异常才会执行 @AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void afterThrowing()&#123; System.out.println(&quot;afterThrowing&quot;); &#125; //环绕通知，在方法执行之前和之后都执行 @Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕之前....&quot;); //被增强的方法 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后....&quot;); &#125; &#125; 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring5.aopanno&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 开启Aspect生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 2、用完全注解方式实现只需把上面的xml配置文件换成配置类就好了 1234567891011121314package com.atguigu.spring5.Config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@ComponentScan(basePackages = &#123;&quot;com.atguigu.spring5&quot;&#125;)//开启注解扫描@Configuration//把这个类作为配置类//proxyTargetClass = false 默认为false 表示JDK代理，true为cglib代理@EnableAspectJAutoProxy(proxyTargetClass = false)//这个注解开启Aspect生成代理对象public class SpringConfig &#123;&#125; 啊这，也太方便了吧 3、只用xml实现123456789package com.atguigu.spring5.aopxml;//被代理类public class Book &#123; //切点 public void buy()&#123; System.out.println(&quot;buy....&quot;); &#125;&#125; 1234567891011121314package com.atguigu.spring5.aopxml;import org.aspectj.lang.annotation.Before;//代理类public class BookProxy &#123; //作为前置通知 public void before()&#123; System.out.println(&quot;before....&quot;); &#125; //作为后置通知 public void after()&#123; System.out.println(&quot;after....&quot;); &#125;&#125; 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 创建对象--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.aopxml.Book&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bookProxy&quot; class=&quot;com.atguigu.spring5.aopxml.BookProxy&quot;&gt;&lt;/bean&gt;&lt;!-- 配置aop增强--&gt; &lt;aop:config&gt;&lt;!-- 切入点--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.atguigu.spring5.aopxml.Book.buy())&quot;/&gt;","categories":[],"tags":[]},{"title":"Spring5-IOC","slug":"Spring5-IOC","date":"2022-04-30T01:04:29.000Z","updated":"2022-04-30T03:22:34.245Z","comments":true,"path":"2022/04/30/Spring5-IOC/","link":"","permalink":"http://example.com/2022/04/30/Spring5-IOC/","excerpt":"","text":"​ 花了两个星期的课余时间终于把Spring的大致内容学完了，今天先整理一些干货传上来。 IOC原理IOC（控制反转）就是依赖倒置原则的一种代码设计思路。 就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。 Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。 上面是比较官方的说法，据我理解其实 IOC 的意思是 “控制反转 ” 就是让Spring 帮我们管理对象，让对象在生存在框架上。平时我们不用框架去写代码的时候写出来的代码对象之间的耦合性很高，这样就造成了代码的可维护性极低，当我们需要更改某处的代码时就会造成连锁反应，一处改处处改。用了Spring之后Spring就会把对象都分开，减小耦合度，当我们需要修改代码的时候只需改改配置文件就OK了，也不需要担心每个对象之间复杂的关系。 其实Spring底层就是靠反射机制来完成的。 下面这张图就能很好的体现IOC机制 IOC的一些操作细节XML配置方式1.对象生成先把类写好，然和在xml中配置对象 1&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring5.User&quot;&gt;&lt;/bean&gt; id 相当于是给对象起个别名，com.atguigu.spring5.User 是类的全类名 用上述方法我们就可以实现一个对象的创建 2.XML实现属性注入属性注入有两中方式 1、用set方法进行属性注入 先生成每个属性的set方法，然后再在xml文件里进行配置 1234567891011121314151617181920212223242526package com.atguigu.spring5;/** * 演示实用set方法进行注入属性 */public class Book &#123; private String bname; private String bauthor; private String address; public void setBname(String bname) &#123; this.bname = bname; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public void setBauthor( String bauthor) &#123; this.bauthor = bauthor; &#125; public void testDemo()&#123; System.out.println(bname+&quot;----&gt;&quot;+bauthor+&quot;---&gt;&quot;+address); &#125;&#125; 123456789101112 &lt;!--2 set方法注入属性 --&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot;&gt; 实用property完成属性注入 &lt;property name=&quot;bname&quot; value=&quot;李锦超&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;达摩老祖祖&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;中国古代&quot;&gt;&lt;/property&gt; &lt;!-- 属性值包含特殊符号--&gt;&lt;!-- &lt;property name=&quot;address&quot; &gt;--&gt;&lt;!-- &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;--&gt;&lt;!-- &lt;/property&gt;--&gt; &lt;/bean&gt; 测试代码写法 123456789101112131415161718192021package com.atguigu.spring5.testdemo;import com.atguigu.spring5.config.SpringConfig;import com.atguigu.spring5.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring5Demo1 &#123; @Test public void testService()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125;&#125; 2、用构造器进行属性注入 一定要写构造方法，然后才能在xml中配置注入属性 1234&lt;bean id=&quot;orders&quot; class=&quot;com.atguigu.spring5.Orders&quot;&gt; &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 3、引入名称空间，简化属性注入 123&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p = &quot;http://www.springframework.org/schema/p&quot; 最下面的一行就是我引入的名称空间 p,我是这样写的：先复制第一行 xmlns&#x3D;”http://www.springframework.org/schema/beans&quot; 然后改成 第三行 xmlns:p &#x3D; “http://www.springframework.org/schema/p&quot; 这个样子就算引入名称空间 p 了，这个写法是固定的就只能这样写。 再进行属性注入，就可以这样写了 12&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot; p:bname=&quot;九阳神功&quot; p:bauthor=&quot;无名氏&quot;&gt;&lt;/bean&gt; 4.对象注入 对象作为属性注入有两种方式，内部bean和外部bean。 外部bean 写法 优势：可以给多个对象共享 先建两个类，其中一个类是接口实现类 123456789101112package com.atguigu.spring5.service;import com.atguigu.spring5.dao.UserDao;public class UserService &#123; //创建UserDao类型属性，生成set方法 private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 123456789package com.atguigu.spring5.dao;public class UserDaoImpl implements UserDao&#123; @Override public void update() &#123; System.out.println(&quot;dao update......&quot;); &#125;&#125; 用xml进行对象注入 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--service和dao对象创建 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring5.service.UserService&quot;&gt;&lt;!-- 注入userDao对象 name属性值，类里面属性名称 ref属性：创建userDao对象bean标签id值--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring5.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 内部bean写法 123456789101112&lt;!-- 内部bean--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;&lt;!-- 设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;李锦超&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;!-- 设置对象类型的属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 5.级联赋值 采用外部bean方式实现 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt; &lt;!-- 设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;王某&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- 级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;&lt;!-- &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 6.集合类型属性注入 这里面包含了含有对象的集合，由于时间原因我就直接贴代码了 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.spring5.collectiontype;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Stu &#123; //数组类型属性 private String[] courses; private List&lt;String&gt; list; private Map&lt;String,String&gt; maps; private Set&lt;String&gt; sets; //学生所学多门课程 private List&lt;Course&gt; courseList; public void setCourseList(List&lt;Course&gt; courseList) &#123; this.courseList = courseList; &#125; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125; public void setSets(Set&lt;String&gt; sets) &#123; this.sets = sets; &#125; public void test()&#123; System.out.println(Arrays.toString(courses)); System.out.println(list); System.out.println(maps); System.out.println(sets); System.out.println(courseList); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 1 集合类型属性注入--&gt; &lt;bean id=&quot;stu&quot; class=&quot;com.atguigu.spring5.collectiontype.Stu&quot;&gt;&lt;!-- 数组类型属性注入--&gt; &lt;property name=&quot;courses&quot;&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;value&gt;计算机网络&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!-- list类型属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;value&gt;三儿&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;!-- 注入list集合类型，值是对象--&gt; &lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- 创建多个course对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;MyBatis框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 8.利用名称空间实现公共集合属性 12345678910111213141516package com.atguigu.spring5.collectiontype;import java.util.List;public class Book &#123; private List&lt;String&gt; list; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void test()&#123; System.out.println(list); &#125;&#125; 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;&lt;!-- 1.提取list集合属性的注入--&gt; &lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;易筋经&lt;/value&gt; &lt;value&gt;九阴真经&lt;/value&gt; &lt;value&gt;九阳神功&lt;/value&gt; &lt;/util:list&gt;&lt;!-- 2、提取list集合属性的注入使用--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.collectiontype.Book&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 注意这里的名称空间还要在xsi:schemaLocation的双引号里额外的加上 http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd 9.bean的生命周期 大致可以分为五部分,细分的话有八部分 10.自动装配 有两种自动装配 根据属性名称 byName 根据属性类型 byType 这里我演示的是 byName 123456789101112131415161718192021package com.atguigu.spring5.autowire;public class Emp &#123; private Dept dept; public void setDept(Dept dept) &#123; this.dept = dept; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;dept=&quot; + dept + &#x27;&#125;&#x27;; &#125; public void test()&#123; System.out.println(dept); &#125;&#125; 1234package com.atguigu.spring5.autowire;public class Dept &#123;&#125; 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 实现自动装配 bean标签属性autowire,配置自动装配 autowire属性常用两个值：byName根据属性名称注入， 注入bean的id值要和属性名称一样 byType根据属性类型注入--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byName&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; XML加注解创建对象很多注解的意思我已经写成注释了，那就直接看代码 12345package com.atguigu.spring5.dao;public interface UserDao &#123; public void add();&#125; 12345678910111213package com.atguigu.spring5.dao;import org.springframework.stereotype.Repository;@Repository(value = &quot;userDaoImpl&quot;)public class UserDaoImpl implements UserDao&#123; @Override public void add() &#123; System.out.println(&quot;Dao add....&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.spring5.service;import com.atguigu.spring5.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import org.springframework.stereotype.Controller;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;//在注解里面value属性值可以不写//默认值是类名，首字母小写//UserService ---&gt; userService//@Service @Controller @Repository @Component//以上四个注解都可以用来创建对象，只不过用在不同的地方会更容易让人知道目前属于那一层@Component//相当于 &lt;bean id = &quot;userService&quot; class=&quot;.../&quot;/&gt;public class UserService &#123; //定义dao类型的属性 //不需要加set方法 //添加注入属性注解 @Autowired//只要这个注解的时候根据类型进行注入 @Qualifier(value = &quot;userDaoImpl&quot;)//加上这个就可以根据名称（指类的 id 值）进行注入 private UserDao userDao; @Value(value = &quot;李锦超&quot;) private String name; public void add()&#123; System.out.println(&quot;Service add....&quot;); userDao.add(); System.out.println(name); &#125;&#125; 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 开启组件扫描 1 如果扫描多个包，多个包用逗号隔开 2 或者扫描包上层目录 组件扫描的意思就是检查哪些类上面有 @Service @Controller @Repository @Component 这四个注解的其中之一就生成相应的对象，不再用bean标签去生成对象--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 示例1 use-default-filters=&quot;false&quot; 表示现在不使用默认filter context:include-filter 设置扫描哪些内容--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt;&lt;!-- 示例2 下面设置默认扫描所有内容 但是当我们加上 context:exclude-filter 就设置了哪些内容不进行扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; &gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 下面是测试代码的写法 1234567891011121314151617181920212223package com.atguigu.spring5.testdemo;import com.atguigu.spring5.config.SpringConfig;import com.atguigu.spring5.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring5Demo1 &#123; @Test public void testService2()&#123; //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125;&#125; 完全注解写法就是把上面的xml文件换成配置类就好了 下面是配置类 12345678910package com.atguigu.spring5.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration //作为配置类，替代xml配置文件@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)//开启组件扫描public class SpringConfig &#123;&#125; 好了，至此Spring的IOC就告一段落，以后有时间我会把底层原理了解一遍再发上来","categories":[],"tags":[]},{"title":"链表相加","slug":"链表相加","date":"2022-04-22T04:34:00.000Z","updated":"2022-04-22T05:09:17.526Z","comments":true,"path":"2022/04/22/链表相加/","link":"","permalink":"http://example.com/2022/04/22/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"今天牛客这题感觉很有意思，我硬是改了好几次才通过，他那个测试数据是真的长啊。 题目 思路1、先分别遍历两个链表，同时利用头插法逆转两个链表2、通过一我们成功的把链表的尾变成了头，这时我们就可以再一个循环里同时遍历两个链表，把他们对应的节点值相加。3、我们要注意两值相加进位的临界值是 9 ，因此我们必须考虑(sum + rem1)&#x3D;9、(sum + rem1)&lt;9、(sum + rem1)&gt;9这三种情况(sum表示两数相加的和，rem1表示进位数)这样做可以得到时间复杂度为O(n),空间复杂度为O(n). 上码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public static ListNode addInList (ListNode head1, ListNode head2) &#123; // write code here ListNode h1 = head1,h2 = head2; ListNode p1=null,p2=null; ListNode p3 = null,pSum = null; int k1=0,k2=0; while(h1!=null) &#123; ListNode temp = h1.next; h1.next = p1; p1 = h1; h1 = temp; k1++; &#125; while(h2!=null) &#123; ListNode temp = h2.next; h2.next = p2; p2 = h2; h2 = temp; k2++; &#125; int min = k1; if(k1&gt;k2) &#123; ListNode temp = p1; p1 = p2; p2 = temp; min = k2; &#125;; //sum为对应的两个数相加的和，rem和rem1用来存放进位数 int sum=0,rem=0,rem1=0; for(int i=0;p2!=null;i++,p2=p2.next) &#123; if(p1!=null&amp;&amp;p2!=null) &#123; sum = p1.val+p2.val; if((sum+rem1)&gt;9) &#123; sum = sum + rem1 - 10; rem = 1; &#125;else&#123; if((sum+rem1)==9)&#123; sum = sum + rem1; &#125;else&#123; if((sum+rem1)&lt;9)&#123; sum = sum + rem1; &#125;else&#123; if(sum&gt;9&amp;&amp;(rem1!=1)) &#123; sum = sum - 10; rem = 1; &#125; &#125; &#125; &#125; pSum = new ListNode(sum); pSum.next = p3; p3 = pSum; rem1 = rem; rem = 0; p1=p1.next; &#125; if(i&gt;=min) &#123; sum = p2.val; if((rem1+sum)&gt;9) &#123; sum = sum + rem1 - 10; rem = 1; &#125;else&#123; if((sum+rem1)==9)&#123; sum = sum + rem1; &#125;else&#123; if((sum+rem1)&lt;9)&#123; sum = sum + rem1; &#125; &#125; &#125; pSum = new ListNode(sum); pSum.next = p3; p3 = pSum; rem1 = rem; rem = 0; &#125; //System.out.println(i); &#125; if(rem1==1) &#123; pSum = new ListNode(1); pSum.next = p3; p3 = pSum; &#125; //output(p3); return p3; &#125; 结果","categories":[],"tags":[]},{"title":"牛客第三题","slug":"牛客第三题","date":"2022-04-16T15:20:18.000Z","updated":"2022-04-16T15:39:24.383Z","comments":true,"path":"2022/04/16/牛客第三题/","link":"","permalink":"http://example.com/2022/04/16/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%89%E9%A2%98/","excerpt":"","text":"今天又在牛客刷了一题，就单纯的想记录一下。 题目描述将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。 数据范围： 2000 0≤n≤2000 ， 20001≤k≤2000 ，链表中每个元素都满足 10000≤val≤1000要求空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)例如：给定的链表是 1→2→3→4→5对于 k &#x3D; 2k&#x3D;2 , 你应该返回 2→1→4→3→5对于 k &#x3D; 3k&#x3D;3 , 你应该返回 3→2→1→4→5 上码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static ListNode reverseKGroup (ListNode head, int k) &#123; /* * 我的大体思路就是每遍历k个节点就顺便放到栈里面，在栈里面把k个节点反转， * 然后再与后面的节点连起来 */ // write code here //如果链表为空或者k=1,就直接返回链表 if(head == null||k==1) &#123; return head; &#125; ListNode pre = head; ListNode temp=head,temp1= new ListNode(0); ListNode h =temp1,temp2=new ListNode(0); //用数组建一个栈，用来存k个节点 ListNode[] keyNode = new ListNode[k]; int keyCount = 0; int c=0; for(int i = 0;pre!=null;i++,keyCount++,c=i) &#123; if(i%k==0&amp;&amp;i!=0) &#123; temp2.next = keyNode[keyCount-1]; temp = keyNode[keyCount-1].next; for(int j = keyCount-1;j&gt;=0;j--) &#123; temp1.next = keyNode[j]; temp1 = keyNode[j]; &#125; temp2 = keyNode[0]; pre = temp; keyCount = 0; keyNode[keyCount] = pre; pre = pre.next; continue; &#125; //System.out.println(i); keyNode[keyCount] = pre; pre = pre.next; &#125; if(c&lt;k) &#123; return head; &#125; ListNode pp=null; if(c==k) &#123; for(int i = keyCount-1;i&gt;=0;i--) &#123; ListNode t = head.next; head.next = pp; pp = head; head = t; &#125; //output(pp); return pp; &#125; if(keyCount==k) &#123; for(int i = keyCount-1;i&gt;=0;i--) &#123;temp2.next = keyNode[i];temp2 = keyNode[i]; &#125; temp2.next=null; &#125;else &#123; for(int i = 0;i&lt;keyCount;i++) &#123; temp2.next = keyNode[i]; temp2 = keyNode[i]; &#125; &#125; //output(h); return h.next;&#125; 运行结果 这让我很意外","categories":[],"tags":[]},{"title":"AnswerPage","slug":"AnswerPage","date":"2022-04-15T01:13:10.000Z","updated":"2022-04-15T01:35:41.715Z","comments":true,"path":"2022/04/15/AnswerPage/","link":"","permalink":"http://example.com/2022/04/15/AnswerPage/","excerpt":"","text":"这两天小春同学向我求助帮他做一个答题网页。虽然感觉自己有很多事情都还没有做完，但是好哥们儿我肯定要帮啊。于是我就利用了三天的零碎时间做了这个网页，其实做完这个网页对我自己的收获也蛮大的。 AnswerPage需求：1、做一个由很多正方形组成的边框2、正方形边框里要有一个党徽在不断的移动3、让题目动态的显示，做完一题就可以进入下一题4、最后计算总分，用时其他的我就不多做赘述了，很多细节我已经写成注释混合在代码里了 上码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #content&#123;margin:20px auto 0px;&#125; .d2&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:40px;&#125; #contentbuttom&#123;margin:20px auto 0px;&#125; .d3&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:620px;&#125; #contentleft&#123;margin:20px auto 0px;&#125; .d4&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:130px;&#125; #contentright&#123;margin:20px auto 0px;&#125; .d5&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:1450px; top:130px;&#125; .move &#123; width: 80px; height: 80px; left:10px; top:40px; background-color: yellow; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var onOff = true; //获取body里面的div，返回值是数组 var d2 = document.getElementById(&#x27;content&#x27;).getElementsByTagName(&#x27;div&#x27;); var d3 = document.getElementById(&#x27;contentbuttom&#x27;).getElementsByTagName(&#x27;div&#x27;); var d4 = document.getElementById(&#x27;contentleft&#x27;).getElementsByTagName(&#x27;div&#x27;); var d5 = document.getElementById(&#x27;contentright&#x27;).getElementsByTagName(&#x27;div&#x27;); var d6 = document.getElementById(&#x27;mo&#x27;).getElementsByTagName(&#x27;div&#x27;); //生成最上面的墙(在id为content的div中生成17个div作为墙) function aa()&#123; document.getElementById(&#x27;content&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;17; i++)&#123; document.getElementById(&#x27;content&#x27;).innerHTML += &#x27;&lt;div class=&quot;d2&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d2[i].style.left = 10+(i*90)+&#x27;px&#x27;;//计算每个div间的距离 &#125; onOff = true; &#125; &#125; aa(); //生成最下面的墙(在id为contentbuttom的div中生成17个div作为墙) function bb()&#123; document.getElementById(&#x27;contentbuttom&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;17; i++)&#123; document.getElementById(&#x27;contentbuttom&#x27;).innerHTML += &#x27;&lt;div class=&quot;d3&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d3[i].style.left = 10+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; bb(); //生成左边的墙(在id为contentleft的div中生成5个div作为墙) function cc()&#123; document.getElementById(&#x27;contentleft&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;5; i++)&#123; document.getElementById(&#x27;contentleft&#x27;).innerHTML += &#x27;&lt;div class=&quot;d4&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d4[i].style.top = 150+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; cc(); //生成右边的墙(在id为contentright的div中生成5个div作为墙) function dd()&#123; document.getElementById(&#x27;contentright&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;5; i++)&#123; document.getElementById(&#x27;contentright&#x27;).innerHTML += &#x27;&lt;div class=&quot;d5&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d5[i].style.top = 150+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; dd(); //生成党徽(在id为mo的div中生成一个放党徽的div) function ee()&#123; document.getElementById(&#x27;mo&#x27;).innerHTML = &#x27;&#x27;; document.getElementById(&#x27;mo&#x27;).innerHTML += &#x27;&lt;div id=&quot;mm&quot; class=&quot;move&quot;&gt;&#x27;+&#x27;&lt;img src=&quot;https://tse2-mm.cn.bing.net/th/id/OIP-C.w7iifmShxQ8WNVHgRsnTRgHaHE?w=213&amp;h=204&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.25&amp;pid=1.7&quot; width=&quot;80&quot; height=&quot;80&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; &#125; ee(); //以下代码为控制党徽不断的在墙面上移动 m = document.getElementById(&#x27;mm&#x27;);//获取党徽所在的div的id var num1 = 10,num2=150,num3=600,num4=620;//这里初始化党徽运动到每一面墙的初始值 var x = 0,y=0;//这里用来定位党徽的位置 var flagx1 = true,flagx2=false,flagy1 = false,flagy2=false;//辅助变量 setInterval(function ()&#123; //在最上面的墙上运动 if((x&gt;=0&amp;&amp;x&lt;17)&amp;&amp;y==0)&#123; num2=150; flagx1=true; flagx2=false; flagy2=false; flagy1=false; m.style.top = 40 +&quot;px&quot;; m.style.left = num1 + &#x27;px&#x27;; num1 = num1 +90; &#125; //在右边的墙上运动 if(x==17&amp;&amp;(y&gt;=0&amp;&amp;y&lt;5))&#123; num4=num1-90; flagy1=true; flagx1=false; flagx2=false; flagy2=false; m.style.top = num2 +&#x27;px&#x27;; num2 = num2 + 90; &#125; //在最下面的墙上运动 if((x&lt;=17&amp;&amp;x&gt;0)&amp;&amp;y==5)&#123; num3=num2-90; flagx1=false; flagx2=true; flagy2=false; flagy1=false; m.style.top = 620 +&#x27;px&#x27;; m.style.left = num4 +&#x27;px&#x27;; num4 = num4 -90; &#125; //在最左边的墙上运动 if(x==0&amp;&amp;(y&lt;=5&amp;&amp;y&gt;0))&#123; num1 = 10 flagx1=false; flagx2=false; flagy2=true; flagy1=false; m.style.top = num3 +&#x27;px&#x27;; num3 = num3 -90; &#125; if(flagx1==true)&#123; x++; &#125; if(flagx2==true)&#123; x--; &#125; if(flagy1==true)&#123; y++ &#125; if(flagy2==true)&#123; y--; &#125; &#125;,300) var num = 10; /* setInterval(function()&#123; m.style.left = num +&#x27;px&#x27;; num = num +90; &#125;,500)*/ &#125; function $(id)&#123;//拿到html页里相应的id对象（这里的$相当于函数名,固定用法） return document.getElementById(id); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body background=&quot;https://tse1-mm.cn.bing.net/th/id/OIP-C.-Q5IrwV8dZ3PxjXIXW_ypwHaE8?pid=ImgDet&amp;rs=1&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var problems = new Array(9);//这个数组用来存放题目 problems[0] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[1] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[2] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; problems[3] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[4] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[5] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; problems[6] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[7] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[8] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; var arr = problems; var score_sum=0;//计分 // arr.push(problem1); //arr.push(problem2); //arr.push(problem3); for(let i=0;i&lt;3;i++)&#123; &#125; var k =0; var flag=false; //这些变量用来存放开始时间 var start_h=0 var start_m=0 var start_s=0 //这个函数用来控制下一题 function fun()&#123; judge(k,arr);//每点一次下一题按钮判断一次选项的值 k++; if(k==arr.length)&#123;//如果题目全部做完就把form删了，显示得分、用时 // alert(&quot;答题完毕！ &quot;+&quot;总得分：&quot;+score_sum); del(); var endtime = new Date(); var end_h = endtime.getHours(); var end_m = endtime.getMinutes(); var end_s = endtime.getSeconds(); var total_m=0; var total_s=0; //alert(&quot;结束时间：&quot;+end_m+&quot;分 &quot;+end_s+&quot;秒&quot;); //得到正确的时间 if(end_h!=start_h)&#123; total_m = (60-start_h)+end_m; if(end_m!=start_m)&#123; total_s = (60-start_s)+end_s; &#125;else&#123; total_s = end_s - start_s; &#125; &#125;else&#123; total_m = end_m - start_m; if(end_m!=start_m)&#123; total_s = (60-start_s)+end_s; &#125;else&#123; total_s = end_s - start_s; &#125; &#125; if(total_m&gt;0)&#123; total_m = total_m - 1; &#125; //alert(&quot;用时&quot;+total_m+&quot;分&quot;+total_s+&quot;秒&quot;); $(&#x27;replace&#x27;).innerHTML += &#x27;&lt;div style=&quot;margin-left: 150px;margin-top:150px; font-size:50px;color: rgb(23, 18, 168);&quot;&gt;&#x27;+&quot;总得分：&quot;+score_sum+ &quot;分 用时&quot;+total_m+ &quot;分钟&quot; +total_s+&#x27;秒&lt;/div&gt;&#x27;; &#125; //以下控制题目变化 document.getElementById(&#x27;a1&#x27;).innerHTML=arr[k].titile; document.getElementById(&#x27;a2&#x27;).innerHTML=arr[k].choice1; document.getElementById(&#x27;a3&#x27;).innerHTML=arr[k].choice2; document.getElementById(&#x27;a4&#x27;).innerHTML=arr[k].choice3; document.getElementById(&#x27;a5&#x27;).innerHTML=arr[k].choice4; //k++; &#125; function del()&#123;//删除form var elem = document.getElementById(&quot;myform&quot;); elem.parentNode.removeChild(elem); &#125; function judge(k,arr)&#123;//判断选项 var obj = document.getElementsByName(&#x27;ch&#x27;); var len = obj.length; //alert(k+&quot; &quot;+arr[k].answer); // alert(len) for(let j=0;true;j++)&#123; if(obj[j].checked==true)&#123; if(obj[j].value==arr[k].answer)&#123; score_sum = score_sum + 5; &#125; //alert(&quot;已选择&quot;+obj[j].value+&quot; 目前得分&quot;+score_sum); break; &#125; &#125; &#125; function au()&#123;//显示第一题 document.getElementById(&#x27;a1&#x27;).innerHTML=arr[0].titile; document.getElementById(&#x27;a2&#x27;).innerHTML=arr[0].choice1; document.getElementById(&#x27;a3&#x27;).innerHTML=arr[0].choice2; document.getElementById(&#x27;a4&#x27;).innerHTML=arr[0].choice3; document.getElementById(&#x27;a5&#x27;).innerHTML=arr[0].choice4; var starttime = new Date(); //获取开始时间 start_h = starttime.getHours(); start_m = starttime.getMinutes(); start_s = starttime.getSeconds(); //alert(&quot;开始时间：&quot;+start_m+&quot;分 &quot;+start_s+&quot;秒&quot;); //judge(0,arr); &#125; setTimeout(&quot;au()&quot;,1);//刚打开页面就显示第一个题目&lt;/script&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentbuttom&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentleft&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentright&quot;&gt;&lt;/div&gt;&lt;div id=&quot;mo&quot;&gt;&lt;/div&gt;&lt;div id=&quot;replace&quot;&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 500px;margin-top:300px; font-size:50px; color: rgb(134, 134, 137); position: absolute;&quot;&gt;我们一起来做题&lt;/div&gt;&lt;form style=&quot;margin-left: 200px;margin-top:200px;color: rgb(23, 18, 168);font-size: 20px;font-weight: bold;&quot; name=&quot;myform&quot; id=&quot;myform&quot;&gt;题目：&lt;label &gt;&lt;p id=&quot;a1&quot;&gt;&lt;/p&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;A&quot;&gt;A、&lt;label id=&quot;a2&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;B&quot;&gt;B、&lt;label id=&quot;a3&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;C&quot;&gt;C、&lt;label id=&quot;a4&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;D&quot;&gt;D、&lt;label id=&quot;a5&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; onclick=&quot;fun()&quot; name=&quot;next&quot; value=&quot;下一题&quot; style=&quot;font-size: 20px;color: blue;&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"反转链表","slug":"反转链表","date":"2022-04-10T01:24:55.000Z","updated":"2022-04-10T14:11:27.338Z","comments":true,"path":"2022/04/10/反转链表/","link":"","permalink":"http://example.com/2022/04/10/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"今天心血来潮想刷点题，于是就注册了牛客。没想到第一个题就是反转链表，啊这不是so easy吗。我火急火燎的就写完提交，没想到运行时间116ms,占用内存高达12948KB。代码我是用java写的，我看一些大神用Rust,C写竟然只花了2ms,300多KB,简直太牛了。后来我去看了一些题解把代码改进了一下，不用再去new空间，直接将原结点的指针反过来就ok了。 上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package p1;import java.util.Scanner;public class reverseLink &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ListNode h = create_list(); //output(h); ReverseList(h); &#125; public static ListNode create_list() &#123; Scanner input = new Scanner(System.in); int x=input.nextInt(); ListNode p=null,p1=null; ListNode h=new ListNode(input.nextInt()); p1=h; for(int i=0;i&lt;x-1;i++) &#123; p = new ListNode(input.nextInt()); p1.next = p; p1=p; p.next = null; &#125; return h; &#125; public static void output(ListNode h) &#123; while(h!=null) &#123; System.out.println(h.val); h=h.next; &#125; &#125; public static ListNode ReverseList(ListNode head) &#123; ListNode p=null,temp=null; //最巧的就是这个循环了 while(head!=null) &#123; //先让temp指向head.next节点,用来遍历链表 temp = head.next; //head.next指针指向p head.next = p; //让p指向head这个节点，这样下次循环的节点就可以和现在的节点连起来了 p = head; //这里再把刚刚temp保存的地址赋给head，继续遍历下一个节点 head = temp; &#125; while(p!=null) &#123; System.out.println(p.val); p=p.next; &#125; return new ListNode(1); &#125;&#125;class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 运行结果","categories":[],"tags":[]},{"title":"java编译器","slug":"java编译器","date":"2022-04-02T17:24:55.000Z","updated":"2022-04-02T17:53:14.675Z","comments":true,"path":"2022/04/03/java编译器/","link":"","permalink":"http://example.com/2022/04/03/java%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"java编译器今天偶然在网上看到一个java项目，就是用Java写一个Java编译器，只要会Javase就可以做。主要用到java里的几个包比如swing、io等。啊这不就很适合我做吗，于是我就跟着教程手敲了这个程序。由于时间问题，我就不写思路了，还有源代码我没有写注释，等有时间再来写吧。 FileWindow.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.Lijinchao.myedit;import java.awt.CardLayout;、import java.awt.Color;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.BufferedInputStream;import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JTextArea;import javax.swing.JTextField;public class FileWindow extends JFrame implements ActionListener,Runnable &#123; Thread compiler = null; Thread run_prom = null; boolean bn = true; CardLayout mycard; File file_saved = null; JButton button_input_txt, button_compiler_text, button_compiler, button_run_prom, button_see_doswin; JPanel p = new JPanel(); JTextArea input_text = new JTextArea(); JTextArea compiler_text = new JTextArea(); JTextArea dos_out_text = new JTextArea(); JTextField input_file_name_text = new JTextField(); JTextField run_file_name_text = new JTextField(); public FileWindow() &#123; super(&quot;JavaCompiler&quot;); mycard = new CardLayout(); compiler = new Thread(this); run_prom = new Thread(this); button_input_txt = new JButton(&quot;程序输入区(white)&quot;); button_compiler_text = new JButton(&quot;编译结果区(pink)&quot;); button_see_doswin = new JButton(&quot;程序执行结果(wathet)&quot;); button_compiler = new JButton(&quot;Compiler&quot;); button_run_prom = new JButton(&quot;Running&quot;); p.setLayout(mycard); p.add(&quot;input&quot;,input_text); p.add(&quot;compiler&quot;,compiler_text); p.add(&quot;dos&quot;,dos_out_text); add(p,&quot;Center&quot;); compiler_text.setBackground(Color.pink); dos_out_text.setBackground(Color.cyan); JPanel p1 = new JPanel(); p1.setLayout(new GridLayout(3,3)); p1.add(button_input_txt); p1.add(button_compiler_text); p1.add(button_see_doswin); p1.add(new JLabel(&quot;输入程序名称(.java)&quot;)); p1.add(input_file_name_text); p1.add(button_compiler); p1.add(new JLabel(&quot;输入程序主类名&quot;)); p1.add(run_file_name_text); p1.add(button_run_prom); add(p1,&quot;North&quot;); button_input_txt.addActionListener(this); button_compiler.addActionListener(this); button_compiler_text.addActionListener(this); button_run_prom.addActionListener(this); button_see_doswin.addActionListener(this); &#125; public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==button_input_txt) &#123; mycard.show(p,&quot;input&quot;); &#125;else if(e.getSource()==button_compiler_text) &#123; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_see_doswin) &#123; mycard.show(p, &quot;dos&quot;); &#125;else if(e.getSource()==button_compiler) &#123; if(!(compiler.isAlive())) &#123; compiler = new Thread(this); &#125; try &#123; compiler.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_run_prom) &#123; if(!(run_prom.isAlive())) &#123; run_prom = new Thread(this); &#125; try &#123; run_prom.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;dos&quot;); &#125; &#125; public void run() &#123; if(Thread.currentThread()==compiler) &#123; compiler_text.setText(null); String temp = input_text.getText().trim(); byte [] buffer = temp.getBytes(); int b = buffer.length; String file_name = null; file_name = input_file_name_text.getText().trim(); try &#123; file_saved = new File(file_name); FileOutputStream writefile = null; writefile = new FileOutputStream(file_saved); writefile.write(buffer, 0, b); writefile.close(); &#125;catch (Exception e) &#123; System.out.println(&quot;ERROR&quot;); &#125; try &#123; Runtime rt = Runtime.getRuntime(); InputStream in = rt.exec(&quot;javac &quot;+file_name).getErrorStream(); BufferedInputStream bufIn = new BufferedInputStream(in); byte[] shuzu = new byte[100]; int n=0; boolean flag = true; while((n=bufIn.read(shuzu,0,shuzu.length))!=-1) &#123; String s = null; s = new String(shuzu,0,n); compiler_text.append(s); if(s!=null) &#123; flag = false; &#125; &#125; if(flag) &#123; compiler_text.append(&quot;Compiler Succeed!&quot;); &#125; &#125; catch (Exception e) &#123; &#125; &#125; else if(Thread.currentThread()==run_prom) &#123; dos_out_text.setText(null); try &#123; Runtime rt = Runtime.getRuntime(); String path = run_file_name_text.getText().trim(); Process stream = rt.exec(&quot;java &quot;+path); InputStream in = stream.getInputStream(); BufferedInputStream bisErr = new BufferedInputStream(stream.getErrorStream()); BufferedInputStream bisIn = new BufferedInputStream(in); byte[] buf = new byte[150]; byte[] err_buf = new byte[150]; int m=0; int i=0; String s = null; String err = null; while((m = bisIn.read(buf, 0, 150))!=-1) &#123; s = new String(buf,0,150); dos_out_text.append(s); &#125; while((i = bisErr.read(err_buf))!=-1) &#123; &#123; err = new String(err_buf,0,150); dos_out_text.append(err); &#125; &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; Main.java12345678910111213141516171819202122package com.Lijinchao.myedit;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub FileWindow win = new FileWindow(); win.pack(); win.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); win.setBounds(200,180,550,360); win.setVisible(true); &#125;&#125; 运行结果点Running出现这样的画面就说明没问题了 正确运行需要在程序输入区输入代码，记住程序名称一定要.java作为后缀,并且程序名称一定要和主类名同名，主类名没有后缀。 1.先在程序输入区写好代码 2.点击Compiler编译 3.点击Running运行","categories":[],"tags":[]},{"title":"利用python爬取网页表情包","slug":"python爬虫","date":"2022-03-26T07:11:26.000Z","updated":"2022-04-15T01:39:34.806Z","comments":true,"path":"2022/03/26/python爬虫/","link":"","permalink":"http://example.com/2022/03/26/python%E7%88%AC%E8%99%AB/","excerpt":"","text":"今天刷着刷着视频，突然刷到一个关于python爬虫的视频，瞬间激起了我对爬虫的好奇心。刚好我以前学过一点python的知识，这会儿终于派上用场了。于是我上网借鉴了一些资料写了这个爬虫代码 requests,re知识想要写爬虫代码我们需要先了解这两个包。requests是一个很实用的python HTTP客户端库，编写爬虫这个包必不可少。这是我们常用的方法：requests.get()：获取HTML网页的主要方法，对应于HTTP的GET。re模块创建一个“规则表达式”，用于验证和查找符合规则的文本，广泛用于各种搜索引擎，账号密码的验证等。这是我们常用的两个方法：findall：扫描整个目标文本，返回所有与规则匹配的子串组成的列表，如果没有匹配的返回空列表。split：从与规则匹配的子串进行切割，返回切割后子串组成的列表。 爬虫编写步骤找表情包网站https://www.biaoqingba.net/hot.html 这个网址就是我爬表情包的网站，每个网站都有自己的HTML网页，所以我们需要简单的分析一下网页的HTML代码，便于写正则表达式，这里我就不多说了，直接看图。 获取URL，并且发起请求首先，我们想要下载表情包，就需要先获取网页的url，get方法里的网址就是url，可以上百度找到一个网页，然后复制链接就好。requests.get()就发起了一个请求。 1response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;) 利用正则表达式筛选数据在img标签中提取我们想要的内容，比如表情包的url,名字等 123re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text) 保存数据这里我们写一个download方法来保存数据。 12345678910111213# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix) 这里是源代码123456789101112131415161718192021222324252627282930313233343536373839import reimport osimport requests# https://www.biaoqingba.net/hot.html，这是我爬表情包的网页# 创建一个文件用来放表情包，images为文件名images = &#x27;images&#x27;# 如果文件不存在，就新建一个if not os.path.exists(images): os.mkdir(images)# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix)response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;)# print(response.text) 打印所请求网页的内容，其实就是网页的实现代码# 这行代码用了正则表达式来提取img标签的内容，src的引号内就是表情包链接，(.*?)表示# 只要是引号内的内容都要re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text)# print(result)# 循环获取result数组内的每个元素，调用download函数下载表情包for img in result: print(img) download(img[1], img[0]) # img[1]为name,img[0]为url 运行结果爬了满满一文件夹的表情包，真爽！","categories":[],"tags":[]},{"title":"Socket","slug":"page","date":"2022-03-21T01:34:55.000Z","updated":"2022-04-02T16:53:05.986Z","comments":true,"path":"2022/03/21/page/","link":"","permalink":"http://example.com/2022/03/21/page/","excerpt":"","text":"什么是Socket呢？Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。简言之，我们的QQ或者微信发送消息和接受消息的功能，底层就是用Socket实现的。废话不多说，直接上代码。 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package SeverAndClient;/** * @author 超 * 这里是服务器，开启两个线程，一个是接收消息的，一个是发送消息的 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class sever extends Thread&#123; ServerSocket server = null;//先定义一个服务Socket Socket socket = null; public sever(int port) &#123;//直接利用构造方法传入端口号 try &#123; server = new ServerSocket(port);//实例化ServerSocket &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run()&#123; super.run(); try&#123; System.out.println(&quot;wait client connect...&quot;); socket = server.accept();//等待客户端连接 new sendMessThread().start();//连接并返回socket后，再启用发送消息线程 System.out.println(socket.getInetAddress().getHostAddress()+&quot;SUCCESS TO CONNECT...&quot;); InputStream in = socket.getInputStream();//利用IO流获取信息 int len = 0; byte[] buf = new byte[1024];//这个用来缓冲数据 while ((len=in.read(buf))!=-1)&#123; System.out.println(&quot;client saying: &quot;+new String(buf,0,len)); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //这个就是发送消息的线程 class sendMessThread extends Thread&#123; @Override public void run()&#123; super.run(); Scanner scanner=null; OutputStream out = null; try&#123; if(socket != null)&#123; scanner = new Scanner(System.in); out = socket.getOutputStream(); String in = &quot;&quot;; do &#123; in = scanner.next();//输入数据 out.write((&quot;server saying: &quot;+in).getBytes()); out.flush();//清空缓存区的内容 &#125;while (!in.equals(&quot;q&quot;)); scanner.close(); try&#123; out.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; sever server = new sever(1234); server.start();//启动线程 &#125;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package SeverAndClient;/** * @author 超 * 这里是客户端 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;public class client extends Thread &#123; //定义一个Socket对象 Socket socket = null; public client(String host, int port) &#123; try &#123; //需要服务器的IP地址和端口号，才能获得正确的Socket对象 socket = new Socket(host, port);//host为服务器的ip地址，port为服务器的端口号 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; //客户端一连接就可以写数据个服务器了 new sendMessThread().start(); super.run(); try &#123; // 读Sock里面的数据 InputStream s = socket.getInputStream(); byte[] buf = new byte[1024];//缓冲数据 int len = 0; while ((len = s.read(buf)) != -1) &#123; System.out.println(new String(buf, 0, len)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //往Socket里面写数据，需要新开一个线程 class sendMessThread extends Thread&#123; @Override public void run() &#123; super.run(); //写操作 Scanner scanner=null; OutputStream os= null; try &#123; scanner=new Scanner(System.in); os= socket.getOutputStream(); String in=&quot;&quot;; do &#123; in=scanner.next();//输入数据 os.write((&quot;&quot;+in).getBytes()); os.flush(); &#125; while (!in.equals(&quot;bye&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; scanner.close(); try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; //需要服务器的正确的IP地址和端口号 client clientTest=new client(&quot;127.0.0.1&quot;, 8000);//127.0.0.1为测试专用ip,如果你想连另一台主机，就把ip换了 clientTest.start();//启动线程 &#125;&#125; 运行结果记住！一定要先运行服务器。","categories":[],"tags":[]}],"categories":[],"tags":[]}