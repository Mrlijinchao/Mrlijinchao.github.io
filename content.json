{"meta":{"title":"Mr.li的小站","subtitle":"","description":"","author":"Mr.li","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"springMVC-demo2","slug":"springMVC-demo2","date":"2022-05-20T13:35:59.000Z","updated":"2022-05-20T16:56:55.887Z","comments":true,"path":"2022/05/20/springMVC-demo2/","link":"","permalink":"http://example.com/2022/05/20/springMVC-demo2/","excerpt":"","text":"例1 springMVC的一些基本知识1234567891011121314151617181920package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestController &#123; @RequestMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @RequestMapping(&quot;/param&quot;) public String testParam()&#123; return &quot;test_param&quot;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller// 如果加上下面这个 /hello 参数，那么请求路径里就必须包含 /hello//@RequestMapping(&quot;/hello&quot;)public class RequestMappingController &#123; @RequestMapping(value=&#123;&quot;/testRequestMapping&quot;,&quot;/test&quot;&#125;, // 请求方式必须为 gte，或者 post方式才能访问这个方法 method = &#123;RequestMethod.GET,RequestMethod.POST&#125;, //username表示我们当前的请求映射所能够匹配的请求必须携带username参数// !username表示当前所匹配的请求中一定不能有username这个参数// username=admin表示username的值必须为admin// username!=admin表示必须携带username但是username的值一定不能为admin params = &#123;&quot;username=admin&quot;&#125; ) public String success()&#123; return &quot;success&quot;; &#125; //get请求方式的注解 @GetMapping(&quot;/testGetMapping&quot;) public String testGetMapping()&#123; return &quot;success&quot;; &#125; @RequestMapping(value=&quot;/testPut&quot;,method= &#123;RequestMethod.PUT&#125;) public String testPut()&#123; return &quot;success&quot;; &#125; //headers和params要求差不多 //就是要要求请求的报文的报头要满足类似 Host=localhost:8081 的键值对的格式才能访问目标网页 @RequestMapping(value=&quot;/testParamsAndHeaders&quot;, params = &#123;&quot;username&quot;,&quot;password=123456&quot;&#125;, headers=&#123;&quot;Host=localhost:8081&quot;&#125;) public String testParamsAndHeaders()&#123; return &quot;success&quot;; &#125; //写 a?a 表示两个a之间可以加任意的一个字符 /和?除外 //写a*a 表示两个a之间可以加任意的0至多个字符 同样 /和?除外 //// @RequestMapping(&quot;/a?a/testAnt&quot;)// @RequestMapping(&quot;/a*a/testAnt&quot;)// @RequestMapping(&quot;/a**a/testAnt&quot;)// ** 表示任意的一层或者多层目录 就可以加任意的 / 了// 但是我加了 ? 它就返回上一个网页，不知道是为什么 @RequestMapping(&quot;/**/testAnt&quot;) public String testAnt()&#123; return &quot;success&quot;; &#125; //@RequestMapping(&quot;/testPath/&#123;id&#125;&quot;)中的id就是我们要传递的参数 @RequestMapping(&quot;/testPath/&#123;id&#125;/&#123;username&#125;&quot;) public String testPath(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String username)&#123;//加上@PathVariable(&quot;id&quot;)注解就可以将形参id赋值为传过来的参数 System.out.println(&quot;id::&quot;+id); System.out.println(&quot;username::&quot;+username); return &quot;success&quot;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;!--视图解析器的命名空间--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/hello/testRequestMapping&#125;&quot;&gt;测试RequestMapping注解的位置&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testRequestMapping&#125;&quot;&gt;测试/testRequestMapping&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试/test&lt;/a&gt;&lt;form th:action=&quot;@&#123;/test&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试RequestMapping注解的method属性---》post&quot;&gt;&lt;/form&gt;&lt;form th:action=&quot;@&#123;/testGetMapping&#125;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试testGetMapping注解&quot;&gt;&lt;/form&gt;&lt;form th:action=&quot;@&#123;/testPut&#125;&quot; method=&quot;put&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试form表单是否可以设置put请求方式&quot;&gt;&lt;/form&gt;&lt;a th:href=&quot;@&#123;/testParamsAndHeaders(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试Params属性&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/a1a/testAnt&#125;&quot;&gt;测试匹配Ant风格的路径？&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/a5678k/testAnt&#125;&quot;&gt;测试匹配Ant风格的路径*&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/a1a/testAnt&#125;&quot;&gt;测试匹配Ant风格的路径**&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/testPath/1/werwsd&#125;&quot;&gt;测试RequestMapping可以支持路径中的占位符--》/testPath&lt;/a&gt;&lt;br&gt;&lt;a th:href=&quot;@&#123;/param&#125;&quot;&gt;跳转&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 1、访问第一个链接 出现404是因为我把类上面的 @RequestMapping(“&#x2F;hello”) 注释了找不到资源 2、访问第二个链接 由报错提示可知因为 username&#x3D;admin 这个条件不满足所以不能访问 3、访问第三个链接会出现和访问第二个链接同样的错误 4、点击图中第一个按钮以post方式发送请求，但是还是不满足 username&#x3D;admin 的条件无法访问 5、点击第二个按钮 成功访问success页面 对应代码 12345//get请求方式的注解@GetMapping(&quot;/testGetMapping&quot;)public String testGetMapping()&#123; return &quot;success&quot;;&#125; 123&lt;form th:action=&quot;@&#123;/testGetMapping&#125;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试testGetMapping注解&quot;&gt;&lt;/form&gt; 由此可知 @GetMapping() 这个注解可以接受 get 请求 6、点击第三个按钮 12345@RequestMapping(value=&quot;/testPut&quot;,method= &#123;RequestMethod.PUT&#125;)public String testPut()&#123; return &quot;success&quot;;&#125; 123&lt;form th:action=&quot;@&#123;/testPut&#125;&quot; method=&quot;put&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;测试form表单是否可以设置put请求方式&quot;&gt;&lt;/form&gt; 对应代码我们可以看到路径没错，对应方法也是一致的，但是就是访问不了，看错误提示 Request method ‘GET’ not supported 翻译过来就是 请求方法不被支持 ，其实原因就是再浏览器上面只有两种请求方,就是post和get请求，当我们用put方式请求时其实它默认为get方式，而我们控制器中没有对应的方法，所以它就表示 请求方法不被支持。 7、点击“ 测试Params属性” 链接 12345678//headers和params要求差不多//就是要要求请求的报文的报头要满足类似 Host=localhost:8080 的键值对的格式才能访问目标网页@RequestMapping(value=&quot;/testParamsAndHeaders&quot;, params = &#123;&quot;username&quot;,&quot;password=123456&quot;&#125;, headers=&#123;&quot;Host=localhost:8080&quot;&#125;)public String testParamsAndHeaders()&#123; return &quot;success&quot;;&#125; 1&lt;a th:href=&quot;@&#123;/testParamsAndHeaders(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试Params属性&lt;/a&gt;&lt;br&gt; 由此可知请求需要满足 含有 username,password属性 且 password&#x3D;123456,Host&#x3D;localhost:8080才能找到对应的方法进而访问成功 8、Ant风格的路径 1234567891011 //写 a?a 表示两个a之间可以加任意的一个字符 /和?除外 //写a*a 表示两个a之间可以加任意的0至多个字符 同样 /和?除外// @RequestMapping(&quot;/a?a/testAnt&quot;)// @RequestMapping(&quot;/a*a/testAnt&quot;)// @RequestMapping(&quot;/a**a/testAnt&quot;)// ** 表示任意的一层或者多层目录 就可以加任意的 / 了// 但是我加了 ? 它就返回上一个网页，不知道是为什么 @RequestMapping(&quot;/**/testAnt&quot;) public String testAnt()&#123; return &quot;success&quot;; &#125; 9、RequestMapping可以支持路径中的占位符 12345678//@RequestMapping(&quot;/testPath/&#123;id&#125;&quot;)中的id就是我们要传递的参数@RequestMapping(&quot;/testPath/&#123;id&#125;/&#123;username&#125;&quot;)public String testPath(@PathVariable(&quot;id&quot;) Integer id, @PathVariable(&quot;username&quot;) String username)&#123;//加上@PathVariable(&quot;id&quot;)注解就可以将形参id赋值为传过来的参数 System.out.println(&quot;id::&quot;+id); System.out.println(&quot;username::&quot;+username); return &quot;success&quot;;&#125; 1&lt;a th:href=&quot;@&#123;/testPath/1/werwsd&#125;&quot;&gt;测试RequestMapping可以支持路径中的占位符--》/testPath&lt;/a&gt;&lt;br&gt; 点击链接在服务器控制台得到以下输出 占位符 {} 位于两个 &#x2F; 之间，当我们在控制器的路径中加上占位符后，我们就可以用restFul风格传送数据，取数据的时候只需在控制器方法的形参位置加上 @PathVariable 注解就可以获取到值 例2 springMVC参数的获取1234567891011121314151617181920package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestController &#123; @RequestMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @RequestMapping(&quot;/param&quot;) public String testParam()&#123; return &quot;test_param&quot;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.atguigu.mvc.controller;import com.atguigu.mvc.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;@Controllerpublic class ParamController &#123; @RequestMapping(&quot;/testServletAPI&quot;) //形参位置的request表示当前的请求对象request public String testServletAPI(HttpServletRequest request)&#123; request.getSession(); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot; + username); System.out.println(&quot;password:&quot; + password); return &quot;success&quot;; &#125; /* @RequestParam @RequestHeader */ //若多个请求参数中出现多个同名的参数，可以在控制器方法的形参位置设置字符串类型或字符串数组来接收此请求参数 //若用字符串类型的形参，最终结果为请求参数的每一个值之间使用逗号进行拼接 //此外这里形参的参数名必须要跟请求对象里的相同 @RequestMapping(&quot;/testParam&quot;) //required = false 表示可以不传username 的值，为true就必须要传值，不传就报错.required默认为true //defaultValue = &quot;hehe&quot; 表示不传值是默认为hehe,不管required的值为true还是false,只要传过来的值为空字符串就使用defaultValue 所指定的默认值 public String testParam(@RequestParam(value = &quot;user_name&quot;,required = false,defaultValue = &quot;hehe&quot;) String username, String password , String hobby ,//String[] hobby 会获取到一个字符串数组 @RequestHeader(value = &quot;Hos&quot;,required = true,defaultValue = &quot;cfffs&quot;) String host, @CookieValue(&quot;JSESSIONID&quot;) String JSESSIONID)&#123; System.out.println(&quot;username:&quot; + username +&quot;\\npassword:&quot; + password+&quot;\\nhobby:&quot;+hobby); System.out.println(&quot;host:&quot; + host+&quot;\\nJSESSIONID&quot; + JSESSIONID); return &quot;success&quot;; &#125; @RequestMapping(&quot;/testBean&quot;) public String testBean(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试请求参数&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;测试请求参数&lt;/h1&gt;&lt;br&gt; &lt;a th:href=&quot;@&#123;/testServletAPI(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试使用ServletAPI来获取请求参数&lt;/a&gt; &lt;br&gt; &lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试使用控制器的形参来获取请求参数&lt;/a&gt; &lt;br&gt;&lt;form th:action=&quot;@&#123;/testParam&#125;&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user_name&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name = &quot;password&quot;&gt;&lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;a&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;b&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;c&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;d&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;测试使用控制器的形参获取请求参数&quot;&gt;&lt;/form&gt;&lt;hr&gt;&lt;form th:action=&quot;@&#123;/testBean&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;使用实体类接受请求参数&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atguigu.mvc.bean;import org.springframework.stereotype.Component;public class User &#123; private String username; private String password; private Integer age; private String sex; private String email; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot; username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 1、测试用原生的servletAPI来获取request请求参数 12345678910111213@RequestMapping(&quot;/testServletAPI&quot;)//形参位置的request表示当前的请求对象requestpublic String testServletAPI(HttpServletRequest request)&#123; request.getSession(); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot; + username); System.out.println(&quot;password:&quot; + password); return &quot;success&quot;;&#125; 1&lt;a th:href=&quot;@&#123;/testServletAPI(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试使用ServletAPI来获取请求参数&lt;/a&gt; &lt;br&gt; 服务器控制台输出结果 2、测试使用控制器的形参来获取请求参数 12345678910111213141516171819//若多个请求参数中出现多个同名的参数，可以在控制器方法的形参位置设置字符串类型或字符串数组来接收此请求参数 //若用字符串类型的形参，最终结果为请求参数的每一个值之间使用逗号进行拼接 //此外这里形参的参数名必须要跟请求对象里的相同 @RequestMapping(&quot;/testParam&quot;) //required = false 表示可以不传username 的值，为true就必须要传值，不传就报错.required默认为true //defaultValue = &quot;hehe&quot; 表示不传值是默认为hehe,不管required的值为true还是false,只要传过来的值为空字符串就使用defaultValue 所指定的默认值 public String testParam(@RequestParam(value = &quot;user_name&quot;,required = false,defaultValue = &quot;hehe&quot;) String username, String password , String hobby ,//String[] hobby 会获取到一个字符串数组 @RequestHeader(value = &quot;Host&quot;,required = true,defaultValue = &quot;cfffs&quot;) String host, @CookieValue(&quot;JSESSIONID&quot;) String JSESSIONID)&#123; System.out.println(&quot;username:&quot; + username +&quot;\\npassword:&quot; + password+&quot;\\nhobby:&quot;+hobby); System.out.println(&quot;host:&quot; + host+&quot;\\nJSESSIONID&quot; + JSESSIONID); return &quot;success&quot;; &#125; 1234567891011 &lt;a th:href=&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;&gt;测试使用控制器的形参来获取请求参数&lt;/a&gt; &lt;br&gt;&lt;form th:action=&quot;@&#123;/testParam&#125;&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;user_name&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name = &quot;password&quot;&gt;&lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;a&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;b&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;c&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;d&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;测试使用控制器的形参获取请求参数&quot;&gt;&lt;/form&gt; 浏览器界面 （1） 当我们点击 “测试使用控制器的形参来获取请求参数 ”这个链接的时候服务器控制台就会输出 这里输出的host和Cookie对应请求头里的 host和Cookie ，我们可以在浏览器页面上右键点击 检查，点击 网络 查看host和Cookie和我们打印出来的一样 请求头里的数据都是以键值对的方式保存的，我们只需用相应的注解就可以获取到数据 （2）在浏览器端输入以下数据然后提交 服务器控制台输出 这里原理已经被我写在了注释里，就不多说了 （3）使用实体类接受请求参数 定义一个实体类User 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.mvc.bean;import org.springframework.stereotype.Component;public class User &#123; private String username; private String password; private Integer age; private String sex; private String email; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot; username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 1234567@RequestMapping(&quot;/testBean&quot;)public String testBean(User user)&#123; System.out.println(user); return &quot;success&quot;;&#125; 12345678&lt;form th:action=&quot;@&#123;/testBean&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;使用实体类接受请求参数&quot;&gt;&lt;br&gt;&lt;/form&gt; 在浏览器输入，点击提交 服务器控制台输出 这里简单的用一个对象来接收参数，需要要注意的是我们传输的参数名和对象里的属性名一定要一一对应 最后说一下，如果不做任何处理从浏览器发来的中文在服务器控制台输出一定会出现乱码。我这里之所以没有出现乱码是因为我在web.xml里加了一个过滤器，更改了编码方式。 1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","categories":[],"tags":[]},{"title":"springMVC简介","slug":"springMVC简介","date":"2022-05-20T12:13:57.000Z","updated":"2022-05-20T13:32:34.637Z","comments":true,"path":"2022/05/20/springMVC简介/","link":"","permalink":"http://example.com/2022/05/20/springMVC%E7%AE%80%E4%BB%8B/","excerpt":"","text":"springMVC是啥呢springMVC是spring的一个后续产品，是spring的一个子项目。 springMVC是spring为表述层开发提供的一整套完备的解决方案。在表述层框架经历Strust,webWork.Strust2等诸多产品的历代更迭之后，目前springMVC可以说是java EE项目表述层开发的最佳方案。springMVC中的MVC就可以很好的解释springMVC的功能，M表示model模块,V表示view视图,C表示controller控制器，这三个模块差不多就是springMVC的主要内容了。 springMVC原理原理图 springMVC工作流程概述 1、客户端向web服务器(如tomcat)发送一个http请求，web服务器对http请求进行解析，解析后的URL地址如果匹配了DispatcherServlet的映射路径(通过web.xml中的servlet-mapping配置),web容器就将请求交给DispatcherServlet处理。 2、DispatcherServlet接收到这个请求后，再对URL进行解析，得到请求资源标识符（URI）。然后调用相应方法得到的HandlerMapping对象，再根据URI，调用这个对象的相应方法获得Handler对象以及它对应的拦截器。（在这里只是获得了Handler对象，并不会操作它，在SpringMVC中，是通过HandlerAdapter对Handler进行调用、控制的） 3、DispatcherServlet根据得到的Handler对象，选择一个合适的HandlerAdapter，创建其实例对象，执行拦截器中的preHandler()方法。 4、在拦截器方法中，提取请求中的数据模型，填充Handler入参，所以所有准备工作都已做好，开始执行Handler（我们写的controller代码并不是能被直接执行，需要有刚才那些操作，才能转变为Handler被执行）。 5、Handler执行完毕后返回一个ModelAndView对象给DispatcherServlet。 6、这个ModleAndView只是一个逻辑视图，并不是真正的视图，DispatcherServlet通过ViewResolver视图解析器将逻辑视图转化为真正的视图（通俗理解为将视图名称补全，如加上路径前缀，加上.jsp后缀，能指向实际的视图）。 7、DispatcherServlet通过Model将ModelAndView中得到的处数据解析后用于渲染视图。将得到的最终视图通过http响应返回客户端。 (上面的图和流程是转载的，我感觉这个流程总结超级好) 第一个springMVC程序1、开发环境 IDE:idea 2021 构建工具：maven(超级推荐用maven构建项目，因为太好用了) 服务器：Tomcat(推荐用tomcat7以上的，有一些东西7不支持) Spring版本：5.3.18 2、构建maven工程 （1）用maven创建一个Web工程 （2）打包方式：war （3）引入依赖 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.mvc&lt;/groupId&gt; &lt;artifactId&gt;springMVC-demo1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;16&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;16&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;!-- spring依赖 --&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 日志 --&gt; &lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt;&lt;!-- &lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt;&lt;!-- servlet依赖 --&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 视图解析器依赖 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.thymeleaf/thymeleaf-spring5 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 构建--&gt; &lt;build&gt; &lt;!-- 设置插件--&gt; &lt;plugins&gt; &lt;!-- 具体的插件配置--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; web.xml12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置springMVC的前端控制器，对浏览器发送的请求进行统一的处理--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;!-- 配置SpringMVC配置文件的位置和名称--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;!-- 将前端控制器DispatcherServlet的初始化时间提前到服务器启动时--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- / 表示服务器默认访问路径为http://localhost:8080/springMVC-demo1 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; springMVC.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 扫描组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 配置Thymeleaf视图解析器--&gt; &lt;bean id=&quot;viewResoler&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;&lt;!-- 视图前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;&lt;!-- 视图后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 配置好了接下来我们进入主题部分 1、先创建一个index.html页面作为首页。 2、创建一个HelloController作为控制器来控制页面的跳转 3、再创建一个target.html 4、在index里写一个超链接实现点击跳转到target页面 index.html123456789101112&lt;!DOCTYPE html&gt;&lt;!-- xmlns:th=&quot;http://www.thyemleaf.org&quot; 实现这种风格的href th:href=&quot;@&#123;/target&#125;&quot; /target为目标路径 --&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你哈!&lt;/h1&gt;&lt;a th:href=&quot;@&#123;/target&#125;&quot;&gt;访问目标页面target.html&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; HelloContriller1234567891011121314151617181920212223242526package com.atguigu.mvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; // value = &quot;/&quot; 经过web.xml配置只要访问http://localhost:8080/springMVC-demo1 //前端控制器就自动找到这里这个index()方法 @RequestMapping(value = &quot;/&quot;) public String index()&#123; //返回视图名称，经过视图解析器，加上 前缀/WEB-INF/templates/ //加上后缀 .html就 得到 http://localhost:8080/springMVC-demo1/WEB-INF/templates/index.html //这样我们就可以访问到index.html文件了 return &quot;index&quot;; &#125; @RequestMapping(&quot;/target&quot;) public String toTarget()&#123; return &quot;target&quot;; &#125;&#125; target.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thyemleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;HELLO WORLD&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 运行结果","categories":[],"tags":[]},{"title":"Spring-事务","slug":"Spring-事务","date":"2022-04-30T15:15:10.000Z","updated":"2022-04-30T15:51:52.239Z","comments":true,"path":"2022/04/30/Spring-事务/","link":"","permalink":"http://example.com/2022/04/30/Spring-%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务：其实就是Spring 用来解决在现实场景中会出现的一些逻辑错误例子：比如你去银行要转账给某人，在你刚刚进行完转账操作，数据库里把你账户上的钱扣除相应的部分，如果这时突然停电但是系统还在转账过程中，这就有可能造成你的钱是被扣除了，但是对方还未收到你的转账。一、propagation:事务传播行为也就是带有事务的方法调用不带事务的方法会默认使不带事务的方法带上事务 二、ioslation:事务隔离级别（1）事务有特性成为隔离性，多事务操作之间不会产生影响，不考虑隔离性会产生很多问题（2）有三个读问题：脏读、不可重复读、虚读（幻读）脏读：一个未提交事务读取到另一个未提交事务的数据不可重复读：一个未提交的事务读取到另一个提交事务修改数据虚读：一个未提交事务读取到另一个提交事务添加数据解决：通过设置事务隔离级别，解决读问题 REPEATABLE_READ:无脏读，无不可重复读READ_COMMITTED：只无脏读SERIALIZABLE：无脏读、无不可重复读、无虚读READ_UNCOMMITTED：啥都不能解决 三、timeout事务需要在一定时间内进行提交，如果不提交进行回滚默认值时-1，设置时间以秒为单位进行 四、readOnly:是否只读1、读：查询操作，写：添加修改删除操作2、readOnly默认值false,表示可以查询，可以进行添加修改删除操作3、设置readOnly 值为true，只能进行查询操作 五、rollbackFor:回滚设置出现哪些异常进行回滚 六、noRollbackFor:不回滚设置出现哪些异常不进行回滚 代码模拟银行转账问题1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;!-- 开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 数据库连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;ljc625995&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;/bean&gt;&lt;!-- jdbcTemplate 对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;!-- 注入dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 创建事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!-- 注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt; 1234567package com.atguigu.spring5.dao;public interface UserDao &#123; public void addMoney(); public void reduceMoney();&#125; 1234567891011121314151617181920212223242526272829303132package com.atguigu.spring5.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repositorypublic class UserDaoImpl implements UserDao&#123; @Autowired private JdbcTemplate jdbcTemplate; //lucy转帐100给mary //加钱 @Override public void addMoney() &#123; String sql = &quot;update t_account set money = money + ? where username = ?&quot;; int money = 100; jdbcTemplate.update(sql,money,&quot;mary&quot;); System.out.println(&quot;mary加&quot;+money+&quot;元&quot;); &#125; //减钱 @Override public void reduceMoney() &#123; String sql = &quot;update t_account set money = money - ? where username = ?&quot;; int money = 100; jdbcTemplate.update(sql,money,&quot;lucy&quot;); System.out.println(&quot;lucy减&quot;+money+&quot;元&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.atguigu.spring5.service;import com.atguigu.spring5.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;//如果@Transactional 里啥都不写就默认propagation = Propagation.REQUIRED 表示事务会在被调用方法和调用方法间传播//添加到类上面：表示类里面所有的方法都添加事务。添加到方法上面：表示仅仅此方法添加事务。mysql 默认REPEATABLE_READ 隔离级别@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ,timeout = -1)@Servicepublic class UserService &#123; //注入 @Autowired private UserDao userDao; //转账的方法 public void accountMoney()&#123; //lucy少100 userDao.reduceMoney(); //用除零错误模拟转账过程中断电或者出现异常 //int i = 10/0; //mary多100 userDao.addMoney(); &#125;&#125; 12345678910111213141516171819202122232425262728293031package com.atguigu.spring5.test;import com.atguigu.spring5.config.TxConfig;import com.atguigu.spring5.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.GenericApplicationContext;public class TestBook &#123; @Test public void testAccount()&#123; // PlatformTransactionManager ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); userService.accountMoney(); &#125; @Test public void testAccount1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); userService.accountMoney(); &#125;&#125; 正常情况 转账前数据库 执行结果 转账后数据库 异常情况 制造异常并运行 出现异常 出现这种请况按道理就是lucy少了100,但是mary没有收到钱 但是这里我们启用了事务当发生异常时就能对这件事情进行回滚，保住了lucy的100块钱 数据库不变","categories":[],"tags":[]},{"title":"Spring-JdbcTemplate","slug":"Spring-JdbcTemplate","date":"2022-04-30T14:22:20.000Z","updated":"2022-04-30T16:00:20.264Z","comments":true,"path":"2022/04/30/Spring-JdbcTemplate/","link":"","permalink":"http://example.com/2022/04/30/Spring-JdbcTemplate/","excerpt":"","text":"Spring框架把JDBC封装在JdbcTemplate 里大大简化了对数据库的操作 在Spring里数据库的连接池一般用的都是 阿里巴巴 的德鲁伊连接池，所有再做数据库的操作时一定要先引入德鲁伊的依赖以及所用数据库的依赖 下面展示用Spring 怎么对数据库进行操作 1、用xml配置好连接池以及Jdbctemplate，并把数据源注入Jdbctemplate 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 数据库连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///salesdb&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;ljc625995&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;/bean&gt;&lt;!-- jdbcTemplate 对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;&lt;!-- 注入dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2、创建一个Book类，设置好属性，对应数据库的列名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atguigu.spring5.entity;public class Book &#123; private String cno; private String cname; private String city; private String manager; private String tel; public void setCno(String cno) &#123; this.cno = cno; &#125; public void setCname(String cname) &#123; this.cname = cname; &#125; public void setCity(String city) &#123; this.city = city; &#125; public void setManager(String manager) &#123; this.manager = manager; &#125; public void setTel(String tel) &#123; this.tel = tel; &#125; public String getCno() &#123; return cno; &#125; public String getCname() &#123; return cname; &#125; public String getCity() &#123; return city; &#125; public String getManager() &#123; return manager; &#125; public String getTel() &#123; return tel; &#125; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;cno=&#x27;&quot; + cno + &#x27;\\&#x27;&#x27; + &quot;, cname=&#x27;&quot; + cname + &#x27;\\&#x27;&#x27; + &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; + &quot;, manager=&#x27;&quot; + manager + &#x27;\\&#x27;&#x27; + &quot;, tel=&#x27;&quot; + tel + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 3、创建接口BookDao定义方法 1234567891011121314151617181920212223242526package com.atguigu.spring5.dao;import com.atguigu.spring5.entity.Book;import java.util.List;public interface BookDao &#123; //添加的方法 void add(Book book); void updateCum(Book book); void deletes(Book book); int selectCount(Book book); Book findCoustomerInfo(String cname); List&lt;Book&gt; findAllCustomer(); void batchAddCust(List&lt;Object[]&gt; batchArgs); void batchUpdateCust(List&lt;Object[]&gt; batchArgs); void batchDeleteCust(List&lt;Object[]&gt; batchArgs);&#125; 4、创建接口实现类BookDaoImpl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.atguigu.spring5.dao;import com.atguigu.spring5.entity.Book;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic class BookDaoImpl implements BookDao&#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; //添加的方法 @Override public void add(Book book) &#123; //1 创建sql语句 //？号代表要填入的数据 String sql = &quot;insert into customer values(?,?,?,?,?)&quot;; //调用方法实现 //这里的这些book.get 方法就代表对上面的问号填入实际的数据 int update = jdbcTemplate.update(sql,book.getCno(),book.getCname(),book.getCity(), book.getManager(),book.getTel()); System.out.println(&quot;成功添加&quot;+update); &#125; @Override public void updateCum(Book book) &#123; String sql = &quot;update customer set cname=?,city=?,manager=? where cno=?&quot;; int update = jdbcTemplate.update(sql,book.getCname(),book.getCity(),book.getManager(),book.getCno()); System.out.println(&quot;成功修改&quot;+update); &#125; @Override public void deletes(Book book) &#123; String sql = &quot;delete from customer where cno=?&quot;; int update = jdbcTemplate.update(sql,book.getCno()); System.out.println(&quot;成功删除&quot;+update); &#125; @Override public int selectCount(Book book) &#123; String sql = &quot;select count(*) from customer&quot;; Integer count = jdbcTemplate.queryForObject(sql,Integer.class); return count; &#125; //查询返回对象 @Override public Book findCoustomerInfo(String cname) &#123; String sql = &quot;select * from customer where cname=?&quot;; //调用方法 Book book = jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class),cname); return book; &#125; @Override public List&lt;Book&gt; findAllCustomer() &#123; String sql = &quot;select * from customer&quot;; //调用方法 //new BeanPropertyRowMapper&lt;Book&gt;(Book.class) 方法用来临时存放从数据库里查出来的数据 List&lt;Book&gt; custList = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class)); //custLid里的就是所查询到的数据 return custList; &#125; @Override public void batchAddCust(List&lt;Object[]&gt; batchArgs) &#123; //其实这里就是把很多个字段的数据放到batchArgs数组中 String sql = &quot;insert into testCustomer values(?,?,?,?,?)&quot;; //在batchUpdate（）内部遍历batchArgs数组，每遍历一次就调用一次sql语句插入一个字段 jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;成功批量添加&quot;); &#125; @Override public void batchUpdateCust(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;update testCustomer set cname=?,city=?,manager=? where cno=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;成功修改&quot;+ints); &#125; @Override public void batchDeleteCust(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;delete from testCustomer where cno=?&quot;; jdbcTemplate.batchUpdate(sql,batchArgs); System.out.println(&quot;成功批量删除&quot;); &#125; &#125; 5、创建一个BookService类定义BookDao属性，定义方法调用相应的sql语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.atguigu.spring5.service;import com.atguigu.spring5.dao.BookDao;import com.atguigu.spring5.entity.Book;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class BookService &#123; //注入Dao @Autowired private BookDao bookDao; //添加的方法 public void addCustomer(Book book)&#123; bookDao.add(book); &#125; //修改 public void updateCustomer(Book book)&#123; bookDao.updateCum(book); &#125; //删除 public void deleteCumtomer(Book book)&#123; bookDao.deletes(book); &#125; //查询表中的记录数 public int findCount(Book book)&#123; return bookDao.selectCount(book); &#125; //查询返回对象 public Book findOne(String cname)&#123; Book book = bookDao.findCoustomerInfo(cname); return book; &#125; public List&lt;Book&gt; findAll()&#123; return bookDao.findAllCustomer(); &#125; //批量添加 public void batchAdd(List&lt;Object[]&gt; batchArgs)&#123; bookDao.batchAddCust(batchArgs); &#125; //批量修改 public void batchUpdate(List&lt;Object[]&gt; batchArgs)&#123; bookDao.batchUpdateCust(batchArgs); &#125; //批量删除 public void batchDelete(List&lt;Object[]&gt; batchArgs)&#123; bookDao.batchDeleteCust(batchArgs); &#125;&#125; 6、创建TestBook测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.atguigu.spring5.test;import com.atguigu.spring5.entity.Book;import com.atguigu.spring5.service.BookService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.ArrayList;import java.util.List;public class TestBook &#123; @Test public void testJDBC()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class); Book book = new Book(); //添加数据// book.setCno(&quot;00009&quot;);// book.setCname(&quot;贵州公司&quot;);// book.setCity(&quot;威宁&quot;);// book.setManager(&quot;李锦超&quot;);// book.setTel(&quot;17580&quot;); // bookService.addCustomer(book); //修改数据// book.setCname(&quot;兴旺&quot;);// book.setCity(&quot;六盘水&quot;);// book.setManager(&quot;王小姐&quot;);// book.setCno(&quot;12345&quot;);// bookService.updateCustomer(book); //删除数据// book.setCno(&quot;00009&quot;);// bookService.deleteCumtomer(book); //查询字段数目// int count = bookService.findCount(book);// System.out.println(count); //查询返回对象// Book boo = bookService.findOne(&quot;兴旺&quot;);// System.out.println(boo); //查询返回集合// List&lt;Book&gt; all = bookService.findAll();////// for(Book bo : all)&#123;// System.out.println(bo);// &#125; //批量添加// List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();// Object[] o1 = &#123;&quot;10086&quot;,&quot;盛世公司&quot;,&quot;威宁&quot;,&quot;李显示&quot;,&quot;22343400&quot;&#125;;// Object[] o2 = &#123;&quot;10087&quot;,&quot;完美公司&quot;,&quot;威宁&quot;,&quot;李显&quot;,&quot;233234343400&quot;&#125;;// Object[] o3 = &#123;&quot;10088&quot;,&quot;刘芳公司&quot;,&quot;威宁&quot;,&quot;显示&quot;,&quot;229000003400&quot;&#125;;// batchArgs.add(o1);// batchArgs.add(o2);// batchArgs.add(o3);// bookService.batchAdd(batchArgs); //批量修改// List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();// Object[] o1 = &#123;&quot;c++公司&quot;,&quot;美国&quot;,&quot;mark&quot;,&quot;10086&quot;&#125;;// Object[] o2 = &#123;&quot;c语言公司&quot;,&quot;法国&quot;,&quot;lilii&quot;,&quot;10087&quot;&#125;;// Object[] o3 = &#123;&quot;java公司&quot;,&quot;中国&quot;,&quot;李先生&quot;,&quot;10088&quot;&#125;;// batchArgs.add(o1);// batchArgs.add(o2);// batchArgs.add(o3);// bookService.batchUpdate(batchArgs); //批量删除 List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); Object[] o1 = &#123;&quot;10086&quot;&#125;; Object[] o2 = &#123;&quot;10087&quot;&#125;; Object[] o3 = &#123;&quot;10088&quot;&#125;; batchArgs.add(o1); batchArgs.add(o2); batchArgs.add(o3); bookService.batchDelete(batchArgs); &#125;&#125; 数据库 这就是Spring操作数据库的大部分方法了","categories":[],"tags":[]},{"title":"Spring5-AOP","slug":"Spring5-AOP","date":"2022-04-30T13:06:58.000Z","updated":"2022-04-30T15:59:58.578Z","comments":true,"path":"2022/04/30/Spring5-AOP/","link":"","permalink":"http://example.com/2022/04/30/Spring5-AOP/","excerpt":"","text":"AOP原理 Spring的AOP实现原理其实很简单，就是通过动态代理实现的。如果我们为Spring的某个bean配置了切面，那么Spring在创建这个bean的时候，实际上创建的是这个bean的一个代理对象，我们后续对bean中方法的调用，实际上调用的是代理类重写的代理方法。而Spring的AOP使用了两种动态代理，分别是JDK的动态代理，以及CGLib的动态代理。AOP其实就是面向切面编程。 那动态代理又是什么呢？我用一个通俗易懂的例子来描述一下 其实动态代理就像现实生活中那些房地产商人有房子，但是他不会直接向普通人出售，一般都是通过房产中介来帮他卖房子，而普通人想要买房子就必须通过房产中介这个Proxy来实现。而房产中介作为理工中间人他可以为我们办理一系列手续，提供咨询等等的事情，这就相当于把我们买房子这个动作增强了。这就是动态代理的大概含义。 JDK动态代理必须要有接口实现类，而这个类中的方法便可以通过JDK动态代理实现功能的增强。 CGLib动态代理是通过继承的方法实现的，有一个唯一的局限就是含有切点（要增强的方法）的类不能由finally修饰，因为有finally 修饰就不能进行类的继承了。 就效率而言CGLib动态代理比JDK动态代理要高很多，但奈何JDK动态代理是java源码，而CGLib是第三方库，在默认情况下都是使用JDK动态代理。 下面是JDK动态代理的具体实现方式1、先创建一个接口里面定义切点（要增强的方法） 1234567package com.atguigu.spring5;public interface UserDao &#123; public int add(int a,int b); public String update(String id);&#125; 2、创建一个接口实现类，实现接口中的方法 123456789101112131415package com.atguigu.spring5;public class UserDaoImpl implements UserDao&#123; @Override public int add(int a, int b) &#123; System.out.println(&quot;add方法执行了....&quot;); return a+b; &#125; @Override public String update(String id) &#123; System.out.println(&quot;update方法之执行了.....&quot;); return id; &#125;&#125; 3、创建一个JDKProxy.java ,包含JDKProx类和UserDaoProxy类 UserDaoProxy类用来实现 InvocationHandler 接口 重写它的 public Object invoke(Object proxy, Method method, Object[] args) 方法，我们想要增强的方法就可以在invoke里实现增强 公共类JDKProx 调用 Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 方法生成代理对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.spring5;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class JDKProxy &#123; public static void main(String[] args)&#123; //创建接口实现类代理对象 Class[] interfaces = &#123;UserDao.class&#125;; //匿名内部类// Proxy.newProxyInstance(JDKProxy.class.getClassLoader(),interfaces,new InvocationHandler()&#123;//// @Override// public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// return null;// &#125;// &#125;); UserDaoImpl userDao = new UserDaoImpl(); //先在下面创建了一个类来继承 Invocationhandler 接口就不用写匿名内部类了 UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(),interfaces, new UserDaoProxy(userDao)); int result = dao.add(1,2); System.out.println(&quot;result:&quot;+result); String id = dao.update(&quot;20117899&quot;); System.out.println(&quot;学号为：&quot;+id); &#125;&#125;//创建代理对象代码class UserDaoProxy implements InvocationHandler &#123;/* 1 创建的是谁的代理对象把谁传进来 */ //有参数构造传递 private Object obj; public UserDaoProxy(Object obj)&#123; this.obj = obj; &#125; //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //方法之前 System.out.println(&quot;方法之前执行...&quot; +method.getName()+&quot;:传递的参数...&quot;+ Arrays.toString(args)); //被增强的方法执行 Object res = method.invoke(obj,args); System.out.println(&quot;res:&quot;+res); //方法之后 System.out.println(&quot;方法之后执行...&quot;+obj); return res; &#125;&#125; 利用Spring框架来实现动态代理1、XML加注解混用实现1234567891011package com.atguigu.spring5.aopanno;import org.springframework.stereotype.Component;//被增强的类@Componentpublic class User &#123; public void add()&#123; System.out.println(&quot;add.....&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.spring5.aopanno;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;//增强的类@Component@Aspect//加上这个注解就使这个类成为代理类@Order(6)//数值越小优先级越高public class UserProxy &#123; //相同的切入点进行抽取,这样就可以用 //pointdemo()来代替execution(* com.atguigu.spring5.aopanno.User.add())了 //当我们需要改切入点的时候只需改一处就可以了 @Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void pointdemo()&#123; &#125; //前置通知 //@Before注解表示作为前置通知 @Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void before()&#123; System.out.println(&quot;before....&quot;); &#125; //最终通知，就算有异常它也执行 @After(value = &quot;pointdemo()&quot;) public void after()&#123; System.out.println(&quot;after.....&quot;); &#125; //后置通知（返回通知）在返回结果后执行 @AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void afterReturning()&#123; System.out.println(&quot;afterReturning....&quot;); &#125; //异常通知，只有发生异常才会执行 @AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void afterThrowing()&#123; System.out.println(&quot;afterThrowing&quot;); &#125; //环绕通知，在方法执行之前和之后都执行 @Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add())&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕之前....&quot;); //被增强的方法 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后....&quot;); &#125; &#125; 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring5.aopanno&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 开启Aspect生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 2、用完全注解方式实现只需把上面的xml配置文件换成配置类就好了 1234567891011121314package com.atguigu.spring5.Config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@ComponentScan(basePackages = &#123;&quot;com.atguigu.spring5&quot;&#125;)//开启注解扫描@Configuration//把这个类作为配置类//proxyTargetClass = false 默认为false 表示JDK代理，true为cglib代理@EnableAspectJAutoProxy(proxyTargetClass = false)//这个注解开启Aspect生成代理对象public class SpringConfig &#123;&#125; 啊这，也太方便了吧 3、只用xml实现123456789package com.atguigu.spring5.aopxml;//被代理类public class Book &#123; //切点 public void buy()&#123; System.out.println(&quot;buy....&quot;); &#125;&#125; 1234567891011121314package com.atguigu.spring5.aopxml;import org.aspectj.lang.annotation.Before;//代理类public class BookProxy &#123; //作为前置通知 public void before()&#123; System.out.println(&quot;before....&quot;); &#125; //作为后置通知 public void after()&#123; System.out.println(&quot;after....&quot;); &#125;&#125; 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- 创建对象--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.aopxml.Book&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bookProxy&quot; class=&quot;com.atguigu.spring5.aopxml.BookProxy&quot;&gt;&lt;/bean&gt;&lt;!-- 配置aop增强--&gt; &lt;aop:config&gt;&lt;!-- 切入点--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.atguigu.spring5.aopxml.Book.buy())&quot;/&gt;","categories":[],"tags":[]},{"title":"Spring5-IOC","slug":"Spring5-IOC","date":"2022-04-30T01:04:29.000Z","updated":"2022-04-30T03:22:34.245Z","comments":true,"path":"2022/04/30/Spring5-IOC/","link":"","permalink":"http://example.com/2022/04/30/Spring5-IOC/","excerpt":"","text":"​ 花了两个星期的课余时间终于把Spring的大致内容学完了，今天先整理一些干货传上来。 IOC原理IOC（控制反转）就是依赖倒置原则的一种代码设计思路。 就是把原先在代码里面需要实现的对象创建、对象之间的依赖，反转给容器来帮忙实现。 Spring IOC容器通过xml,注解等其它方式配置类及类之间的依赖关系，完成了对象的创建和依赖的管理注入。 上面是比较官方的说法，据我理解其实 IOC 的意思是 “控制反转 ” 就是让Spring 帮我们管理对象，让对象在生存在框架上。平时我们不用框架去写代码的时候写出来的代码对象之间的耦合性很高，这样就造成了代码的可维护性极低，当我们需要更改某处的代码时就会造成连锁反应，一处改处处改。用了Spring之后Spring就会把对象都分开，减小耦合度，当我们需要修改代码的时候只需改改配置文件就OK了，也不需要担心每个对象之间复杂的关系。 其实Spring底层就是靠反射机制来完成的。 下面这张图就能很好的体现IOC机制 IOC的一些操作细节XML配置方式1.对象生成先把类写好，然和在xml中配置对象 1&lt;bean id=&quot;user&quot; class=&quot;com.atguigu.spring5.User&quot;&gt;&lt;/bean&gt; id 相当于是给对象起个别名，com.atguigu.spring5.User 是类的全类名 用上述方法我们就可以实现一个对象的创建 2.XML实现属性注入属性注入有两中方式 1、用set方法进行属性注入 先生成每个属性的set方法，然后再在xml文件里进行配置 1234567891011121314151617181920212223242526package com.atguigu.spring5;/** * 演示实用set方法进行注入属性 */public class Book &#123; private String bname; private String bauthor; private String address; public void setBname(String bname) &#123; this.bname = bname; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public void setBauthor( String bauthor) &#123; this.bauthor = bauthor; &#125; public void testDemo()&#123; System.out.println(bname+&quot;----&gt;&quot;+bauthor+&quot;---&gt;&quot;+address); &#125;&#125; 123456789101112 &lt;!--2 set方法注入属性 --&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot;&gt; 实用property完成属性注入 &lt;property name=&quot;bname&quot; value=&quot;李锦超&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;达摩老祖祖&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;中国古代&quot;&gt;&lt;/property&gt; &lt;!-- 属性值包含特殊符号--&gt;&lt;!-- &lt;property name=&quot;address&quot; &gt;--&gt;&lt;!-- &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;--&gt;&lt;!-- &lt;/property&gt;--&gt; &lt;/bean&gt; 测试代码写法 123456789101112131415161718192021package com.atguigu.spring5.testdemo;import com.atguigu.spring5.config.SpringConfig;import com.atguigu.spring5.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring5Demo1 &#123; @Test public void testService()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125;&#125; 2、用构造器进行属性注入 一定要写构造方法，然后才能在xml中配置注入属性 1234&lt;bean id=&quot;orders&quot; class=&quot;com.atguigu.spring5.Orders&quot;&gt; &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 3、引入名称空间，简化属性注入 123&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p = &quot;http://www.springframework.org/schema/p&quot; 最下面的一行就是我引入的名称空间 p,我是这样写的：先复制第一行 xmlns&#x3D;”http://www.springframework.org/schema/beans&quot; 然后改成 第三行 xmlns:p &#x3D; “http://www.springframework.org/schema/p&quot; 这个样子就算引入名称空间 p 了，这个写法是固定的就只能这样写。 再进行属性注入，就可以这样写了 12&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot; p:bname=&quot;九阳神功&quot; p:bauthor=&quot;无名氏&quot;&gt;&lt;/bean&gt; 4.对象注入 对象作为属性注入有两种方式，内部bean和外部bean。 外部bean 写法 优势：可以给多个对象共享 先建两个类，其中一个类是接口实现类 123456789101112package com.atguigu.spring5.service;import com.atguigu.spring5.dao.UserDao;public class UserService &#123; //创建UserDao类型属性，生成set方法 private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125; 123456789package com.atguigu.spring5.dao;public class UserDaoImpl implements UserDao&#123; @Override public void update() &#123; System.out.println(&quot;dao update......&quot;); &#125;&#125; 用xml进行对象注入 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--service和dao对象创建 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring5.service.UserService&quot;&gt;&lt;!-- 注入userDao对象 name属性值，类里面属性名称 ref属性：创建userDao对象bean标签id值--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring5.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 内部bean写法 123456789101112&lt;!-- 内部bean--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;&lt;!-- 设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;李锦超&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;!-- 设置对象类型的属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 5.级联赋值 采用外部bean方式实现 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt; &lt;!-- 设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;王某&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- 级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;&lt;!-- &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 6.集合类型属性注入 这里面包含了含有对象的集合，由于时间原因我就直接贴代码了 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.atguigu.spring5.collectiontype;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Stu &#123; //数组类型属性 private String[] courses; private List&lt;String&gt; list; private Map&lt;String,String&gt; maps; private Set&lt;String&gt; sets; //学生所学多门课程 private List&lt;Course&gt; courseList; public void setCourseList(List&lt;Course&gt; courseList) &#123; this.courseList = courseList; &#125; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125; public void setSets(Set&lt;String&gt; sets) &#123; this.sets = sets; &#125; public void test()&#123; System.out.println(Arrays.toString(courses)); System.out.println(list); System.out.println(maps); System.out.println(sets); System.out.println(courseList); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 1 集合类型属性注入--&gt; &lt;bean id=&quot;stu&quot; class=&quot;com.atguigu.spring5.collectiontype.Stu&quot;&gt;&lt;!-- 数组类型属性注入--&gt; &lt;property name=&quot;courses&quot;&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;value&gt;计算机网络&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!-- list类型属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;value&gt;三儿&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;!-- 注入list集合类型，值是对象--&gt; &lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- 创建多个course对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;MyBatis框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 8.利用名称空间实现公共集合属性 12345678910111213141516package com.atguigu.spring5.collectiontype;import java.util.List;public class Book &#123; private List&lt;String&gt; list; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void test()&#123; System.out.println(list); &#125;&#125; 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;&lt;!-- 1.提取list集合属性的注入--&gt; &lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;易筋经&lt;/value&gt; &lt;value&gt;九阴真经&lt;/value&gt; &lt;value&gt;九阳神功&lt;/value&gt; &lt;/util:list&gt;&lt;!-- 2、提取list集合属性的注入使用--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.collectiontype.Book&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 注意这里的名称空间还要在xsi:schemaLocation的双引号里额外的加上 http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd 9.bean的生命周期 大致可以分为五部分,细分的话有八部分 10.自动装配 有两种自动装配 根据属性名称 byName 根据属性类型 byType 这里我演示的是 byName 123456789101112131415161718192021package com.atguigu.spring5.autowire;public class Emp &#123; private Dept dept; public void setDept(Dept dept) &#123; this.dept = dept; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;dept=&quot; + dept + &#x27;&#125;&#x27;; &#125; public void test()&#123; System.out.println(dept); &#125;&#125; 1234package com.atguigu.spring5.autowire;public class Dept &#123;&#125; 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- 实现自动装配 bean标签属性autowire,配置自动装配 autowire属性常用两个值：byName根据属性名称注入， 注入bean的id值要和属性名称一样 byType根据属性类型注入--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byName&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; XML加注解创建对象很多注解的意思我已经写成注释了，那就直接看代码 12345package com.atguigu.spring5.dao;public interface UserDao &#123; public void add();&#125; 12345678910111213package com.atguigu.spring5.dao;import org.springframework.stereotype.Repository;@Repository(value = &quot;userDaoImpl&quot;)public class UserDaoImpl implements UserDao&#123; @Override public void add() &#123; System.out.println(&quot;Dao add....&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package com.atguigu.spring5.service;import com.atguigu.spring5.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import org.springframework.stereotype.Controller;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;//在注解里面value属性值可以不写//默认值是类名，首字母小写//UserService ---&gt; userService//@Service @Controller @Repository @Component//以上四个注解都可以用来创建对象，只不过用在不同的地方会更容易让人知道目前属于那一层@Component//相当于 &lt;bean id = &quot;userService&quot; class=&quot;.../&quot;/&gt;public class UserService &#123; //定义dao类型的属性 //不需要加set方法 //添加注入属性注解 @Autowired//只要这个注解的时候根据类型进行注入 @Qualifier(value = &quot;userDaoImpl&quot;)//加上这个就可以根据名称（指类的 id 值）进行注入 private UserDao userDao; @Value(value = &quot;李锦超&quot;) private String name; public void add()&#123; System.out.println(&quot;Service add....&quot;); userDao.add(); System.out.println(name); &#125;&#125; 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!-- 开启组件扫描 1 如果扫描多个包，多个包用逗号隔开 2 或者扫描包上层目录 组件扫描的意思就是检查哪些类上面有 @Service @Controller @Repository @Component 这四个注解的其中之一就生成相应的对象，不再用bean标签去生成对象--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 示例1 use-default-filters=&quot;false&quot; 表示现在不使用默认filter context:include-filter 设置扫描哪些内容--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt;&lt;!-- 示例2 下面设置默认扫描所有内容 但是当我们加上 context:exclude-filter 就设置了哪些内容不进行扫描--&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; &gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 下面是测试代码的写法 1234567891011121314151617181920212223package com.atguigu.spring5.testdemo;import com.atguigu.spring5.config.SpringConfig;import com.atguigu.spring5.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpring5Demo1 &#123; @Test public void testService2()&#123; //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); &#125;&#125; 完全注解写法就是把上面的xml文件换成配置类就好了 下面是配置类 12345678910package com.atguigu.spring5.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration //作为配置类，替代xml配置文件@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)//开启组件扫描public class SpringConfig &#123;&#125; 好了，至此Spring的IOC就告一段落，以后有时间我会把底层原理了解一遍再发上来","categories":[],"tags":[]},{"title":"链表相加","slug":"链表相加","date":"2022-04-22T04:34:00.000Z","updated":"2022-04-22T05:09:17.526Z","comments":true,"path":"2022/04/22/链表相加/","link":"","permalink":"http://example.com/2022/04/22/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"今天牛客这题感觉很有意思，我硬是改了好几次才通过，他那个测试数据是真的长啊。 题目 思路1、先分别遍历两个链表，同时利用头插法逆转两个链表2、通过一我们成功的把链表的尾变成了头，这时我们就可以再一个循环里同时遍历两个链表，把他们对应的节点值相加。3、我们要注意两值相加进位的临界值是 9 ，因此我们必须考虑(sum + rem1)&#x3D;9、(sum + rem1)&lt;9、(sum + rem1)&gt;9这三种情况(sum表示两数相加的和，rem1表示进位数)这样做可以得到时间复杂度为O(n),空间复杂度为O(n). 上码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public static ListNode addInList (ListNode head1, ListNode head2) &#123; // write code here ListNode h1 = head1,h2 = head2; ListNode p1=null,p2=null; ListNode p3 = null,pSum = null; int k1=0,k2=0; while(h1!=null) &#123; ListNode temp = h1.next; h1.next = p1; p1 = h1; h1 = temp; k1++; &#125; while(h2!=null) &#123; ListNode temp = h2.next; h2.next = p2; p2 = h2; h2 = temp; k2++; &#125; int min = k1; if(k1&gt;k2) &#123; ListNode temp = p1; p1 = p2; p2 = temp; min = k2; &#125;; //sum为对应的两个数相加的和，rem和rem1用来存放进位数 int sum=0,rem=0,rem1=0; for(int i=0;p2!=null;i++,p2=p2.next) &#123; if(p1!=null&amp;&amp;p2!=null) &#123; sum = p1.val+p2.val; if((sum+rem1)&gt;9) &#123; sum = sum + rem1 - 10; rem = 1; &#125;else&#123; if((sum+rem1)==9)&#123; sum = sum + rem1; &#125;else&#123; if((sum+rem1)&lt;9)&#123; sum = sum + rem1; &#125;else&#123; if(sum&gt;9&amp;&amp;(rem1!=1)) &#123; sum = sum - 10; rem = 1; &#125; &#125; &#125; &#125; pSum = new ListNode(sum); pSum.next = p3; p3 = pSum; rem1 = rem; rem = 0; p1=p1.next; &#125; if(i&gt;=min) &#123; sum = p2.val; if((rem1+sum)&gt;9) &#123; sum = sum + rem1 - 10; rem = 1; &#125;else&#123; if((sum+rem1)==9)&#123; sum = sum + rem1; &#125;else&#123; if((sum+rem1)&lt;9)&#123; sum = sum + rem1; &#125; &#125; &#125; pSum = new ListNode(sum); pSum.next = p3; p3 = pSum; rem1 = rem; rem = 0; &#125; //System.out.println(i); &#125; if(rem1==1) &#123; pSum = new ListNode(1); pSum.next = p3; p3 = pSum; &#125; //output(p3); return p3; &#125; 结果","categories":[],"tags":[]},{"title":"牛客第三题","slug":"牛客第三题","date":"2022-04-16T15:20:18.000Z","updated":"2022-04-16T15:39:24.383Z","comments":true,"path":"2022/04/16/牛客第三题/","link":"","permalink":"http://example.com/2022/04/16/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%89%E9%A2%98/","excerpt":"","text":"今天又在牛客刷了一题，就单纯的想记录一下。 题目描述将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。 数据范围： 2000 0≤n≤2000 ， 20001≤k≤2000 ，链表中每个元素都满足 10000≤val≤1000要求空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)例如：给定的链表是 1→2→3→4→5对于 k &#x3D; 2k&#x3D;2 , 你应该返回 2→1→4→3→5对于 k &#x3D; 3k&#x3D;3 , 你应该返回 3→2→1→4→5 上码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static ListNode reverseKGroup (ListNode head, int k) &#123; /* * 我的大体思路就是每遍历k个节点就顺便放到栈里面，在栈里面把k个节点反转， * 然后再与后面的节点连起来 */ // write code here //如果链表为空或者k=1,就直接返回链表 if(head == null||k==1) &#123; return head; &#125; ListNode pre = head; ListNode temp=head,temp1= new ListNode(0); ListNode h =temp1,temp2=new ListNode(0); //用数组建一个栈，用来存k个节点 ListNode[] keyNode = new ListNode[k]; int keyCount = 0; int c=0; for(int i = 0;pre!=null;i++,keyCount++,c=i) &#123; if(i%k==0&amp;&amp;i!=0) &#123; temp2.next = keyNode[keyCount-1]; temp = keyNode[keyCount-1].next; for(int j = keyCount-1;j&gt;=0;j--) &#123; temp1.next = keyNode[j]; temp1 = keyNode[j]; &#125; temp2 = keyNode[0]; pre = temp; keyCount = 0; keyNode[keyCount] = pre; pre = pre.next; continue; &#125; //System.out.println(i); keyNode[keyCount] = pre; pre = pre.next; &#125; if(c&lt;k) &#123; return head; &#125; ListNode pp=null; if(c==k) &#123; for(int i = keyCount-1;i&gt;=0;i--) &#123; ListNode t = head.next; head.next = pp; pp = head; head = t; &#125; //output(pp); return pp; &#125; if(keyCount==k) &#123; for(int i = keyCount-1;i&gt;=0;i--) &#123;temp2.next = keyNode[i];temp2 = keyNode[i]; &#125; temp2.next=null; &#125;else &#123; for(int i = 0;i&lt;keyCount;i++) &#123; temp2.next = keyNode[i]; temp2 = keyNode[i]; &#125; &#125; //output(h); return h.next;&#125; 运行结果 这让我很意外","categories":[],"tags":[]},{"title":"AnswerPage","slug":"AnswerPage","date":"2022-04-15T01:13:10.000Z","updated":"2022-04-15T01:35:41.715Z","comments":true,"path":"2022/04/15/AnswerPage/","link":"","permalink":"http://example.com/2022/04/15/AnswerPage/","excerpt":"","text":"这两天小春同学向我求助帮他做一个答题网页。虽然感觉自己有很多事情都还没有做完，但是好哥们儿我肯定要帮啊。于是我就利用了三天的零碎时间做了这个网页，其实做完这个网页对我自己的收获也蛮大的。 AnswerPage需求：1、做一个由很多正方形组成的边框2、正方形边框里要有一个党徽在不断的移动3、让题目动态的显示，做完一题就可以进入下一题4、最后计算总分，用时其他的我就不多做赘述了，很多细节我已经写成注释混合在代码里了 上码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #content&#123;margin:20px auto 0px;&#125; .d2&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:40px;&#125; #contentbuttom&#123;margin:20px auto 0px;&#125; .d3&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:620px;&#125; #contentleft&#123;margin:20px auto 0px;&#125; .d4&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:130px;&#125; #contentright&#123;margin:20px auto 0px;&#125; .d5&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:1450px; top:130px;&#125; .move &#123; width: 80px; height: 80px; left:10px; top:40px; background-color: yellow; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var onOff = true; //获取body里面的div，返回值是数组 var d2 = document.getElementById(&#x27;content&#x27;).getElementsByTagName(&#x27;div&#x27;); var d3 = document.getElementById(&#x27;contentbuttom&#x27;).getElementsByTagName(&#x27;div&#x27;); var d4 = document.getElementById(&#x27;contentleft&#x27;).getElementsByTagName(&#x27;div&#x27;); var d5 = document.getElementById(&#x27;contentright&#x27;).getElementsByTagName(&#x27;div&#x27;); var d6 = document.getElementById(&#x27;mo&#x27;).getElementsByTagName(&#x27;div&#x27;); //生成最上面的墙(在id为content的div中生成17个div作为墙) function aa()&#123; document.getElementById(&#x27;content&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;17; i++)&#123; document.getElementById(&#x27;content&#x27;).innerHTML += &#x27;&lt;div class=&quot;d2&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d2[i].style.left = 10+(i*90)+&#x27;px&#x27;;//计算每个div间的距离 &#125; onOff = true; &#125; &#125; aa(); //生成最下面的墙(在id为contentbuttom的div中生成17个div作为墙) function bb()&#123; document.getElementById(&#x27;contentbuttom&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;17; i++)&#123; document.getElementById(&#x27;contentbuttom&#x27;).innerHTML += &#x27;&lt;div class=&quot;d3&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d3[i].style.left = 10+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; bb(); //生成左边的墙(在id为contentleft的div中生成5个div作为墙) function cc()&#123; document.getElementById(&#x27;contentleft&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;5; i++)&#123; document.getElementById(&#x27;contentleft&#x27;).innerHTML += &#x27;&lt;div class=&quot;d4&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d4[i].style.top = 150+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; cc(); //生成右边的墙(在id为contentright的div中生成5个div作为墙) function dd()&#123; document.getElementById(&#x27;contentright&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;5; i++)&#123; document.getElementById(&#x27;contentright&#x27;).innerHTML += &#x27;&lt;div class=&quot;d5&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d5[i].style.top = 150+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; dd(); //生成党徽(在id为mo的div中生成一个放党徽的div) function ee()&#123; document.getElementById(&#x27;mo&#x27;).innerHTML = &#x27;&#x27;; document.getElementById(&#x27;mo&#x27;).innerHTML += &#x27;&lt;div id=&quot;mm&quot; class=&quot;move&quot;&gt;&#x27;+&#x27;&lt;img src=&quot;https://tse2-mm.cn.bing.net/th/id/OIP-C.w7iifmShxQ8WNVHgRsnTRgHaHE?w=213&amp;h=204&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.25&amp;pid=1.7&quot; width=&quot;80&quot; height=&quot;80&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; &#125; ee(); //以下代码为控制党徽不断的在墙面上移动 m = document.getElementById(&#x27;mm&#x27;);//获取党徽所在的div的id var num1 = 10,num2=150,num3=600,num4=620;//这里初始化党徽运动到每一面墙的初始值 var x = 0,y=0;//这里用来定位党徽的位置 var flagx1 = true,flagx2=false,flagy1 = false,flagy2=false;//辅助变量 setInterval(function ()&#123; //在最上面的墙上运动 if((x&gt;=0&amp;&amp;x&lt;17)&amp;&amp;y==0)&#123; num2=150; flagx1=true; flagx2=false; flagy2=false; flagy1=false; m.style.top = 40 +&quot;px&quot;; m.style.left = num1 + &#x27;px&#x27;; num1 = num1 +90; &#125; //在右边的墙上运动 if(x==17&amp;&amp;(y&gt;=0&amp;&amp;y&lt;5))&#123; num4=num1-90; flagy1=true; flagx1=false; flagx2=false; flagy2=false; m.style.top = num2 +&#x27;px&#x27;; num2 = num2 + 90; &#125; //在最下面的墙上运动 if((x&lt;=17&amp;&amp;x&gt;0)&amp;&amp;y==5)&#123; num3=num2-90; flagx1=false; flagx2=true; flagy2=false; flagy1=false; m.style.top = 620 +&#x27;px&#x27;; m.style.left = num4 +&#x27;px&#x27;; num4 = num4 -90; &#125; //在最左边的墙上运动 if(x==0&amp;&amp;(y&lt;=5&amp;&amp;y&gt;0))&#123; num1 = 10 flagx1=false; flagx2=false; flagy2=true; flagy1=false; m.style.top = num3 +&#x27;px&#x27;; num3 = num3 -90; &#125; if(flagx1==true)&#123; x++; &#125; if(flagx2==true)&#123; x--; &#125; if(flagy1==true)&#123; y++ &#125; if(flagy2==true)&#123; y--; &#125; &#125;,300) var num = 10; /* setInterval(function()&#123; m.style.left = num +&#x27;px&#x27;; num = num +90; &#125;,500)*/ &#125; function $(id)&#123;//拿到html页里相应的id对象（这里的$相当于函数名,固定用法） return document.getElementById(id); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body background=&quot;https://tse1-mm.cn.bing.net/th/id/OIP-C.-Q5IrwV8dZ3PxjXIXW_ypwHaE8?pid=ImgDet&amp;rs=1&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var problems = new Array(9);//这个数组用来存放题目 problems[0] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[1] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[2] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; problems[3] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[4] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[5] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; problems[6] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[7] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[8] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; var arr = problems; var score_sum=0;//计分 // arr.push(problem1); //arr.push(problem2); //arr.push(problem3); for(let i=0;i&lt;3;i++)&#123; &#125; var k =0; var flag=false; //这些变量用来存放开始时间 var start_h=0 var start_m=0 var start_s=0 //这个函数用来控制下一题 function fun()&#123; judge(k,arr);//每点一次下一题按钮判断一次选项的值 k++; if(k==arr.length)&#123;//如果题目全部做完就把form删了，显示得分、用时 // alert(&quot;答题完毕！ &quot;+&quot;总得分：&quot;+score_sum); del(); var endtime = new Date(); var end_h = endtime.getHours(); var end_m = endtime.getMinutes(); var end_s = endtime.getSeconds(); var total_m=0; var total_s=0; //alert(&quot;结束时间：&quot;+end_m+&quot;分 &quot;+end_s+&quot;秒&quot;); //得到正确的时间 if(end_h!=start_h)&#123; total_m = (60-start_h)+end_m; if(end_m!=start_m)&#123; total_s = (60-start_s)+end_s; &#125;else&#123; total_s = end_s - start_s; &#125; &#125;else&#123; total_m = end_m - start_m; if(end_m!=start_m)&#123; total_s = (60-start_s)+end_s; &#125;else&#123; total_s = end_s - start_s; &#125; &#125; if(total_m&gt;0)&#123; total_m = total_m - 1; &#125; //alert(&quot;用时&quot;+total_m+&quot;分&quot;+total_s+&quot;秒&quot;); $(&#x27;replace&#x27;).innerHTML += &#x27;&lt;div style=&quot;margin-left: 150px;margin-top:150px; font-size:50px;color: rgb(23, 18, 168);&quot;&gt;&#x27;+&quot;总得分：&quot;+score_sum+ &quot;分 用时&quot;+total_m+ &quot;分钟&quot; +total_s+&#x27;秒&lt;/div&gt;&#x27;; &#125; //以下控制题目变化 document.getElementById(&#x27;a1&#x27;).innerHTML=arr[k].titile; document.getElementById(&#x27;a2&#x27;).innerHTML=arr[k].choice1; document.getElementById(&#x27;a3&#x27;).innerHTML=arr[k].choice2; document.getElementById(&#x27;a4&#x27;).innerHTML=arr[k].choice3; document.getElementById(&#x27;a5&#x27;).innerHTML=arr[k].choice4; //k++; &#125; function del()&#123;//删除form var elem = document.getElementById(&quot;myform&quot;); elem.parentNode.removeChild(elem); &#125; function judge(k,arr)&#123;//判断选项 var obj = document.getElementsByName(&#x27;ch&#x27;); var len = obj.length; //alert(k+&quot; &quot;+arr[k].answer); // alert(len) for(let j=0;true;j++)&#123; if(obj[j].checked==true)&#123; if(obj[j].value==arr[k].answer)&#123; score_sum = score_sum + 5; &#125; //alert(&quot;已选择&quot;+obj[j].value+&quot; 目前得分&quot;+score_sum); break; &#125; &#125; &#125; function au()&#123;//显示第一题 document.getElementById(&#x27;a1&#x27;).innerHTML=arr[0].titile; document.getElementById(&#x27;a2&#x27;).innerHTML=arr[0].choice1; document.getElementById(&#x27;a3&#x27;).innerHTML=arr[0].choice2; document.getElementById(&#x27;a4&#x27;).innerHTML=arr[0].choice3; document.getElementById(&#x27;a5&#x27;).innerHTML=arr[0].choice4; var starttime = new Date(); //获取开始时间 start_h = starttime.getHours(); start_m = starttime.getMinutes(); start_s = starttime.getSeconds(); //alert(&quot;开始时间：&quot;+start_m+&quot;分 &quot;+start_s+&quot;秒&quot;); //judge(0,arr); &#125; setTimeout(&quot;au()&quot;,1);//刚打开页面就显示第一个题目&lt;/script&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentbuttom&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentleft&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentright&quot;&gt;&lt;/div&gt;&lt;div id=&quot;mo&quot;&gt;&lt;/div&gt;&lt;div id=&quot;replace&quot;&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 500px;margin-top:300px; font-size:50px; color: rgb(134, 134, 137); position: absolute;&quot;&gt;我们一起来做题&lt;/div&gt;&lt;form style=&quot;margin-left: 200px;margin-top:200px;color: rgb(23, 18, 168);font-size: 20px;font-weight: bold;&quot; name=&quot;myform&quot; id=&quot;myform&quot;&gt;题目：&lt;label &gt;&lt;p id=&quot;a1&quot;&gt;&lt;/p&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;A&quot;&gt;A、&lt;label id=&quot;a2&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;B&quot;&gt;B、&lt;label id=&quot;a3&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;C&quot;&gt;C、&lt;label id=&quot;a4&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;D&quot;&gt;D、&lt;label id=&quot;a5&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; onclick=&quot;fun()&quot; name=&quot;next&quot; value=&quot;下一题&quot; style=&quot;font-size: 20px;color: blue;&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"反转链表","slug":"反转链表","date":"2022-04-10T01:24:55.000Z","updated":"2022-04-10T14:11:27.338Z","comments":true,"path":"2022/04/10/反转链表/","link":"","permalink":"http://example.com/2022/04/10/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"今天心血来潮想刷点题，于是就注册了牛客。没想到第一个题就是反转链表，啊这不是so easy吗。我火急火燎的就写完提交，没想到运行时间116ms,占用内存高达12948KB。代码我是用java写的，我看一些大神用Rust,C写竟然只花了2ms,300多KB,简直太牛了。后来我去看了一些题解把代码改进了一下，不用再去new空间，直接将原结点的指针反过来就ok了。 上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package p1;import java.util.Scanner;public class reverseLink &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ListNode h = create_list(); //output(h); ReverseList(h); &#125; public static ListNode create_list() &#123; Scanner input = new Scanner(System.in); int x=input.nextInt(); ListNode p=null,p1=null; ListNode h=new ListNode(input.nextInt()); p1=h; for(int i=0;i&lt;x-1;i++) &#123; p = new ListNode(input.nextInt()); p1.next = p; p1=p; p.next = null; &#125; return h; &#125; public static void output(ListNode h) &#123; while(h!=null) &#123; System.out.println(h.val); h=h.next; &#125; &#125; public static ListNode ReverseList(ListNode head) &#123; ListNode p=null,temp=null; //最巧的就是这个循环了 while(head!=null) &#123; //先让temp指向head.next节点,用来遍历链表 temp = head.next; //head.next指针指向p head.next = p; //让p指向head这个节点，这样下次循环的节点就可以和现在的节点连起来了 p = head; //这里再把刚刚temp保存的地址赋给head，继续遍历下一个节点 head = temp; &#125; while(p!=null) &#123; System.out.println(p.val); p=p.next; &#125; return new ListNode(1); &#125;&#125;class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 运行结果","categories":[],"tags":[]},{"title":"java编译器","slug":"java编译器","date":"2022-04-02T17:24:55.000Z","updated":"2022-04-02T17:53:14.675Z","comments":true,"path":"2022/04/03/java编译器/","link":"","permalink":"http://example.com/2022/04/03/java%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"java编译器今天偶然在网上看到一个java项目，就是用Java写一个Java编译器，只要会Javase就可以做。主要用到java里的几个包比如swing、io等。啊这不就很适合我做吗，于是我就跟着教程手敲了这个程序。由于时间问题，我就不写思路了，还有源代码我没有写注释，等有时间再来写吧。 FileWindow.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.Lijinchao.myedit;import java.awt.CardLayout;、import java.awt.Color;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.BufferedInputStream;import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JTextArea;import javax.swing.JTextField;public class FileWindow extends JFrame implements ActionListener,Runnable &#123; Thread compiler = null; Thread run_prom = null; boolean bn = true; CardLayout mycard; File file_saved = null; JButton button_input_txt, button_compiler_text, button_compiler, button_run_prom, button_see_doswin; JPanel p = new JPanel(); JTextArea input_text = new JTextArea(); JTextArea compiler_text = new JTextArea(); JTextArea dos_out_text = new JTextArea(); JTextField input_file_name_text = new JTextField(); JTextField run_file_name_text = new JTextField(); public FileWindow() &#123; super(&quot;JavaCompiler&quot;); mycard = new CardLayout(); compiler = new Thread(this); run_prom = new Thread(this); button_input_txt = new JButton(&quot;程序输入区(white)&quot;); button_compiler_text = new JButton(&quot;编译结果区(pink)&quot;); button_see_doswin = new JButton(&quot;程序执行结果(wathet)&quot;); button_compiler = new JButton(&quot;Compiler&quot;); button_run_prom = new JButton(&quot;Running&quot;); p.setLayout(mycard); p.add(&quot;input&quot;,input_text); p.add(&quot;compiler&quot;,compiler_text); p.add(&quot;dos&quot;,dos_out_text); add(p,&quot;Center&quot;); compiler_text.setBackground(Color.pink); dos_out_text.setBackground(Color.cyan); JPanel p1 = new JPanel(); p1.setLayout(new GridLayout(3,3)); p1.add(button_input_txt); p1.add(button_compiler_text); p1.add(button_see_doswin); p1.add(new JLabel(&quot;输入程序名称(.java)&quot;)); p1.add(input_file_name_text); p1.add(button_compiler); p1.add(new JLabel(&quot;输入程序主类名&quot;)); p1.add(run_file_name_text); p1.add(button_run_prom); add(p1,&quot;North&quot;); button_input_txt.addActionListener(this); button_compiler.addActionListener(this); button_compiler_text.addActionListener(this); button_run_prom.addActionListener(this); button_see_doswin.addActionListener(this); &#125; public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==button_input_txt) &#123; mycard.show(p,&quot;input&quot;); &#125;else if(e.getSource()==button_compiler_text) &#123; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_see_doswin) &#123; mycard.show(p, &quot;dos&quot;); &#125;else if(e.getSource()==button_compiler) &#123; if(!(compiler.isAlive())) &#123; compiler = new Thread(this); &#125; try &#123; compiler.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_run_prom) &#123; if(!(run_prom.isAlive())) &#123; run_prom = new Thread(this); &#125; try &#123; run_prom.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;dos&quot;); &#125; &#125; public void run() &#123; if(Thread.currentThread()==compiler) &#123; compiler_text.setText(null); String temp = input_text.getText().trim(); byte [] buffer = temp.getBytes(); int b = buffer.length; String file_name = null; file_name = input_file_name_text.getText().trim(); try &#123; file_saved = new File(file_name); FileOutputStream writefile = null; writefile = new FileOutputStream(file_saved); writefile.write(buffer, 0, b); writefile.close(); &#125;catch (Exception e) &#123; System.out.println(&quot;ERROR&quot;); &#125; try &#123; Runtime rt = Runtime.getRuntime(); InputStream in = rt.exec(&quot;javac &quot;+file_name).getErrorStream(); BufferedInputStream bufIn = new BufferedInputStream(in); byte[] shuzu = new byte[100]; int n=0; boolean flag = true; while((n=bufIn.read(shuzu,0,shuzu.length))!=-1) &#123; String s = null; s = new String(shuzu,0,n); compiler_text.append(s); if(s!=null) &#123; flag = false; &#125; &#125; if(flag) &#123; compiler_text.append(&quot;Compiler Succeed!&quot;); &#125; &#125; catch (Exception e) &#123; &#125; &#125; else if(Thread.currentThread()==run_prom) &#123; dos_out_text.setText(null); try &#123; Runtime rt = Runtime.getRuntime(); String path = run_file_name_text.getText().trim(); Process stream = rt.exec(&quot;java &quot;+path); InputStream in = stream.getInputStream(); BufferedInputStream bisErr = new BufferedInputStream(stream.getErrorStream()); BufferedInputStream bisIn = new BufferedInputStream(in); byte[] buf = new byte[150]; byte[] err_buf = new byte[150]; int m=0; int i=0; String s = null; String err = null; while((m = bisIn.read(buf, 0, 150))!=-1) &#123; s = new String(buf,0,150); dos_out_text.append(s); &#125; while((i = bisErr.read(err_buf))!=-1) &#123; &#123; err = new String(err_buf,0,150); dos_out_text.append(err); &#125; &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; Main.java12345678910111213141516171819202122package com.Lijinchao.myedit;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub FileWindow win = new FileWindow(); win.pack(); win.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); win.setBounds(200,180,550,360); win.setVisible(true); &#125;&#125; 运行结果点Running出现这样的画面就说明没问题了 正确运行需要在程序输入区输入代码，记住程序名称一定要.java作为后缀,并且程序名称一定要和主类名同名，主类名没有后缀。 1.先在程序输入区写好代码 2.点击Compiler编译 3.点击Running运行","categories":[],"tags":[]},{"title":"利用python爬取网页表情包","slug":"python爬虫","date":"2022-03-26T07:11:26.000Z","updated":"2022-04-15T01:39:34.806Z","comments":true,"path":"2022/03/26/python爬虫/","link":"","permalink":"http://example.com/2022/03/26/python%E7%88%AC%E8%99%AB/","excerpt":"","text":"今天刷着刷着视频，突然刷到一个关于python爬虫的视频，瞬间激起了我对爬虫的好奇心。刚好我以前学过一点python的知识，这会儿终于派上用场了。于是我上网借鉴了一些资料写了这个爬虫代码 requests,re知识想要写爬虫代码我们需要先了解这两个包。requests是一个很实用的python HTTP客户端库，编写爬虫这个包必不可少。这是我们常用的方法：requests.get()：获取HTML网页的主要方法，对应于HTTP的GET。re模块创建一个“规则表达式”，用于验证和查找符合规则的文本，广泛用于各种搜索引擎，账号密码的验证等。这是我们常用的两个方法：findall：扫描整个目标文本，返回所有与规则匹配的子串组成的列表，如果没有匹配的返回空列表。split：从与规则匹配的子串进行切割，返回切割后子串组成的列表。 爬虫编写步骤找表情包网站https://www.biaoqingba.net/hot.html 这个网址就是我爬表情包的网站，每个网站都有自己的HTML网页，所以我们需要简单的分析一下网页的HTML代码，便于写正则表达式，这里我就不多说了，直接看图。 获取URL，并且发起请求首先，我们想要下载表情包，就需要先获取网页的url，get方法里的网址就是url，可以上百度找到一个网页，然后复制链接就好。requests.get()就发起了一个请求。 1response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;) 利用正则表达式筛选数据在img标签中提取我们想要的内容，比如表情包的url,名字等 123re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text) 保存数据这里我们写一个download方法来保存数据。 12345678910111213# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix) 这里是源代码123456789101112131415161718192021222324252627282930313233343536373839import reimport osimport requests# https://www.biaoqingba.net/hot.html，这是我爬表情包的网页# 创建一个文件用来放表情包，images为文件名images = &#x27;images&#x27;# 如果文件不存在，就新建一个if not os.path.exists(images): os.mkdir(images)# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix)response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;)# print(response.text) 打印所请求网页的内容，其实就是网页的实现代码# 这行代码用了正则表达式来提取img标签的内容，src的引号内就是表情包链接，(.*?)表示# 只要是引号内的内容都要re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text)# print(result)# 循环获取result数组内的每个元素，调用download函数下载表情包for img in result: print(img) download(img[1], img[0]) # img[1]为name,img[0]为url 运行结果爬了满满一文件夹的表情包，真爽！","categories":[],"tags":[]},{"title":"Socket","slug":"page","date":"2022-03-21T01:34:55.000Z","updated":"2022-04-02T16:53:05.986Z","comments":true,"path":"2022/03/21/page/","link":"","permalink":"http://example.com/2022/03/21/page/","excerpt":"","text":"什么是Socket呢？Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。简言之，我们的QQ或者微信发送消息和接受消息的功能，底层就是用Socket实现的。废话不多说，直接上代码。 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package SeverAndClient;/** * @author 超 * 这里是服务器，开启两个线程，一个是接收消息的，一个是发送消息的 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class sever extends Thread&#123; ServerSocket server = null;//先定义一个服务Socket Socket socket = null; public sever(int port) &#123;//直接利用构造方法传入端口号 try &#123; server = new ServerSocket(port);//实例化ServerSocket &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run()&#123; super.run(); try&#123; System.out.println(&quot;wait client connect...&quot;); socket = server.accept();//等待客户端连接 new sendMessThread().start();//连接并返回socket后，再启用发送消息线程 System.out.println(socket.getInetAddress().getHostAddress()+&quot;SUCCESS TO CONNECT...&quot;); InputStream in = socket.getInputStream();//利用IO流获取信息 int len = 0; byte[] buf = new byte[1024];//这个用来缓冲数据 while ((len=in.read(buf))!=-1)&#123; System.out.println(&quot;client saying: &quot;+new String(buf,0,len)); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //这个就是发送消息的线程 class sendMessThread extends Thread&#123; @Override public void run()&#123; super.run(); Scanner scanner=null; OutputStream out = null; try&#123; if(socket != null)&#123; scanner = new Scanner(System.in); out = socket.getOutputStream(); String in = &quot;&quot;; do &#123; in = scanner.next();//输入数据 out.write((&quot;server saying: &quot;+in).getBytes()); out.flush();//清空缓存区的内容 &#125;while (!in.equals(&quot;q&quot;)); scanner.close(); try&#123; out.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; sever server = new sever(1234); server.start();//启动线程 &#125;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package SeverAndClient;/** * @author 超 * 这里是客户端 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;public class client extends Thread &#123; //定义一个Socket对象 Socket socket = null; public client(String host, int port) &#123; try &#123; //需要服务器的IP地址和端口号，才能获得正确的Socket对象 socket = new Socket(host, port);//host为服务器的ip地址，port为服务器的端口号 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; //客户端一连接就可以写数据个服务器了 new sendMessThread().start(); super.run(); try &#123; // 读Sock里面的数据 InputStream s = socket.getInputStream(); byte[] buf = new byte[1024];//缓冲数据 int len = 0; while ((len = s.read(buf)) != -1) &#123; System.out.println(new String(buf, 0, len)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //往Socket里面写数据，需要新开一个线程 class sendMessThread extends Thread&#123; @Override public void run() &#123; super.run(); //写操作 Scanner scanner=null; OutputStream os= null; try &#123; scanner=new Scanner(System.in); os= socket.getOutputStream(); String in=&quot;&quot;; do &#123; in=scanner.next();//输入数据 os.write((&quot;&quot;+in).getBytes()); os.flush(); &#125; while (!in.equals(&quot;bye&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; scanner.close(); try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; //需要服务器的正确的IP地址和端口号 client clientTest=new client(&quot;127.0.0.1&quot;, 8000);//127.0.0.1为测试专用ip,如果你想连另一台主机，就把ip换了 clientTest.start();//启动线程 &#125;&#125; 运行结果记住！一定要先运行服务器。","categories":[],"tags":[]}],"categories":[],"tags":[]}