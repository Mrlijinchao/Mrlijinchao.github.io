{"meta":{"title":"Mr.li的小站","subtitle":"","description":"","author":"Mr.li","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"链表相加","slug":"链表相加","date":"2022-04-22T04:34:00.000Z","updated":"2022-04-22T05:09:17.526Z","comments":true,"path":"2022/04/22/链表相加/","link":"","permalink":"http://example.com/2022/04/22/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/","excerpt":"","text":"今天牛客这题感觉很有意思，我硬是改了好几次才通过，他那个测试数据是真的长啊。 题目 思路1、先分别遍历两个链表，同时利用头插法逆转两个链表2、通过一我们成功的把链表的尾变成了头，这时我们就可以再一个循环里同时遍历两个链表，把他们对应的节点值相加。3、我们要注意两值相加进位的临界值是 9 ，因此我们必须考虑(sum + rem1)&#x3D;9、(sum + rem1)&lt;9、(sum + rem1)&gt;9这三种情况(sum表示两数相加的和，rem1表示进位数)这样做可以得到时间复杂度为O(n),空间复杂度为O(n). 上码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public static ListNode addInList (ListNode head1, ListNode head2) &#123; // write code here ListNode h1 = head1,h2 = head2; ListNode p1=null,p2=null; ListNode p3 = null,pSum = null; int k1=0,k2=0; while(h1!=null) &#123; ListNode temp = h1.next; h1.next = p1; p1 = h1; h1 = temp; k1++; &#125; while(h2!=null) &#123; ListNode temp = h2.next; h2.next = p2; p2 = h2; h2 = temp; k2++; &#125; int min = k1; if(k1&gt;k2) &#123; ListNode temp = p1; p1 = p2; p2 = temp; min = k2; &#125;; //sum为对应的两个数相加的和，rem和rem1用来存放进位数 int sum=0,rem=0,rem1=0; for(int i=0;p2!=null;i++,p2=p2.next) &#123; if(p1!=null&amp;&amp;p2!=null) &#123; sum = p1.val+p2.val; if((sum+rem1)&gt;9) &#123; sum = sum + rem1 - 10; rem = 1; &#125;else&#123; if((sum+rem1)==9)&#123; sum = sum + rem1; &#125;else&#123; if((sum+rem1)&lt;9)&#123; sum = sum + rem1; &#125;else&#123; if(sum&gt;9&amp;&amp;(rem1!=1)) &#123; sum = sum - 10; rem = 1; &#125; &#125; &#125; &#125; pSum = new ListNode(sum); pSum.next = p3; p3 = pSum; rem1 = rem; rem = 0; p1=p1.next; &#125; if(i&gt;=min) &#123; sum = p2.val; if((rem1+sum)&gt;9) &#123; sum = sum + rem1 - 10; rem = 1; &#125;else&#123; if((sum+rem1)==9)&#123; sum = sum + rem1; &#125;else&#123; if((sum+rem1)&lt;9)&#123; sum = sum + rem1; &#125; &#125; &#125; pSum = new ListNode(sum); pSum.next = p3; p3 = pSum; rem1 = rem; rem = 0; &#125; //System.out.println(i); &#125; if(rem1==1) &#123; pSum = new ListNode(1); pSum.next = p3; p3 = pSum; &#125; //output(p3); return p3; &#125; 结果","categories":[],"tags":[]},{"title":"牛客第三题","slug":"牛客第三题","date":"2022-04-16T15:20:18.000Z","updated":"2022-04-16T15:39:24.383Z","comments":true,"path":"2022/04/16/牛客第三题/","link":"","permalink":"http://example.com/2022/04/16/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%89%E9%A2%98/","excerpt":"","text":"今天又在牛客刷了一题，就单纯的想记录一下。 题目描述将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样你不能更改节点中的值，只能更改节点本身。 数据范围： 2000 0≤n≤2000 ， 20001≤k≤2000 ，链表中每个元素都满足 10000≤val≤1000要求空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)例如：给定的链表是 1→2→3→4→5对于 k &#x3D; 2k&#x3D;2 , 你应该返回 2→1→4→3→5对于 k &#x3D; 3k&#x3D;3 , 你应该返回 3→2→1→4→5 上码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static ListNode reverseKGroup (ListNode head, int k) &#123; /* * 我的大体思路就是每遍历k个节点就顺便放到栈里面，在栈里面把k个节点反转， * 然后再与后面的节点连起来 */ // write code here //如果链表为空或者k=1,就直接返回链表 if(head == null||k==1) &#123; return head; &#125; ListNode pre = head; ListNode temp=head,temp1= new ListNode(0); ListNode h =temp1,temp2=new ListNode(0); //用数组建一个栈，用来存k个节点 ListNode[] keyNode = new ListNode[k]; int keyCount = 0; int c=0; for(int i = 0;pre!=null;i++,keyCount++,c=i) &#123; if(i%k==0&amp;&amp;i!=0) &#123; temp2.next = keyNode[keyCount-1]; temp = keyNode[keyCount-1].next; for(int j = keyCount-1;j&gt;=0;j--) &#123; temp1.next = keyNode[j]; temp1 = keyNode[j]; &#125; temp2 = keyNode[0]; pre = temp; keyCount = 0; keyNode[keyCount] = pre; pre = pre.next; continue; &#125; //System.out.println(i); keyNode[keyCount] = pre; pre = pre.next; &#125; if(c&lt;k) &#123; return head; &#125; ListNode pp=null; if(c==k) &#123; for(int i = keyCount-1;i&gt;=0;i--) &#123; ListNode t = head.next; head.next = pp; pp = head; head = t; &#125; //output(pp); return pp; &#125; if(keyCount==k) &#123; for(int i = keyCount-1;i&gt;=0;i--) &#123;temp2.next = keyNode[i];temp2 = keyNode[i]; &#125; temp2.next=null; &#125;else &#123; for(int i = 0;i&lt;keyCount;i++) &#123; temp2.next = keyNode[i]; temp2 = keyNode[i]; &#125; &#125; //output(h); return h.next;&#125; 运行结果 这让我很意外","categories":[],"tags":[]},{"title":"AnswerPage","slug":"AnswerPage","date":"2022-04-15T01:13:10.000Z","updated":"2022-04-15T01:35:41.715Z","comments":true,"path":"2022/04/15/AnswerPage/","link":"","permalink":"http://example.com/2022/04/15/AnswerPage/","excerpt":"","text":"这两天小春同学向我求助帮他做一个答题网页。虽然感觉自己有很多事情都还没有做完，但是好哥们儿我肯定要帮啊。于是我就利用了三天的零碎时间做了这个网页，其实做完这个网页对我自己的收获也蛮大的。 AnswerPage需求：1、做一个由很多正方形组成的边框2、正方形边框里要有一个党徽在不断的移动3、让题目动态的显示，做完一题就可以进入下一题4、最后计算总分，用时其他的我就不多做赘述了，很多细节我已经写成注释混合在代码里了 上码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #content&#123;margin:20px auto 0px;&#125; .d2&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:40px;&#125; #contentbuttom&#123;margin:20px auto 0px;&#125; .d3&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:620px;&#125; #contentleft&#123;margin:20px auto 0px;&#125; .d4&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:10px; top:130px;&#125; #contentright&#123;margin:20px auto 0px;&#125; .d5&#123;width:80px;height:80px;color:white;text-align: center;font-size:14px; background:yellow; line-height:50px; position:absolute; left:1450px; top:130px;&#125; .move &#123; width: 80px; height: 80px; left:10px; top:40px; background-color: yellow; position: absolute; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function () &#123; var onOff = true; //获取body里面的div，返回值是数组 var d2 = document.getElementById(&#x27;content&#x27;).getElementsByTagName(&#x27;div&#x27;); var d3 = document.getElementById(&#x27;contentbuttom&#x27;).getElementsByTagName(&#x27;div&#x27;); var d4 = document.getElementById(&#x27;contentleft&#x27;).getElementsByTagName(&#x27;div&#x27;); var d5 = document.getElementById(&#x27;contentright&#x27;).getElementsByTagName(&#x27;div&#x27;); var d6 = document.getElementById(&#x27;mo&#x27;).getElementsByTagName(&#x27;div&#x27;); //生成最上面的墙(在id为content的div中生成17个div作为墙) function aa()&#123; document.getElementById(&#x27;content&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;17; i++)&#123; document.getElementById(&#x27;content&#x27;).innerHTML += &#x27;&lt;div class=&quot;d2&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d2[i].style.left = 10+(i*90)+&#x27;px&#x27;;//计算每个div间的距离 &#125; onOff = true; &#125; &#125; aa(); //生成最下面的墙(在id为contentbuttom的div中生成17个div作为墙) function bb()&#123; document.getElementById(&#x27;contentbuttom&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;17; i++)&#123; document.getElementById(&#x27;contentbuttom&#x27;).innerHTML += &#x27;&lt;div class=&quot;d3&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d3[i].style.left = 10+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; bb(); //生成左边的墙(在id为contentleft的div中生成5个div作为墙) function cc()&#123; document.getElementById(&#x27;contentleft&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;5; i++)&#123; document.getElementById(&#x27;contentleft&#x27;).innerHTML += &#x27;&lt;div class=&quot;d4&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d4[i].style.top = 150+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; cc(); //生成右边的墙(在id为contentright的div中生成5个div作为墙) function dd()&#123; document.getElementById(&#x27;contentright&#x27;).innerHTML = &#x27;&#x27;; if(onOff)&#123; for(var i=0; i&lt;5; i++)&#123; document.getElementById(&#x27;contentright&#x27;).innerHTML += &#x27;&lt;div class=&quot;d5&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; d5[i].style.top = 150+(i*90)+&#x27;px&#x27;; &#125; onOff = true; &#125; &#125; dd(); //生成党徽(在id为mo的div中生成一个放党徽的div) function ee()&#123; document.getElementById(&#x27;mo&#x27;).innerHTML = &#x27;&#x27;; document.getElementById(&#x27;mo&#x27;).innerHTML += &#x27;&lt;div id=&quot;mm&quot; class=&quot;move&quot;&gt;&#x27;+&#x27;&lt;img src=&quot;https://tse2-mm.cn.bing.net/th/id/OIP-C.w7iifmShxQ8WNVHgRsnTRgHaHE?w=213&amp;h=204&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.25&amp;pid=1.7&quot; width=&quot;80&quot; height=&quot;80&quot;&gt;&#x27;+&#x27;&lt;/div&gt;&#x27;; &#125; ee(); //以下代码为控制党徽不断的在墙面上移动 m = document.getElementById(&#x27;mm&#x27;);//获取党徽所在的div的id var num1 = 10,num2=150,num3=600,num4=620;//这里初始化党徽运动到每一面墙的初始值 var x = 0,y=0;//这里用来定位党徽的位置 var flagx1 = true,flagx2=false,flagy1 = false,flagy2=false;//辅助变量 setInterval(function ()&#123; //在最上面的墙上运动 if((x&gt;=0&amp;&amp;x&lt;17)&amp;&amp;y==0)&#123; num2=150; flagx1=true; flagx2=false; flagy2=false; flagy1=false; m.style.top = 40 +&quot;px&quot;; m.style.left = num1 + &#x27;px&#x27;; num1 = num1 +90; &#125; //在右边的墙上运动 if(x==17&amp;&amp;(y&gt;=0&amp;&amp;y&lt;5))&#123; num4=num1-90; flagy1=true; flagx1=false; flagx2=false; flagy2=false; m.style.top = num2 +&#x27;px&#x27;; num2 = num2 + 90; &#125; //在最下面的墙上运动 if((x&lt;=17&amp;&amp;x&gt;0)&amp;&amp;y==5)&#123; num3=num2-90; flagx1=false; flagx2=true; flagy2=false; flagy1=false; m.style.top = 620 +&#x27;px&#x27;; m.style.left = num4 +&#x27;px&#x27;; num4 = num4 -90; &#125; //在最左边的墙上运动 if(x==0&amp;&amp;(y&lt;=5&amp;&amp;y&gt;0))&#123; num1 = 10 flagx1=false; flagx2=false; flagy2=true; flagy1=false; m.style.top = num3 +&#x27;px&#x27;; num3 = num3 -90; &#125; if(flagx1==true)&#123; x++; &#125; if(flagx2==true)&#123; x--; &#125; if(flagy1==true)&#123; y++ &#125; if(flagy2==true)&#123; y--; &#125; &#125;,300) var num = 10; /* setInterval(function()&#123; m.style.left = num +&#x27;px&#x27;; num = num +90; &#125;,500)*/ &#125; function $(id)&#123;//拿到html页里相应的id对象（这里的$相当于函数名,固定用法） return document.getElementById(id); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body background=&quot;https://tse1-mm.cn.bing.net/th/id/OIP-C.-Q5IrwV8dZ3PxjXIXW_ypwHaE8?pid=ImgDet&amp;rs=1&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; var problems = new Array(9);//这个数组用来存放题目 problems[0] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[1] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[2] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; problems[3] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[4] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[5] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; problems[6] =&#123; titile:&quot;中国共产党是那一年成立的？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;B&quot; &#125; problems[7] =&#123; titile:&quot;五四运动发生在哪一年？&quot;, choice1:&quot;1922年&quot;, choice2:&quot;1921年&quot;, choice3:&quot;1919年&quot;, choice4:&quot;1920年&quot;, answer:&quot;C&quot; &#125; problems[8] =&#123; titile:&quot;新中国在哪一年成立？&quot;, choice1:&quot;1945年&quot;, choice2:&quot;1948年&quot;, choice3:&quot;1950年&quot;, choice4:&quot;1949年&quot;, answer:&quot;D&quot; &#125; var arr = problems; var score_sum=0;//计分 // arr.push(problem1); //arr.push(problem2); //arr.push(problem3); for(let i=0;i&lt;3;i++)&#123; &#125; var k =0; var flag=false; //这些变量用来存放开始时间 var start_h=0 var start_m=0 var start_s=0 //这个函数用来控制下一题 function fun()&#123; judge(k,arr);//每点一次下一题按钮判断一次选项的值 k++; if(k==arr.length)&#123;//如果题目全部做完就把form删了，显示得分、用时 // alert(&quot;答题完毕！ &quot;+&quot;总得分：&quot;+score_sum); del(); var endtime = new Date(); var end_h = endtime.getHours(); var end_m = endtime.getMinutes(); var end_s = endtime.getSeconds(); var total_m=0; var total_s=0; //alert(&quot;结束时间：&quot;+end_m+&quot;分 &quot;+end_s+&quot;秒&quot;); //得到正确的时间 if(end_h!=start_h)&#123; total_m = (60-start_h)+end_m; if(end_m!=start_m)&#123; total_s = (60-start_s)+end_s; &#125;else&#123; total_s = end_s - start_s; &#125; &#125;else&#123; total_m = end_m - start_m; if(end_m!=start_m)&#123; total_s = (60-start_s)+end_s; &#125;else&#123; total_s = end_s - start_s; &#125; &#125; if(total_m&gt;0)&#123; total_m = total_m - 1; &#125; //alert(&quot;用时&quot;+total_m+&quot;分&quot;+total_s+&quot;秒&quot;); $(&#x27;replace&#x27;).innerHTML += &#x27;&lt;div style=&quot;margin-left: 150px;margin-top:150px; font-size:50px;color: rgb(23, 18, 168);&quot;&gt;&#x27;+&quot;总得分：&quot;+score_sum+ &quot;分 用时&quot;+total_m+ &quot;分钟&quot; +total_s+&#x27;秒&lt;/div&gt;&#x27;; &#125; //以下控制题目变化 document.getElementById(&#x27;a1&#x27;).innerHTML=arr[k].titile; document.getElementById(&#x27;a2&#x27;).innerHTML=arr[k].choice1; document.getElementById(&#x27;a3&#x27;).innerHTML=arr[k].choice2; document.getElementById(&#x27;a4&#x27;).innerHTML=arr[k].choice3; document.getElementById(&#x27;a5&#x27;).innerHTML=arr[k].choice4; //k++; &#125; function del()&#123;//删除form var elem = document.getElementById(&quot;myform&quot;); elem.parentNode.removeChild(elem); &#125; function judge(k,arr)&#123;//判断选项 var obj = document.getElementsByName(&#x27;ch&#x27;); var len = obj.length; //alert(k+&quot; &quot;+arr[k].answer); // alert(len) for(let j=0;true;j++)&#123; if(obj[j].checked==true)&#123; if(obj[j].value==arr[k].answer)&#123; score_sum = score_sum + 5; &#125; //alert(&quot;已选择&quot;+obj[j].value+&quot; 目前得分&quot;+score_sum); break; &#125; &#125; &#125; function au()&#123;//显示第一题 document.getElementById(&#x27;a1&#x27;).innerHTML=arr[0].titile; document.getElementById(&#x27;a2&#x27;).innerHTML=arr[0].choice1; document.getElementById(&#x27;a3&#x27;).innerHTML=arr[0].choice2; document.getElementById(&#x27;a4&#x27;).innerHTML=arr[0].choice3; document.getElementById(&#x27;a5&#x27;).innerHTML=arr[0].choice4; var starttime = new Date(); //获取开始时间 start_h = starttime.getHours(); start_m = starttime.getMinutes(); start_s = starttime.getSeconds(); //alert(&quot;开始时间：&quot;+start_m+&quot;分 &quot;+start_s+&quot;秒&quot;); //judge(0,arr); &#125; setTimeout(&quot;au()&quot;,1);//刚打开页面就显示第一个题目&lt;/script&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentbuttom&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentleft&quot;&gt;&lt;/div&gt;&lt;div id=&quot;contentright&quot;&gt;&lt;/div&gt;&lt;div id=&quot;mo&quot;&gt;&lt;/div&gt;&lt;div id=&quot;replace&quot;&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 500px;margin-top:300px; font-size:50px; color: rgb(134, 134, 137); position: absolute;&quot;&gt;我们一起来做题&lt;/div&gt;&lt;form style=&quot;margin-left: 200px;margin-top:200px;color: rgb(23, 18, 168);font-size: 20px;font-weight: bold;&quot; name=&quot;myform&quot; id=&quot;myform&quot;&gt;题目：&lt;label &gt;&lt;p id=&quot;a1&quot;&gt;&lt;/p&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;A&quot;&gt;A、&lt;label id=&quot;a2&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;B&quot;&gt;B、&lt;label id=&quot;a3&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;C&quot;&gt;C、&lt;label id=&quot;a4&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;ch&quot; value=&quot;D&quot;&gt;D、&lt;label id=&quot;a5&quot;&gt;&lt;/label&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; onclick=&quot;fun()&quot; name=&quot;next&quot; value=&quot;下一题&quot; style=&quot;font-size: 20px;color: blue;&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"反转链表","slug":"反转链表","date":"2022-04-10T01:24:55.000Z","updated":"2022-04-10T14:11:27.338Z","comments":true,"path":"2022/04/10/反转链表/","link":"","permalink":"http://example.com/2022/04/10/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"今天心血来潮想刷点题，于是就注册了牛客。没想到第一个题就是反转链表，啊这不是so easy吗。我火急火燎的就写完提交，没想到运行时间116ms,占用内存高达12948KB。代码我是用java写的，我看一些大神用Rust,C写竟然只花了2ms,300多KB,简直太牛了。后来我去看了一些题解把代码改进了一下，不用再去new空间，直接将原结点的指针反过来就ok了。 上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package p1;import java.util.Scanner;public class reverseLink &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ListNode h = create_list(); //output(h); ReverseList(h); &#125; public static ListNode create_list() &#123; Scanner input = new Scanner(System.in); int x=input.nextInt(); ListNode p=null,p1=null; ListNode h=new ListNode(input.nextInt()); p1=h; for(int i=0;i&lt;x-1;i++) &#123; p = new ListNode(input.nextInt()); p1.next = p; p1=p; p.next = null; &#125; return h; &#125; public static void output(ListNode h) &#123; while(h!=null) &#123; System.out.println(h.val); h=h.next; &#125; &#125; public static ListNode ReverseList(ListNode head) &#123; ListNode p=null,temp=null; //最巧的就是这个循环了 while(head!=null) &#123; //先让temp指向head.next节点,用来遍历链表 temp = head.next; //head.next指针指向p head.next = p; //让p指向head这个节点，这样下次循环的节点就可以和现在的节点连起来了 p = head; //这里再把刚刚temp保存的地址赋给head，继续遍历下一个节点 head = temp; &#125; while(p!=null) &#123; System.out.println(p.val); p=p.next; &#125; return new ListNode(1); &#125;&#125;class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 运行结果","categories":[],"tags":[]},{"title":"java编译器","slug":"java编译器","date":"2022-04-02T17:24:55.000Z","updated":"2022-04-02T17:53:14.675Z","comments":true,"path":"2022/04/03/java编译器/","link":"","permalink":"http://example.com/2022/04/03/java%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"java编译器今天偶然在网上看到一个java项目，就是用Java写一个Java编译器，只要会Javase就可以做。主要用到java里的几个包比如swing、io等。啊这不就很适合我做吗，于是我就跟着教程手敲了这个程序。由于时间问题，我就不写思路了，还有源代码我没有写注释，等有时间再来写吧。 FileWindow.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.Lijinchao.myedit;import java.awt.CardLayout;、import java.awt.Color;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.BufferedInputStream;import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JTextArea;import javax.swing.JTextField;public class FileWindow extends JFrame implements ActionListener,Runnable &#123; Thread compiler = null; Thread run_prom = null; boolean bn = true; CardLayout mycard; File file_saved = null; JButton button_input_txt, button_compiler_text, button_compiler, button_run_prom, button_see_doswin; JPanel p = new JPanel(); JTextArea input_text = new JTextArea(); JTextArea compiler_text = new JTextArea(); JTextArea dos_out_text = new JTextArea(); JTextField input_file_name_text = new JTextField(); JTextField run_file_name_text = new JTextField(); public FileWindow() &#123; super(&quot;JavaCompiler&quot;); mycard = new CardLayout(); compiler = new Thread(this); run_prom = new Thread(this); button_input_txt = new JButton(&quot;程序输入区(white)&quot;); button_compiler_text = new JButton(&quot;编译结果区(pink)&quot;); button_see_doswin = new JButton(&quot;程序执行结果(wathet)&quot;); button_compiler = new JButton(&quot;Compiler&quot;); button_run_prom = new JButton(&quot;Running&quot;); p.setLayout(mycard); p.add(&quot;input&quot;,input_text); p.add(&quot;compiler&quot;,compiler_text); p.add(&quot;dos&quot;,dos_out_text); add(p,&quot;Center&quot;); compiler_text.setBackground(Color.pink); dos_out_text.setBackground(Color.cyan); JPanel p1 = new JPanel(); p1.setLayout(new GridLayout(3,3)); p1.add(button_input_txt); p1.add(button_compiler_text); p1.add(button_see_doswin); p1.add(new JLabel(&quot;输入程序名称(.java)&quot;)); p1.add(input_file_name_text); p1.add(button_compiler); p1.add(new JLabel(&quot;输入程序主类名&quot;)); p1.add(run_file_name_text); p1.add(button_run_prom); add(p1,&quot;North&quot;); button_input_txt.addActionListener(this); button_compiler.addActionListener(this); button_compiler_text.addActionListener(this); button_run_prom.addActionListener(this); button_see_doswin.addActionListener(this); &#125; public void actionPerformed(ActionEvent e) &#123; if(e.getSource()==button_input_txt) &#123; mycard.show(p,&quot;input&quot;); &#125;else if(e.getSource()==button_compiler_text) &#123; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_see_doswin) &#123; mycard.show(p, &quot;dos&quot;); &#125;else if(e.getSource()==button_compiler) &#123; if(!(compiler.isAlive())) &#123; compiler = new Thread(this); &#125; try &#123; compiler.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;compiler&quot;); &#125;else if(e.getSource()==button_run_prom) &#123; if(!(run_prom.isAlive())) &#123; run_prom = new Thread(this); &#125; try &#123; run_prom.start(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; mycard.show(p, &quot;dos&quot;); &#125; &#125; public void run() &#123; if(Thread.currentThread()==compiler) &#123; compiler_text.setText(null); String temp = input_text.getText().trim(); byte [] buffer = temp.getBytes(); int b = buffer.length; String file_name = null; file_name = input_file_name_text.getText().trim(); try &#123; file_saved = new File(file_name); FileOutputStream writefile = null; writefile = new FileOutputStream(file_saved); writefile.write(buffer, 0, b); writefile.close(); &#125;catch (Exception e) &#123; System.out.println(&quot;ERROR&quot;); &#125; try &#123; Runtime rt = Runtime.getRuntime(); InputStream in = rt.exec(&quot;javac &quot;+file_name).getErrorStream(); BufferedInputStream bufIn = new BufferedInputStream(in); byte[] shuzu = new byte[100]; int n=0; boolean flag = true; while((n=bufIn.read(shuzu,0,shuzu.length))!=-1) &#123; String s = null; s = new String(shuzu,0,n); compiler_text.append(s); if(s!=null) &#123; flag = false; &#125; &#125; if(flag) &#123; compiler_text.append(&quot;Compiler Succeed!&quot;); &#125; &#125; catch (Exception e) &#123; &#125; &#125; else if(Thread.currentThread()==run_prom) &#123; dos_out_text.setText(null); try &#123; Runtime rt = Runtime.getRuntime(); String path = run_file_name_text.getText().trim(); Process stream = rt.exec(&quot;java &quot;+path); InputStream in = stream.getInputStream(); BufferedInputStream bisErr = new BufferedInputStream(stream.getErrorStream()); BufferedInputStream bisIn = new BufferedInputStream(in); byte[] buf = new byte[150]; byte[] err_buf = new byte[150]; int m=0; int i=0; String s = null; String err = null; while((m = bisIn.read(buf, 0, 150))!=-1) &#123; s = new String(buf,0,150); dos_out_text.append(s); &#125; while((i = bisErr.read(err_buf))!=-1) &#123; &#123; err = new String(err_buf,0,150); dos_out_text.append(err); &#125; &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; Main.java12345678910111213141516171819202122package com.Lijinchao.myedit;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub FileWindow win = new FileWindow(); win.pack(); win.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); win.setBounds(200,180,550,360); win.setVisible(true); &#125;&#125; 运行结果点Running出现这样的画面就说明没问题了 正确运行需要在程序输入区输入代码，记住程序名称一定要.java作为后缀,并且程序名称一定要和主类名同名，主类名没有后缀。 1.先在程序输入区写好代码 2.点击Compiler编译 3.点击Running运行","categories":[],"tags":[]},{"title":"利用python爬取网页表情包","slug":"python爬虫","date":"2022-03-26T07:11:26.000Z","updated":"2022-04-15T01:39:34.806Z","comments":true,"path":"2022/03/26/python爬虫/","link":"","permalink":"http://example.com/2022/03/26/python%E7%88%AC%E8%99%AB/","excerpt":"","text":"今天刷着刷着视频，突然刷到一个关于python爬虫的视频，瞬间激起了我对爬虫的好奇心。刚好我以前学过一点python的知识，这会儿终于派上用场了。于是我上网借鉴了一些资料写了这个爬虫代码 requests,re知识想要写爬虫代码我们需要先了解这两个包。requests是一个很实用的python HTTP客户端库，编写爬虫这个包必不可少。这是我们常用的方法：requests.get()：获取HTML网页的主要方法，对应于HTTP的GET。re模块创建一个“规则表达式”，用于验证和查找符合规则的文本，广泛用于各种搜索引擎，账号密码的验证等。这是我们常用的两个方法：findall：扫描整个目标文本，返回所有与规则匹配的子串组成的列表，如果没有匹配的返回空列表。split：从与规则匹配的子串进行切割，返回切割后子串组成的列表。 爬虫编写步骤找表情包网站https://www.biaoqingba.net/hot.html 这个网址就是我爬表情包的网站，每个网站都有自己的HTML网页，所以我们需要简单的分析一下网页的HTML代码，便于写正则表达式，这里我就不多说了，直接看图。 获取URL，并且发起请求首先，我们想要下载表情包，就需要先获取网页的url，get方法里的网址就是url，可以上百度找到一个网页，然后复制链接就好。requests.get()就发起了一个请求。 1response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;) 利用正则表达式筛选数据在img标签中提取我们想要的内容，比如表情包的url,名字等 123re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text) 保存数据这里我们写一个download方法来保存数据。 12345678910111213# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix) 这里是源代码123456789101112131415161718192021222324252627282930313233343536373839import reimport osimport requests# https://www.biaoqingba.net/hot.html，这是我爬表情包的网页# 创建一个文件用来放表情包，images为文件名images = &#x27;images&#x27;# 如果文件不存在，就新建一个if not os.path.exists(images): os.mkdir(images)# 此函数用来下载一个表情def download(name, url): # name为表情的名字，url为表情的链接 # 请求网页 response = requests.get(url) print(response.status_code) # 200 表示请求成功 #获取表情包的文件后缀 suffix = url.split(&#x27;.&#x27;)[-1] # 这里处理一下异常，可能会出现某些内容太长保存不了， try: with open(images + &#x27;/&#x27; + name + &#x27;.&#x27; + suffix, mode=&#x27;wb&#x27;) as file: file.write(response.content) except: print(&quot;保存失败：&quot;, name + &#x27;.&#x27; + suffix)response = requests.get(&#x27;https://www.biaoqingba.net/hot.html&#x27;)# print(response.text) 打印所请求网页的内容，其实就是网页的实现代码# 这行代码用了正则表达式来提取img标签的内容，src的引号内就是表情包链接，(.*?)表示# 只要是引号内的内容都要re_temp = &#x27;&lt;img class=&quot;hot-img&quot; src=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; title=&quot;(.*?)&quot;&gt;&#x27;# 查找网页的所有内容，按照re_temp的规则提取我们想要的内容result = re.findall(re_temp, response.text)# print(result)# 循环获取result数组内的每个元素，调用download函数下载表情包for img in result: print(img) download(img[1], img[0]) # img[1]为name,img[0]为url 运行结果爬了满满一文件夹的表情包，真爽！","categories":[],"tags":[]},{"title":"Socket","slug":"page","date":"2022-03-21T01:34:55.000Z","updated":"2022-04-02T16:53:05.986Z","comments":true,"path":"2022/03/21/page/","link":"","permalink":"http://example.com/2022/03/21/page/","excerpt":"","text":"什么是Socket呢？Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。简言之，我们的QQ或者微信发送消息和接受消息的功能，底层就是用Socket实现的。废话不多说，直接上代码。 服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package SeverAndClient;/** * @author 超 * 这里是服务器，开启两个线程，一个是接收消息的，一个是发送消息的 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.Scanner;public class sever extends Thread&#123; ServerSocket server = null;//先定义一个服务Socket Socket socket = null; public sever(int port) &#123;//直接利用构造方法传入端口号 try &#123; server = new ServerSocket(port);//实例化ServerSocket &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run()&#123; super.run(); try&#123; System.out.println(&quot;wait client connect...&quot;); socket = server.accept();//等待客户端连接 new sendMessThread().start();//连接并返回socket后，再启用发送消息线程 System.out.println(socket.getInetAddress().getHostAddress()+&quot;SUCCESS TO CONNECT...&quot;); InputStream in = socket.getInputStream();//利用IO流获取信息 int len = 0; byte[] buf = new byte[1024];//这个用来缓冲数据 while ((len=in.read(buf))!=-1)&#123; System.out.println(&quot;client saying: &quot;+new String(buf,0,len)); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //这个就是发送消息的线程 class sendMessThread extends Thread&#123; @Override public void run()&#123; super.run(); Scanner scanner=null; OutputStream out = null; try&#123; if(socket != null)&#123; scanner = new Scanner(System.in); out = socket.getOutputStream(); String in = &quot;&quot;; do &#123; in = scanner.next();//输入数据 out.write((&quot;server saying: &quot;+in).getBytes()); out.flush();//清空缓存区的内容 &#125;while (!in.equals(&quot;q&quot;)); scanner.close(); try&#123; out.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; sever server = new sever(1234); server.start();//启动线程 &#125;&#125; 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package SeverAndClient;/** * @author 超 * 这里是客户端 */import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;public class client extends Thread &#123; //定义一个Socket对象 Socket socket = null; public client(String host, int port) &#123; try &#123; //需要服务器的IP地址和端口号，才能获得正确的Socket对象 socket = new Socket(host, port);//host为服务器的ip地址，port为服务器的端口号 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; //客户端一连接就可以写数据个服务器了 new sendMessThread().start(); super.run(); try &#123; // 读Sock里面的数据 InputStream s = socket.getInputStream(); byte[] buf = new byte[1024];//缓冲数据 int len = 0; while ((len = s.read(buf)) != -1) &#123; System.out.println(new String(buf, 0, len)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //往Socket里面写数据，需要新开一个线程 class sendMessThread extends Thread&#123; @Override public void run() &#123; super.run(); //写操作 Scanner scanner=null; OutputStream os= null; try &#123; scanner=new Scanner(System.in); os= socket.getOutputStream(); String in=&quot;&quot;; do &#123; in=scanner.next();//输入数据 os.write((&quot;&quot;+in).getBytes()); os.flush(); &#125; while (!in.equals(&quot;bye&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; scanner.close(); try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //函数入口 public static void main(String[] args) &#123; //需要服务器的正确的IP地址和端口号 client clientTest=new client(&quot;127.0.0.1&quot;, 8000);//127.0.0.1为测试专用ip,如果你想连另一台主机，就把ip换了 clientTest.start();//启动线程 &#125;&#125; 运行结果记住！一定要先运行服务器。","categories":[],"tags":[]}],"categories":[],"tags":[]}